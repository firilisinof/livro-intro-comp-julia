{
  "hash": "95dedac0640370480b7cb7889433cea9",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n# Testes Automatizados {#sec-testes}\n\nDesenvolvemos diversos algoritmos recursivos e, para verificar se eles funcionavam corretamente, realizamos testes manuais executando as funções com diferentes entradas e verificando seus resultados. No entanto, à medida que nossos programas se tornam mais complexos, essa abordagem manual se torna ineficiente e propensa a erros. Neste capítulo, introduziremos o conceito de testes automatizados, que nos permitirá verificar de forma sistemática e confiável se nossas funções estão operando como esperado.\n\n## Por que Testar?\n\nQuando escrevemos código, queremos ter certeza de que ele está funcionando corretamente. Os testes automatizados nos ajudam a:\n\n1. Verificar se o código produz os resultados esperados para diferentes entradas\n2. Identificar bugs e erros antes que o programa seja utilizado\n3. Garantir que modificações no código não quebrem funcionalidades existentes\n4. Documentar o comportamento esperado de nossas funções\n\nEm desenvolvimento de software, uma prática comum é o TDD (_Test-Driven Development_), onde primeiro escrevemos os testes e depois implementamos o código que satisfaz esses testes. Esta abordagem incentiva um design mais claro e uma melhor compreensão dos requisitos antes mesmo de começar a programar.\n\n## Escrevendo Testes Com Condicionais\n\nVamos começar com uma abordagem mais simples para criar testes automatizados usando estruturas condicionais. Consideraremos o \"Problema das Escadas\" que vimos no capítulo anterior.\n\nRelembrando, o problema consistia em determinar de quantas maneiras diferentes podemos subir uma escada com $n$ degraus, se podemos dar passos de 1 ou 2 degraus por vez. Nossa solução foi:\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction maneiras_subir_escada(n)\n    # Casos base\n    if n == 0 || n == 1\n        return 1\n    else\n        # Caso recursivo: soma das maneiras de chegar a partir de n-1 e n-2\n        return maneiras_subir_escada(n - 1) + maneiras_subir_escada(n - 2)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nmaneiras_subir_escada (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAgora, vamos criar uma função de teste para verificar se nossa implementação está correta:\n\n\n\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction testa_maneiras_subir_escada()\n    # Geralmente, verificamos alguns casos conhecidos ou que sabemos a resposta\n    if maneiras_subir_escada(1) != 1\n        println(\"Erro para n = 1\")\n        return false\n    end\n    \n    if maneiras_subir_escada(2) != 2\n        println(\"Erro para n = 2\")\n        return false\n    end\n    \n    if maneiras_subir_escada(3) != 3\n        println(\"Erro para n = 3\")\n        return false\n    end\n    \n    if maneiras_subir_escada(4) != 5\n        println(\"Erro para n = 4\")\n        return false\n    end\n    \n    println(\"Todos os testes para a função maneiras_subir_escada passaram!\")\n    return true\nend\n\n# Executamos os testes\ntesta_maneiras_subir_escada()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTodos os testes para a função maneiras_subir_escada passaram!\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNesta função de teste, verificamos se a nossa implementação retorna os valores corretos para diferentes entradas. Se algum teste falhar, exibimos uma mensagem indicando qual caso falhou. Se todos os testes passarem, exibimos uma mensagem de sucesso.\n\nEste é um princípio importante para testes automatizados: **se o teste passar, ele deve indicar apenas que deu certo!** Isso significa que, idealmente, os testes não devem imprimir muitas mensagens quando tudo estiver funcionando corretamente, apenas quando algo der errado.\n\nVamos fazer o mesmo para o cálculo do \"Coeficiente Binomial\", que também vimos no capítulo anterior:\n\n\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction coeficiente_binomial(n, k)\n    if k == 0 || k == n\n        return 1\n    else\n        return coeficiente_binomial(n - 1, k - 1) + coeficiente_binomial(n - 1, k)\n    end\nend\n\nfunction testa_coeficiente_binomial()\n    if coeficiente_binomial(5, 2) != 10\n        println(\"Erro para (5, 2)\")\n        return false\n    end\n    \n    if coeficiente_binomial(10, 4) != 210\n        println(\"Erro para (10, 4)\")\n        return false\n    end\n    \n    if coeficiente_binomial(7, 3) != 35\n        println(\"Erro para (7, 3)\")\n        return false\n    end\n    \n    println(\"Todos os testes para a função coeficiente_binomial passaram!\")\n    return true\nend\n\n# Executamos os testes\ntesta_coeficiente_binomial()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTodos os testes para a função coeficiente_binomial passaram!\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n\n\n\n\n\n## Testes com o Módulo Test\n\nAté agora, criamos funções de teste manualmente usando estruturas condicionais. No entanto, Julia fornece um módulo de testes integrado chamado `Test`, que oferece funcionalidades mais avançadas para testes automatizados.\n\nVamos reescrever nossos testes usando o módulo `Test`:\n\n\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\n\n@testset \"Testes para maneiras_subir_escada\" begin\n    @test maneiras_subir_escada(1) == 1\n    @test maneiras_subir_escada(2) == 2\n    @test maneiras_subir_escada(3) == 3\n    @test maneiras_subir_escada(4) == 5\nend\n\n@testset \"Testes para coeficiente_binomial\" begin\n    @test coeficiente_binomial(5, 2) == 10\n    @test coeficiente_binomial(10, 4) == 210\n    @test coeficiente_binomial(7, 3) == 35\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest Summary:                     | Pass  Total  Time\nTestes para maneiras_subir_escada |    4      4  0.1s\nTest Summary:                    | Pass  Total  Time\nTestes para coeficiente_binomial |    3      3  0.0s\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nTest.DefaultTestSet(\"Testes para coeficiente_binomial\", Any[], 3, false, false, true, 1.748035029505524e9, 1.748035029505552e9, false, \"/Users/lucas/Desktop/livro-intro-comp-julia/06-testes-automatizados.qmd\")\n```\n:::\n:::\n\n\n\n\n\n\n\n\nCom o módulo `Test`, utilizamos a macro `@testset` para agrupar testes relacionados e a macro `@test` para verificar condições específicas. Se um teste falha, o módulo exibe automaticamente informações úteis sobre a falha, como a expressão que falhou e os valores esperados versus os valores obtidos.\n\nAlém disso, o módulo `Test` oferece outras macros úteis:\n\n- `@test_throws`: verifica se uma expressão lança uma exceção específica\n- `@test_approx_eq`: verifica se dois valores de ponto flutuante são aproximadamente iguais (considerando erros de arredondamento)\n- `@test_broken`: marca um teste que é esperado falhar (útil para documentar bugs conhecidos)\n\n## Mais Exemplos\n\nVamos implementar duas novas funções e seus respectivos testes: uma função para calcular a soma dos dígitos de um número e outra para verificar se um número é primo.\n\n### Soma dos Dígitos\n\nPrimeiramente, vamos criar uma função que calcula a soma dos dígitos de um número inteiro. Por exemplo, para o número 123, a soma dos dígitos seria 1 + 2 + 3 = 6.\n\nAntes de implementar a função, vamos pensar nos casos de teste:\n\n- Se a função recebe um inteiro de um único dígito ela deve retornar esse dígito\n- Se a função recebe 100, ela deve retornar 1 + 0 + 0 = 1\n- Se a função recebe 123, ela deve retornar 1 + 2 + 3 = 6\n- Se a função recebe 99, ela deve retornar 9 + 9 = 18\n\nPodemos implementar a função usando recursão. A ideia é \"descascar\" o número, extraindo um dígito de cada vez:\n\n\n\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction soma_digitos(n)\n    if n <= 0\n        return 0\n    else\n        # Obtemos o último dígito com o resto da divisão por 10\n        ultimo_digito = n % 10\n        # Removemos o último dígito com a divisão inteira por 10\n        resto_numero = n ÷ 10\n        # Somamos o último dígito com a soma dos dígitos do resto do número\n        return ultimo_digito + soma_digitos(resto_numero)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsoma_digitos (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOs casos de teste discutidos acima podem ser implementados utilizando o módulo `Test`:\n\n\n\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n@testset \"Testes para soma_digitos\" begin\n    @test soma_digitos(0) == 0\n    @test soma_digitos(1) == 1\n    @test soma_digitos(100) == 1\n    @test soma_digitos(123) == 6\n    @test soma_digitos(99) == 18\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest Summary:            | Pass  Total  Time\nTestes para soma_digitos |    5      5  0.0s\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nTest.DefaultTestSet(\"Testes para soma_digitos\", Any[], 5, false, false, true, 1.748035029692338e9, 1.7480350296948e9, false, \"/Users/lucas/Desktop/livro-intro-comp-julia/06-testes-automatizados.qmd\")\n```\n:::\n:::\n\n\n\n\n\n\n\n\n### Verificação de Números Primos\n\nVamos criar uma função para verificar se um número é primo. Um número primo é aquele que é divisível apenas por 1 e por ele mesmo. Antes de escrever a função vamos pensar nos testes:\n\n- Por definição, qualquer número menor ou igual a 1 não é primo\n- O número 2 é primo (fácil de verificar)\n- O número 3 é primo (também fácil de verificar)\n- O número 4 não é primo, pois 2 também divide 4\n- O número 17 é primo\n- O número 25 não é primo, pois 5 também divide 25\n\nPodemos implementar a função usando uma abordagem recursiva que tenta dividir o número por cada inteiro de 2 até a raiz quadrada do número:\n\n\n\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction verifica_divisor(n, divisor)\n    # Se encontramos um divisor, o número não é primo\n    if n % divisor == 0\n        return false\n    # Se já testamos até a raiz quadrada, o número é primo\n    elseif divisor * divisor > n\n        return true\n    else\n        # Continua verificando com o próximo divisor\n        return verifica_divisor(n, divisor + 1)\n    end\nend\n\nfunction e_primo(n)\n    if n <= 1 # Por definição\n        return false\n    elseif n == 2 # Primeiro primo\n        return true\n    else\n        # Verifica se n tem algum divisor começando com 2\n        return verifica_divisor(n, 2)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ne_primo (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOs testes podem ser escritos como:\n\n\n\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\n@testset \"Testes para e_primo\" begin\n    @test e_primo(2) == true\n    @test e_primo(3) == true\n    @test e_primo(4) == false\n    @test e_primo(17) == true\n    @test e_primo(25) == false\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest Summary:       | Pass  Total  Time\nTestes para e_primo |    5      5  0.0s\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nTest.DefaultTestSet(\"Testes para e_primo\", Any[], 5, false, false, true, 1.748035029705952e9, 1.748035029712738e9, false, \"/Users/lucas/Desktop/livro-intro-comp-julia/06-testes-automatizados.qmd\")\n```\n:::\n:::\n\n\n\n\n\n\n\n\n## Verifique seu Aprendizado\n\n1. Qual é a diferença entre usar estruturas condicionais e o módulo Test para testes automatizados?\n2. Por que os testes automatizados são importantes no desenvolvimento de software?\n\n## Explore por Conta Própria\n\n1. Explore outras macros disponíveis no módulo Test de Julia e experimente usá-las em seus próprios testes.\n\n",
    "supporting": [
      "06-testes-automatizados_files"
    ],
    "filters": [],
    "includes": {}
  }
}