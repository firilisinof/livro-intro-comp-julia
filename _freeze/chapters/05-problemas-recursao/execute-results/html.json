{
  "hash": "28a857d05afa132088fff97dc206b01a",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n\n\n# Mais Problemas Envolvendo Recursão\n\nNo capítulo anterior, introduzimos o conceito de recursão e vimos como funções podem chamar a si mesmas para resolver problemas. Neste capítulo, vamos explorar mais alguns problemas que podem ser resolvidos utilizando recursão, o que nos ajudará a desenvolver nossa capacidade de \"pensar recursivamente\".\n\n## Pensando Recursivamente\n\nResolver problemas usando recursão requer uma mudança na forma como enxergamos os problemas. Em vez de pensar em todos os passos necessários para chegar à solução, focamos em:\n\n1. Como expressar o problema em termos de uma versão menor do mesmo problema\n2. Quando parar a recursão (caso base)\n\nVamos explorar quatro problemas que ilustram bem o poder da recursão: o problema das escadas, a potenciação por quadrados, o cálculo da raiz quadrada usando o método de Heron e o coeficiente binomial.\n\n## Problema das Escadas\n\nImagine uma escada com $n$ degraus. Você pode subir 1 ou 2 degraus por vez. De quantas maneiras diferentes você pode chegar ao topo da escada?\n\nPor exemplo, se temos uma escada com 3 degraus, existem 3 maneiras de subir:\n\n- Dar três passos de 1 degrau: (1, 1, 1)\n- Dar um passo de 1 degrau seguido de um passo de 2 degraus: (1, 2)\n- Dar um passo de 2 degraus seguido de um passo de 1 degrau: (2, 1)\n\nComo podemos pensar nesse problema recursivamente? Para chegar ao degrau $n$, devemos ter vindo do degrau $n-1$ (dando um passo de 1 degrau) ou do degrau $n-2$ (dando um passo de 2 degraus). Portanto, o número total de maneiras de chegar ao degrau $n$ é a soma do número de maneiras de chegar ao degrau $n-1$ e ao degrau $n-2$.\n\nNossos casos base são:\n\n- Se $n = 0$ (nenhum degrau): há 1 maneira (não subir)\n- Se $n = 1$ (um degrau): há 1 maneira (dar um passo de 1 degrau)\n\nVamos implementar essa solução:\n\n\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction maneiras_subir_escada(n)\n    # Casos base\n    if n == 0 || n == 1\n        return 1\n    else\n        # Caso recursivo: soma das maneiras de chegar a partir de n-1 e n-2\n        return maneiras_subir_escada(n - 1) + maneiras_subir_escada(n - 2)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nmaneiras_subir_escada (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nVamos testar nosso código para diferentes números de degraus:\n\n\n\n\n\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nfor i in 1:10\n    println(\"Escada com $i degraus: $(maneiras_subir_escada(i)) maneiras diferentes\")\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEscada com 1 degraus: 1 maneiras diferentes\nEscada com 2 degraus: 2 maneiras diferentes\nEscada com 3 degraus: 3 maneiras diferentes\nEscada com 4 degraus: 5 maneiras diferentes\nEscada com 5 degraus: 8 maneiras diferentes\nEscada com 6 degraus: 13 maneiras diferentes\nEscada com 7 degraus: 21 maneiras diferentes\nEscada com 8 degraus: 34 maneiras diferentes\nEscada com 9 degraus: 55 maneiras diferentes\nEscada com 10 degraus: 89 maneiras diferentes\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nNote que estamos usando uma estrutura diferente, `for`. Não se preocupe com os detalhes dessa estrutura no momento, mas saiba que estamos apenas repetindo a execução de um bloco de código.\n\nSe você olhar atentamente para essa sequência de resultados, perceberá que ela corresponde à famosa sequência de Fibonacci: $(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, \\dots)$. Isso não é coincidência. O problema da escada e a sequência de Fibonacci compartilham a mesma estrutura recursiva.\n\n## Potenciação por Quadrados\n\nQuando queremos calcular potências como $a^n$, a abordagem mais simples seria multiplicar $a$ por si mesmo $n$ vezes. Por exemplo, para calcular $2^8$, faríamos $2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2$, realizando 7 multiplicações. Mas existe uma abordagem muito mais eficiente usando recursão.\n\nO método de potenciação por quadrados que vamos apresentar consegue calcular o mesmo valor realizando apenas cerca de $\\log_2 n$ operações. Por exemplo, para calcular $2^8$, precisaríamos apenas de 3 multiplicações. Para números grandes, essa diferença é ainda mais significativa - calcular $2^{1000}$ exigiria 999 multiplicações com o método simples, mas apenas cerca de 10 multiplicações com nosso método recursivo.\n\nA ideia baseia-se nas seguintes propriedades matemáticas:\n\n- Se $n$ é negativo: $a^n = 1 / a^{-n}$ (invertemos o resultado da potência positiva)\n- Se $n$ é par: $a^n = (a^{n/2})^2$ (calculamos a \"metade\" da potência e elevamos ao quadrado)\n- Se $n$ é ímpar: $a^n = a \\times a^{n-1}$ (multiplicamos por uma potência par, que sabemos calcular)\n\nComo isso se traduz para o pensamento recursivo?\n\n1. Se queremos calcular $a^n$ e $n$ é par:\n   - Primeiro calculamos $a^{n/2}$ (um problema menor)\n   - Depois multiplicamos esse resultado por si mesmo\n\n2. Se queremos calcular $a^n$ e $n$ é ímpar:\n   - Primeiro calculamos $a^{n-1}$ (que é par e sabemos resolver pelo caso anterior)\n   - Depois multiplicamos esse resultado por $a$\n\n3. Se queremos calcular $a^n$ e $n$ é negativo:\n   - Calculamos $a^{-n}$ (sabemos resolver pelos casos anteriores)\n   - Depois calculamos $1 / a^{-n}$\n\nNossos casos base (onde a recursão para) são:\n\n- Se $n = 0$, então $a^n = 1$ (qualquer número elevado a 0 é 1)\n- Se $n = 1$, então $a^n = a$ (qualquer número elevado a 1 é ele mesmo)\n\nVamos implementar essa solução:\n\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction potenciacao(base, expoente)\n    # Resolvemos o expoente negativo primeiro\n    if expoente < 0\n        return 1 ÷ potenciacao(base, -expoente)\n    end\n    \n    if expoente == 0\n        return 1\n    elseif expoente == 1\n        return base\n    end\n    \n    # Se o expoente for par\n    if expoente % 2 == 0\n        temp = potenciacao(base, expoente ÷ 2)\n        return temp * temp\n    else\n        # Se o expoente for ímpar\n        return base * potenciacao(base, expoente - 1)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npotenciacao (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nVamos testar nossa função:\n\n\n\n\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nprintln(potenciacao(2, 10))  # Deve retornar 1024\nprintln(potenciacao(3, 5))   # Deve retornar 243\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1024\n243\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nPara entender melhor como essa abordagem economiza operações, vamos traçar a execução de `potenciacao(2, 10)`:\n\n**Passo 1**: `potenciacao(2, 10)`\n\n- `expoente = 10` é par\n- Precisamos calcular `potenciacao(2, 5)^2`\n\n**Passo 2**: `potenciacao(2, 5)`\n\n- `expoente = 5` é ímpar\n- Precisamos calcular `2 * potenciacao(2, 4)`\n\n**Passo 3**: `potenciacao(2, 4)`\n\n- `expoente = 4` é par\n- Precisamos calcular `potenciacao(2, 2)^2`\n\n**Passo 4**: `potenciacao(2, 2)`\n\n- `expoente = 2` é par\n- Precisamos calcular `potenciacao(2, 1)^2`\n\n**Passo 5**: `potenciacao(2, 1)`\n\n- `expoente = 1` é ímpar\n- Precisamos calcular `2 * potenciacao(2, 0)`\n\n**Passo 6**: `potenciacao(2, 0)`\n\n- caso base, retorna `1`\n\nValores retornados:\n\n- `potenciacao(2, 0)` retorna `1`\n- `potenciacao(2, 1)` retorna `2 * 1 = 2`\n- `potenciacao(2, 2)` retorna `2^2 = 4`\n- `potenciacao(2, 4)` retorna `4^2 = 16`\n- `potenciacao(2, 5)` retorna `2 * 16 = 32`\n- `potenciacao(2, 10)` retorna `32^2 = 1024`\n\nPara os entusiastas de computação, quando falamos de **complexidade** estamos nos referindo à eficiência de um algoritmo em termos do número de operações realizadas. Para representar a quantidade de operações, utilizamos a notação *Big-O* (O-Grande), simbolizada como $O(\\cdot)$.\n\nNeste contexto, a abordagem que utilizamos consegue reduzir a complexidade de $O(n)$ (onde o número de operações cresce **linearmente** com o tamanho da entrada) para $O(\\log n)$ (onde o número de operações cresce **logaritmicamente**, tornando o algoritmo muito mais eficiente para entradas grandes).\n\n## Cálculo da Raiz Quadrada (Método de Heron)\n\nO Método de Heron (também conhecido como método babilônico) é um algoritmo antigo para calcular aproximações de raízes quadradas. A ideia é começar com uma estimativa e melhorá-la progressivamente.\n\nVamos calcular uma aproximação para $\\sqrt{S}$. Se $x_0 > 0$ é a nossa estimativa inicial, podemos melhorar nossa estimativa usando a seguinte fórmula iterativa:\n\n$$x_{n + 1} = \\frac{1}{2} \\left( x_n + \\frac{S}{x_n} \\right).$$\n\nConsidere $\\varepsilon$ o erro em nossa estimativa de $\\sqrt{S}$. Então, $S = (x_0 + \\varepsilon)^2$. Expandindo o binômio temos\n\n$$S = (x_0 + \\varepsilon)^2 = x_0^2 + 2x_0\\varepsilon + \\varepsilon^2.$$\n\nPodemos resolver a equação acima para $\\varepsilon$.\n\n$$\\varepsilon = \\frac{S - x_0^2}{2x_0 + \\varepsilon} \\approx \\frac{S - x_0^2}{2x_0}, \\quad (\\varepsilon \\ll x_0).$$\n\nAssim, podemos compensar o erro e atualizar nossa estimativa antiga como\n\n$$x_0 + \\varepsilon \\approx x_0 + \\frac{S - x_0^2}{2x_0} = \\frac{S + x_0^2}{2x_0} = \\frac{\\frac{S}{x_0} + x_0}{2} \\equiv x_{1}$$\n\nComo o erro calculado não foi exato, esta não é a resposta final, mas se torna nossa nova estimativa para usar na próxima iteração. O processo de atualização é repetido até que a precisão desejada seja obtida.\n\nVamos implementar esse método recursivamente:\n\n\n\n\n\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction raiz_quadrada(S, xₙ = S / 2, ε = 0.0001)\n    xₙ₊₁ = (xₙ + S / xₙ) / 2\n    \n    # Verificamos se a diferença entre as estimativas é menor que a precisão desejada\n    if abs(xₙ₊₁ - xₙ) < ε\n        return xₙ₊₁\n    else\n        return raiz_quadrada(S, xₙ₊₁, ε)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nraiz_quadrada (generic function with 3 methods)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nA função recebe três parâmetros:\n\n- `S`: o número do qual queremos a raiz quadrada\n- `xₙ`: nossa estimativa atual (por padrão, começamos com metade do número)\n- `ε`: quão próximas duas estimativas consecutivas devem estar para considerarmos que encontramos a resposta (por padrão, estamos considerando `0.0001`)\n\nVamos testar nossa função:\n\n\n\n\n\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\nprintln(raiz_quadrada(25))  # Deve ser próximo de 5\nprintln(raiz_quadrada(2))   # Deve ser próximo de 1.4142...\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.000000000016778\n1.4142135623746899\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nObserve o que acontece com o valor da estimativa para o cálculo da raíz quadrada de 25:\n\n1. Primeira chamada: `x₀ = 25/2 = 12.5`\n2. Segunda chamada: `x₁ = (12.5 + 25/12.5)/2 = 7.25`\n3. Terceira chamada: `x₂ = (7.25 + 25/7.25)/2 = 5.35`\n4. Quarta chamada: `x₃ = (5.35 + 25/5.35)/2 = 5.01`\n5. Quinta chamada: `x₄ = (5.01 + 25/5.01)/2 = 5.0`\n\n## Coeficiente Binomial\n\nO coeficiente binomial $\\binom{n}{k}$ (lê-se \"n escolhe k\") representa o número de maneiras de escolher $k$ elementos de um conjunto de $n$ elementos, sem considerar a ordem. Por exemplo, $\\binom{5}{2}$ é o número de maneiras de escolher 2 elementos de um conjunto de 5 elementos.\n\nO coeficiente binomial possui a seguinte definição recursiva (para $n > k$):\n\n$$\\binom{n}{k} = \\binom{n-1}{k-1} + \\binom{n-1}{k}$$\n\nEsta fórmula pode ser deduzida dividindo o problema em dois casos complementares. Consideremos um elemento $X$ específico dentre as $n$ alternativas disponíveis. Podemos classificar todos os possíveis subconjuntos de $k$ elementos em duas categorias:\n\n1. Subconjuntos que incluem $X$: Neste caso, como $X$ já está selecionado, precisamos escolher apenas $k-1$ elementos adicionais dentre os $n-1$ elementos restantes. Isto corresponde a $\\binom{n-1}{k-1}$ possibilidades.\n\n2. Subconjuntos que não incluem $X$: Neste caso, devemos selecionar todos os $k$ elementos dentre os $n-1$ elementos restantes (excluindo $X$). Isto corresponde a $\\binom{n-1}{k}$ possibilidades.\n\nO número total de subconjuntos possíveis é a soma destes dois casos, o que justifica a fórmula recursiva apresentada.\n\nPodemos determinar os casos base através das seguintes propriedades:\n\n1. $\\binom{n}{0} = 1$ para qualquer $n \\geq 0$ (há apenas uma maneira de escolher 0 elementos)\n2. $\\binom{n}{n} = 1$ para qualquer $n \\geq 0$ (há apenas uma maneira de escolher todos os elementos)\n\nVamos implementar essa solução:\n\n\n\n\n\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction coeficiente_binomial(n, k)\n    if k == 0 || k == n\n        return 1\n    else\n        return coeficiente_binomial(n - 1, k - 1) + coeficiente_binomial(n - 1, k)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ncoeficiente_binomial (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nVamos testar nossa função:\n\n\n\n\n\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\nprintln(coeficiente_binomial(5, 2))  # Deve retornar 10\nprintln(coeficiente_binomial(10, 4)) # Deve retornar 210\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n210\n```\n:::\n:::\n\n\n",
    "supporting": [
      "05-problemas-recursao_files"
    ],
    "filters": [],
    "includes": {}
  }
}