{
  "hash": "33f7216bde54456fc4a7300c1ec82c07",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n\n\n# Introdução às Funções\n\nO objetivo deste capítulo é compreender o conceito de funções em programação e como elas são implementadas em Julia. Vamos explorar como criar nossas próprias funções, como elas podem receber parâmetros e retornar valores, além de introduzir o conceito de recursão.\n\n## Funções como Abstrações Naturais\n\nNa aula anterior, já utilizamos algumas funções predefinidas em Julia. Funções são blocos de código que realizam tarefas específicas e podem ser reutilizados sempre que necessário. Elas nos permitem abstrair operações complexas em comandos simples, tornando o código mais legível e modular.\n\nVamos relembrar algumas das funções que já utilizamos:\n\n- `typeof()` - Recebe um valor como parâmetro e retorna o seu tipo.\n- `div()` - Recebe dois números e retorna a divisão inteira do primeiro pelo segundo.\n- `print()` e `println()` - Imprimem valores no console, sendo que o segundo adiciona uma quebra de linha após a impressão.\n\nAssim como na aula anterior, podemos pedir ajuda ao Julia para entender melhor como essas funções funcionam. Para isso, usamos o ponto de interrogação `?` ou o macro `@doc` antes do nome da função:\n\n\n\n\n\n\n\n\n::: {#2 .cell execution_count=0}\n``` {.julia .cell-code}\n# Exemplos de como acessar a documentação\n@doc typeof\n```\n:::\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\n@doc div\n```\n:::\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\n@doc println\n```\n:::\n\n\n\n\n\n\n\n\n\n\nAo consultar a documentação, descobrimos que algumas funções como `div()` podem ser utilizadas com uma sintaxe alternativa, como por exemplo `\\div`. Esse tipo de notação é particularmente útil para operações matemáticas.\n\n### Funções de Conversão em Julia\n\nUma categoria importante de funções em Julia são as funções de conversão, que transformam valores de um tipo em outro. Vejamos alguns exemplos:\n\n\n\n\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\n# Converte uma string para um número em ponto flutuante\nparse(Float64, \"32\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n32.0\n```\n:::\n:::\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n# Converte um número em ponto flutuante para um inteiro (removendo a parte decimal)\ntrunc(Int64, 2.25)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2\n```\n:::\n:::\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n# Converte um inteiro para um número em ponto flutuante\nfloat(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\n# Converte um número para uma string\nstring(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"3\"\n```\n:::\n:::\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\n# Converte um número em ponto flutuante para uma string\nstring(3.57)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"3.57\"\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n### Funções Matemáticas Prontas em Julia\n\nJulia possui uma grande biblioteca de funções matemáticas prontas para uso. Aqui estão algumas das mais comuns:\n\n| Função            | Descrição                                          |\n|:------------------|:--------------------------------------------------|\n| `sin(x)`          | Calcula o seno de \\( x \\) em radianos            |\n| `cos(x)`          | Calcula o cosseno de \\( x \\) em radianos         |\n| `tan(x)`          | Calcula a tangente de \\( x \\) em radianos        |\n| `deg2rad(x)`      | Converte \\( x \\) de graus em radianos            |\n| `rad2deg(x)`      | Converte \\( x \\) de radianos em graus            |\n| `log(x)`          | Calcula o logaritmo natural de \\( x \\)           |\n| `log(b, x)`       | Calcula o logaritmo de \\( x \\) na base \\( b \\)   |\n| `log2(x)`         | Calcula o logaritmo de \\( x \\) na base 2         |\n| `log10(x)`        | Calcula o logaritmo de \\( x \\) na base 10        |\n| `exp(x)`          | Calcula o expoente da base natural de \\( x \\)    |\n| `abs(x)`          | Calcula o valor absoluto de \\( x \\)              |\n| `sqrt(x)`         | Calcula a raiz quadrada de \\( x \\)                |\n| `cbrt(x)`         | Calcula a raiz cúbica de \\( x \\)                  |\n| `factorial(x)`    | Calcula o fatorial de \\( x \\)                     |\n\nUma boa prática para se familiarizar com essas funções é experimentá-las com diferentes valores e verificar os resultados. Para funções mais complexas, é possível que já existam implementações prontas em Julia. Uma dica útil é pesquisar na internet usando palavras-chave como \"julia lang hiperbolic sin\" para encontrar a função desejada. Em geral, pesquisar em inglês tende a produzir melhores resultados.\n\n## Criando Nossas Próprias Funções\n\nEm Julia, podemos criar nossas próprias funções usando a palavra-chave `function`, seguida pelo nome da função, parênteses (que podem conter parâmetros) e terminando com `end`. Vejamos um exemplo simples:\n\n\n\n\n\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction mensagemDeBomDia()\n   println(\"Tenha um bom dia!\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nmensagemDeBomDia (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nPara usar (ou \"chamar\") uma função, basta escrever seu nome seguido de parênteses:\n\n\n\n\n\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\nmensagemDeBomDia()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTenha um bom dia!\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n### Funções com Parâmetros\n\nAs funções se tornam muito mais úteis quando podem receber informações para processar. Essas informações são chamadas de \"parâmetros\" ou \"argumentos\":\n\n\n\n\n\n\n\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction imprime(a)\n   println(\"Vou imprimir \", a)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nimprime (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nVamos chamar esta função com diferentes valores:\n\n\n\n\n\n\n\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\nimprime(42)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVou imprimir 42\n```\n:::\n:::\n\n\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\nimprime(\"Olá, mundo!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVou imprimir Olá, mundo!\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n### Funções Chamando Outras Funções\n\nUma função pode chamar outra função, permitindo a composição de operações mais complexas:\n\n\n\n\n\n\n\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction imprimeduasvezes(a)\n   imprime(a)\n   imprime(a)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nimprimeduasvezes (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nTestando nossa nova função:\n\n\n\n\n\n\n\n\n::: {#30 .cell execution_count=1}\n``` {.julia .cell-code}\nimprimeduasvezes(13)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVou imprimir 13\nVou imprimir 13\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n### Sobrecarga de Funções\n\nEm Julia, podemos ter funções com o mesmo nome, mas com diferentes números ou tipos de parâmetros. Isso é chamado de \"sobrecarga de funções\":\n\n\n\n\n\n\n\n\n::: {#32 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction recebe(a)\n  println(\"Recebi um parâmetro: \", a)\nend\n\nfunction recebe(a, b)\n  println(\"Recebi dois parâmetros: \", a, \" e \", b)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nrecebe (generic function with 2 methods)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nO Julia decide qual versão da função chamar com base nos argumentos fornecidos:\n\n\n\n\n\n\n\n\n::: {#34 .cell execution_count=1}\n``` {.julia .cell-code}\nrecebe(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRecebi um parâmetro: 1\n```\n:::\n:::\n\n\n\n::: {#36 .cell execution_count=1}\n``` {.julia .cell-code}\nrecebe(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRecebi dois parâmetros: 1 e 2\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nTambém podemos chamar funções usando variáveis e expressões como argumentos:\n\n\n\n\n\n\n\n\n::: {#38 .cell execution_count=1}\n``` {.julia .cell-code}\na = 10\nrecebe(a)\nrecebe(a, a + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRecebi um parâmetro: 10\nRecebi dois parâmetros: 10 e 11\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Funções que Retornam Valores\n\nAté agora, vimos funções que apenas imprimem mensagens, mas não devolvem nenhum valor. O tipo de retorno dessas funções é `Nothing`, indicando que elas não produzem um valor que possa ser atribuído a uma variável.\n\nNo entanto, frequentemente queremos que nossas funções calculem e retornem valores. Para isso, usamos a palavra-chave `return`:\n\n\n\n\n\n\n\n\n::: {#40 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction soma1(a)\n  return a + 1\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsoma1 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nAgora podemos usar essa função em expressões e atribuições:\n\n\n\n\n\n\n\n\n::: {#42 .cell execution_count=1}\n``` {.julia .cell-code}\nresultado = soma1(5)\nprintln(\"O resultado é: \", resultado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nO resultado é: 6\n```\n:::\n:::\n\n\n\n::: {#44 .cell execution_count=1}\n``` {.julia .cell-code}\n# Também podemos usar o resultado em outras expressões\nprintln(\"Resultado multiplicado por 2: \", soma1(5) * 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResultado multiplicado por 2: 12\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nPodemos criar funções para cálculos mais complexos:\n\n\n\n\n\n\n\n\n::: {#46 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction hipotenusa(a, b)\n  hip = sqrt(a^2 + b^2)\n  return hip\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nhipotenusa (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nTestando nossa função:\n\n\n\n\n\n\n\n\n::: {#48 .cell execution_count=1}\n``` {.julia .cell-code}\n# Calculando a hipotenusa de um triângulo 3-4-5\nhipotenusa(3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n5.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Introdução à Recursão\n\nAgora vamos explorar um conceito fundamental em programação: a recursão. Uma função recursiva é aquela que chama a si mesma como parte de sua execução. Isso pode parecer estranho à primeira vista, mas é uma técnica poderosa para resolver certos tipos de problemas.\n\nVamos começar com um exemplo simples: calcular o fatorial de um número. O fatorial de $n$ (representado por $n!$) é o produto de todos os inteiros positivos menores ou iguais a $n$. Por exemplo, $5! = 5 \\times 4 \\times 3 \\times 2 \\times 1 = 120$.\n\nO fatorial pode ser definido recursivamente como:\n\n- Caso base: $0! = 1$\n- Caso recursivo: $n! = n \\times (n-1)!$\n\nVamos implementar isso em Julia:\n\n\n\n\n\n\n\n\n::: {#50 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction fatorial(n)\n  if n == 0\n    return 1  # Caso base\n  else\n    return n * fatorial(n - 1)  # Chamada recursiva\n  end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nfatorial (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nTestando nossa função:\n\n\n\n\n\n\n\n\n::: {#52 .cell execution_count=1}\n``` {.julia .cell-code}\nfatorial(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n120\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nPara entender como a recursão funciona, vamos acompanhar passo a passo o cálculo de `fatorial(3)`:\n\n1. Chamamos `fatorial(3)`\n   - Como $3$ não é igual a $0$, executamos `return 3 * fatorial(2)`\n2. Agora precisamos calcular `fatorial(2)`\n   - Como $2$ não é igual a $0$, executamos `return 2 * fatorial(1)`\n3. Agora precisamos calcular `fatorial(1)`\n   - Como $1$ não é igual a $0$, executamos `return 1 * fatorial(0)`\n4. Agora precisamos calcular `fatorial(0)`\n   - Como $0$ é igual a $0$, retornamos $1$\n5. Agora podemos completar o cálculo de `fatorial(1)` = $1 \\times 1 = 1$\n6. Agora podemos completar o cálculo de `fatorial(2)` = $2 \\times 1 = 2$\n7. Finalmente, completamos o cálculo de `fatorial(3)` = $3 \\times 2 = 6$\n\nA recursão tem duas partes fundamentais:\n\n1. Um **caso base** que encerra a recursão (no nosso exemplo, quando $n = 0$)\n2. Um **caso recursivo** que aproxima o problema do caso base (no nosso exemplo, reduzindo $n$ em $1$)\n\nÉ necessário que a recursão sempre alcance o caso base, caso contrário, a função continuará chamando a si mesma indefinidamente, causando um erro de estouro de pilha (stack overflow).\n\n### Mais Exemplos de Recursão\n\nVamos implementar uma função recursiva para contagem regressiva:\n\n\n\n\n\n\n\n\n::: {#54 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction contagem(n)\n    if n < 0\n        println(\"Fim!\")\n    else\n        print(n, \" \")\n        contagem(n - 1)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ncontagem (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nTestando nossa função:\n\n\n\n\n\n\n\n\n::: {#56 .cell execution_count=1}\n``` {.julia .cell-code}\ncontagem(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 4 3 2 1 0 Fim!\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nPodemos também usar recursão para calcular a soma dos primeiros $n$ números inteiros:\n\n\n\n\n\n\n\n\n::: {#58 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction soma(n)\n  if n == 0\n    return 0  # Caso base\n  else\n    return n + soma(n - 1)  # Caso recursivo\n  end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsoma (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nTestando nossa função:\n\n\n\n\n\n\n\n\n::: {#60 .cell execution_count=1}\n``` {.julia .cell-code}\nsoma(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n55\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nOutro exemplo interessante é o cálculo da soma dos termos da série harmônica:\n\n\n\n\n\n\n\n\n::: {#62 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction somaharmonica(atual, n)\n  # Caso base: quando chegamos ao último termo\n  if atual > n\n    return 0.0\n  else\n    # Caso recursivo: somamos o termo atual e chamamos a função para o próximo termo\n    return 1.0 / atual + somaharmonica(atual + 1, n)\n  end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsomaharmonica (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nVamos calcular a soma dos 10 primeiros termos da série harmônica:\n\n\n\n\n\n\n\n\n::: {#64 .cell execution_count=1}\n``` {.julia .cell-code}\nsomaharmonica(1, 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.9289682539682538\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Verifique seu Aprendizado\n\n1. Qual é a diferença entre uma função que imprime um valor e uma função que retorna um valor? Por que esta distinção é importante?\n2. Explique o conceito de recursão em suas próprias palavras. Quais são os componentes essenciais de uma função recursiva?\n3. Crie uma função que receba um número inteiro positivo e retorne a soma de seus dígitos. Por exemplo, para o número $123$, a função deve retornar $1+2+3 = 6$.\n4. Implemente uma função que calcule o $n$-ésimo número da **sequência de Fibonacci** usando recursão. Lembre-se que\n    - $Fib(0) = 0$\n    - $Fib(1) = 1$\n    - $Fib(n) = Fib(n-1) + Fib(n-2)$, se $n > 1$.\n5. Crie uma função que receba dois números como parâmetros e retorne o **máximo divisor comum (MDC)** entre eles usando o algoritmo de Euclides recursivamente.\n\n## Explore por Conta Própria\n\n1. Pesquise sobre o conceito de \"pilha de chamadas\" (*call stack*) e como ele se relaciona com a recursão. Quais são as limitações práticas da recursão devido à pilha de chamadas?\n2. Pense em como seria possível otimizar a função recursiva de Fibonacci para evitar cálculos repetidos.\n    - Dica: pesquise sobre \"memoização\".\n3. Explore funções com um número variável de argumentos em Julia usando a sintaxe de \"splats\" (`...`).\n4. Procure como você pode definir valores padrão para parâmetros de funções em Julia.\n\n",
    "supporting": [
      "03-funcoes-recursao_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}