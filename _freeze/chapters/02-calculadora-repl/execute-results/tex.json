{
  "hash": "a2a1d8c946a438dea1caf6ef8a509e93",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n# Usando o Interpretador (REPL) como Calculadora\n\nO objetivo deste cap√≠tulo √© apresentar o interpretador de Julia como uma calculadora poderosa e introduzir os primeiros conceitos de programa√ß√£o: vari√°veis e fun√ß√µes. Mas primeiro √© preciso instalar a linguagem Julia em seu computador. Mais detalhes sobre o processo de instala√ß√£o podem ser encontrados neste [link](https://julialang.org/downloads/).\n\nMuito provavelmente seu sistema √© Windows (10 ou 11) e sua arquitetura √© de 64-bits. H√° algumas formas de instalar Julia no Windows:\n\n1. Atrav√©s de um arquivo execut√°vel (`.exe`).\n2. Atrav√©s de comandos pelo terminal (`winget`).\n\nA princ√≠pio qualquer uma das op√ß√µes √© adequada. A primeira op√ß√£o n√£o requer nenhum programa adicional, enquanto que a segunda requer um terminal. Um terminal √© um aplicativo que permite a comunica√ß√£o com o sistema operacional por meio de uma interface de linha de comando (CLI). O terminal padr√£o do Windows √© o Windows Terminal. √â fortemente recomendado que voc√™ o tenha instalado e isso pode ser feito atrav√©s da Microsoft Store.\n\nUma vez que voc√™ tenha acesso a um terminal h√° dois comandos poss√≠veis para instalar Julia: `winget install julia -s msstore` ou `winget install -e --id Julialang.Julia`. Mais uma vez, qualquer uma das op√ß√µes deve funcionar.\n\n## Explorando a Sess√£o Interativa de Julia\n\nVoc√™ pode abrir uma sess√£o interativa (tamb√©m conhecido como um *read-eval-print loop* ou REPL) de Julia digitando o comando `julia` na linha de comando do seu terminal. No Windows, ap√≥s instala√ß√£o da linguagem, √© poss√≠vel abrir uma sess√£o interativa clicando duas vezes no execut√°vel Julia. A sua janela deve ser parecida com\n\n```\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.3 (2025-01-21)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia>\n```\n\nDentro da sess√£o podemos inserir comandos que ser√£o lidos, avaliados e impressos na tela. Um comando s√≥ √© avaliado quando teclamos **Enter**. Vamos come√ßar com opera√ß√µes com n√∫meros inteiros. Para somar dois n√∫meros podemos digitar:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n1 + 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara multiplicar outros dois n√∫mero:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n40 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n160\n```\n:::\n:::\n\n\n\n\n\n\n\n\nComo esperado, podemos utilizar as opera√ß√µes b√°sicas de soma (`+`), subtra√ß√£o (`-`) e multiplica√ß√£o (`*`), e os resultados ocorrem como previsto. No entanto, observaremos a seguir que o comportamento da divis√£o apresenta algumas particularidades:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 84 \nb = 2\n\n# As vari√°veis a e b s√£o do tipo Int64\n\nresultado = a / b\nprintln(resultado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNotem que, neste exemplo, ocorreu uma convers√£o de tipo, pois 84 e 2 s√£o n√∫meros inteiros, enquanto o resultado √© um n√∫mero em ponto flutuante (float). Os pontos flutuantes s√£o representa√ß√µes bin√°rias de n√∫meros reais, tema que exploraremos com mais detalhes em breve. Esta convers√£o fica evidente pela representa√ß√£o do resultado como `42.0`, em vez de simplesmente `42`. Caso deseje obter o resultado como um n√∫mero inteiro, √© poss√≠vel utilizar o operador `div`:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ndiv(84,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu de forma equivalente usando o operador `\\div` (para conseguir ver o s√≠mbolo da divis√£o √© necess√°rio digitar `\\div` seguido da tecla `<tab>`).\n\nAl√©m das opera√ß√µes b√°sicas, √© poss√≠vel fazer exponencia√ß√£o:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2^31\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2147483648\n```\n:::\n:::\n\n\n\n\n\n\n\n\nExpress√µes mais complexas tamb√©m podem ser calculadas:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23 + 2 * 2 + 3 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\n\n\n\nSim, a preced√™ncia de operadores usual tamb√©m √© v√°lida em Julia. Entretanto, lembre-se da primeira li√ß√£o de programa√ß√£o: *Escreva para humanos, n√£o para m√°quinas*. Podemos usar par√™nteses para separar as opera√ß√µes:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23 + (2 * 2) + (3 * 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\n\n\n\nLembra dos pontos flutuantes? Todas as opera√ß√µes vistas podem ser aplicadas em pontos flutuantes:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23.5 * 3.14\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n73.79\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n12.5 / 2.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n6.25\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\nO exemplo acima demonstra mais um c√≥digo escrito de forma clara para pessoas, onde ao utilizarmos `2.0` deixamos expl√≠cito que o segundo par√¢metro √© um n√∫mero de ponto flutuante (float). √â fundamental compreender que n√∫meros de ponto flutuante possuem precis√£o **limitada**, portanto n√£o se surpreenda ao encontrar resultados inesperados como os demonstrados abaixo:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n1.2 - 1.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.19999999999999996\n```\n:::\n:::\n\n\n\n\n\n\n\n\nErros como esse s√£o bastante raros, tanto que normalmente depositamos total confian√ßa nas contas realizadas por computadores e calculadoras. No entanto, √© importante reconhecer que existem limita√ß√µes (veja os exemplos abaixo).\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2.6 - 0.7 - 1.9\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.220446049250313e-16\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n0.1 + 0.2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n10e15 + 1 - 10e15\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nEsses problemas de precis√£o est√£o ligados √† limita√ß√£o de como os n√∫meros s√£o representados no computador. De maneira simplificada, os valores no computador s√£o codificados em palavras, formadas por bits. Nos computadores modernos, as palavras t√™m 64 bits, ou 8 bytes. Logo, uma outra limita√ß√£o est√° relacionada aos n√∫meros inteiros muito grandes.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2^63\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n-9223372036854775808\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNo entanto, para um curso introdut√≥rio, √© suficiente estar ciente dessas limita√ß√µes. O tratamento dessas quest√µes faz parte de disciplinas mais avan√ßadas. Vale ressaltar que o erro mencionado anteriormente √© um *erro silencioso*, ou seja, ao trabalharmos com n√∫meros inteiros, pode acontecer que o valor a ser representado exceda a capacidade do n√∫mero de bits dispon√≠vel, resultando em uma falha que ocorre sem notifica√ß√£o expl√≠cita.\n\nVoltando √†s contas. Um outro operador interessante √© o `%` que calcula o resto da divis√£o\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n4 % 3\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAt√© agora vimos como trabalhar com um √∫nico valor, como se estiv√©ssemos usando o visor de uma calculadora. Mas podemos ir al√©m disso. Em vez de simples teclas de mem√≥ria, o computador nos oferece **vari√°veis**. Essas s√£o como nomes para valores que queremos armazenar e utilizar posteriormente.\n\nAl√©m das opera√ß√µes b√°sicas tamb√©m temos as opera√ß√µes matem√°ticas (fun√ß√µes), como por exemplo o seno, *sine* em ingl√™s. Para saber como uma fun√ß√£o funciona podemos pedir ajuda ao ambiente, usando uma `?` ou o macro (fun√ß√µes especiais) `@doc`, e em seguida digitando o que queremos saber, como por exemplo em:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n@doc sin\n```\n:::\n\n\n\n\n\n\n\n\nA sa√≠da desse comando indica a opera√ß√£o que a fun√ß√£o realiza e ainda apresenta alguns exemplos: \n\n```\nsin(x)\n\nCompute sine of x, where x is in radians.\n\nSee also sind, sinpi, sincos, cis, asin.\n\nExamples\n‚â°‚â°‚â°‚â°‚â°‚â°‚â°‚â°\n\njulia> round.(sin.(range(0, 2pi, length=9)'), digits=3)\n1√ó9 Matrix{Float64}:\n0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0\n```\n\nAmbos os comandos `? sin` e `@doc sin` possuem a mesma sa√≠da.\n\nNotem que nem tudo que foi apresentado faz sentido no momento, mas j√° d√° para entender o uso de uma fun√ß√£o como `sin`. Vejamos agora a raiz quadrada:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n@doc sqrt\n```\n:::\n\n\n\n\n\n\n\n\n```\nsqrt(x)\n\nReturn \\sqrt{x}.\n\nThrows DomainError for negative Real arguments. Use complex negative arguments instead. Note that sqrt has a branch cut\nalong the negative real axis.\n\nThe prefix operator ‚àö is equivalent to sqrt.\n\nSee also: hypot\n...\n```\n\nNela vemos que √© poss√≠vel calcular a raiz como em:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAgora, observe que a documenta√ß√£o da fun√ß√£o `big()` tem a seguinte ajuda:\n\n```\nbig(T::Type)\n\nCompute the type that represents the numeric type T with arbitrary precision. Equivalent to typeof(big(zero(T))).\n\nExamples\n‚â°‚â°‚â°‚â°‚â°‚â°‚â°‚â°\n\njulia> big(Rational)\nRational{BigInt}\n\njulia> big(Float64)\nBigFloat\n\njulia> big(Complex{Int})\nComplex{BigInt}\n\nbig(x)\n\nConvert a number to a maximum precision representation (typically BigInt or BigFloat). See BigFloat for information about\nsome pitfalls with floating-point numbers.\n```\n\nA fun√ß√£o `big()` permite criar n√∫meros de grande magnitude, representados pelos tipos `BigInt` ou `BigFloat`. Essa fun√ß√£o √© particularmente √∫til quando voc√™ precisa trabalhar com n√∫meros muito grandes que ultrapassam os limites dos tipos padr√£o, como `Int64` ou `Int32`. Ao utilizar n√∫meros do tipo `BigInt`, eliminamos problemas de estouro (overflow), conforme podemos observar abaixo:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nbig(2) ^ 1002\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504\n```\n:::\n:::\n\n\n\n\n\n\n\n\n## Vari√°veis e Tipos de Dados\n\nComo j√° introduzido, em Julia, temos o conceito de vari√°veis. Vari√°veis servem para armazenar dados diversos, como inteiros e floats. Podemos operar nas vari√°veis da mesma forma que operamos nos dados que elas guardam (veja o exemplo abaixo).\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 7\n2 + a\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n9\n```\n:::\n:::\n\n\n\n\n\n\n\n\nQuando escrevemos `a = 7`, estamos realizando uma opera√ß√£o chamada **atribui√ß√£o**. O operador `=` em Julia (e na maioria das linguagens de programa√ß√£o) n√£o representa igualdade matem√°tica, mas sim uma instru√ß√£o para armazenar o valor √† direita na vari√°vel √† esquerda. Podemos visualizar isso como se estiv√©ssemos colocando o valor `7` dentro de uma caixa chamada `a`. \n\n√â importante destacar que as vari√°veis em Julia podem receber novos valores, e o tipo da vari√°vel √© determinado pela √∫ltima atribui√ß√£o realizada. A fun√ß√£o `typeof` pode ser usada para identificar o tipo da vari√°vel especificada.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 3\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = a + 1\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n\n\n\n\n\nA atribui√ß√£o sempre acontece da direita para a esquerda: primeiro calcula-se o valor da express√£o √† direita, e depois esse valor √© armazenado na vari√°vel √† esquerda. No exemplo a seguir, a vari√°vel `b` come√ßa com um valor de tipo inteiro. No entanto, ap√≥s a opera√ß√£o de multiplica√ß√£o, seu valor passa a ser do tipo ponto flutuante.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nb = 3\nb = b * 0.5\ntypeof(b)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n\n\n\n\n\nA capacidade de alterar o tipo da vari√°vel √© conhecida como **tipagem din√¢mica**. Esta caracter√≠stica apresenta diversas vantagens, como a flexibilidade de reutilizar vari√°veis para armazenar diferentes tipos de dados ao longo do tempo e a menor verbosidade, pois n√£o √© necess√°rio especificar o tipo de cada vari√°vel, o que melhora a legibilidade do c√≥digo. Neste contexto, podemos observar que Julia possui v√°rios tipos primitivos, sendo os principais:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1.1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(\"Bom dia\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nString\n```\n:::\n:::\n\n\n\n\n\n\n\n\nFalando em **strings**, eles s√£o definidos por conjuntos de caracteres entre aspas como:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Olha que legal\"\ns2 = \"Outra String\"\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Outra String\"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nTamb√©m √© poss√≠vel realizar opera√ß√µes com strings, como **concatena√ß√£o**:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Tenha um\"\ns2 = \" Bom dia\"\ns3 = s1 * s2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Tenha um Bom dia\"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu repeti√ß√£o usando o operador de pot√™ncia:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns = \"N√£o vou mais fazer coisas que possam desagradar os meus colegas \"\ns ^ 10\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fa\" ‚ãØ 100 bytes ‚ãØ \" meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas \"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara evitar que se digitem muitos caracteres, por vezes podemos usar *a√ßucares sint√°ticos*.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nx = 1\nx = x + 1\nx += 1  # '+= 1' equivale a '= x + 1', tamb√©m funciona para os operadores *, - e /\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n\n\n\n\n\nO c√≥digo acima utiliza coment√°rios (tudo depois do `#`). Esses coment√°rios s√£o ignorados pelo interpretador e podem ser usados para tornar o c√≥digo mais leg√≠vel.\n\nAinda sobre vari√°veis, h√° algumas regras referentes aos seus nomes: devem come√ßar com uma letra (ou com `_`), podem conter d√≠gitos e n√£o podem ser palavras reservadas. Vale ressaltar que Julia, por ser uma linguagem moderna, aceita caracteres unicode e emojis nos nomes, como por exemplo o Œî (`\\Delta`).\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nŒî = 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nüê± = 5 # \\:cat: <tab>\nüê∂ = 3 # \\:dog: <tab>\nüè† = 20 # \\:house: <tab>\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n20\n```\n:::\n:::\n\n\n\n\n\n\n\n\nIsso n√£o adiciona nada do lado de algoritmos, mas √© poss√≠vel ter vari√°veis bem bonitinhas. A lista de figuras pode ser encontrada [aqui](https://docs.julialang.org/en/v1/manual/unicode-input/).\n\n## Sa√≠da de Dados\n\nPara imprimir informa√ß√µes no terminal, usamos as fun√ß√µes `print()` e o `println()`. A diferen√ßa entre elas √© que a primeira n√£o pula linha, enquanto que a segunda pula.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nprint(\"Hello \")\nprintln(\"World!\")\nprintln(\"Ola, mundo!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World!\nOla, mundo!\n```\n:::\n:::\n\n\n\n\n\n\n\n\nO comando `println()` pode receber m√∫ltiplos argumentos, que ser√£o convertidos em strings e concatenados automaticamente:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nnome = \"Maria\"\nidade = 25\nprintln(\"Ol√°, meu nome √© \", nome, \" e tenho \", idade, \" anos.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOl√°, meu nome √© Maria e tenho 25 anos.\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara formata√ß√µes mais complexas, Julia oferece **interpola√ß√£o de strings**, onde podemos inserir vari√°veis e express√µes diretamente dentro de uma string usando o cifr√£o `$`:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nnome = \"Jo√£o\"\naltura = 1.75\nprintln(\"$nome tem $altura metros de altura.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJo√£o tem 1.75 metros de altura.\n```\n:::\n:::\n\n\n\n\n\n\n\n\nTamb√©m podemos incluir express√µes dentro de chaves ap√≥s o cifr√£o:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\npreco = 9.99\nquantidade = 3\nprintln(\"Total da compra: R\\$ $(preco * quantidade)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal da compra: R$ 29.97\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara formata√ß√£o num√©rica, podemos usar a fun√ß√£o `@sprintf` ou a macro `@printf` do m√≥dulo `Printf` (detalhes sobre m√≥dulos na @sec-files-modules):\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Printf\n\nvalor = 123.456\n@printf(\"Valor formatado: %.2f\\n\", valor)  # Exibe com 2 casas decimais\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValor formatado: 123.46\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu alternativamente:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nvalor = 123.456\ns = @sprintf(\"Valor formatado: %.2f\", valor)\nprintln(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValor formatado: 123.46\n```\n:::\n:::\n\n\n\n\n\n\n\n\n## Arquivos Externos e M√≥dulos {#sec-files-modules}\n\nNo exemplo anterior usamos a sintaxe `using Printf`. Esta √© a sintaxe para importar um m√≥dulo em Julia. Os m√≥dulos s√£o cole√ß√µes organizadas de c√≥digo que podemos utilizar em nossos programas. O m√≥dulo `Printf` faz parte da **biblioteca padr√£o** de Julia e oferece fun√ß√µes para formata√ß√£o de tipos no estilo da linguagem C. Ao escrever `using Printf`, informamos o interpretador que queremos acessar as fun√ß√µes deste m√≥dulo, como `@printf` e `@sprintf`. Para descobrir quais fun√ß√µes est√£o dispon√≠veis neste e em outros m√≥dulos, consulte a documenta√ß√£o oficial de Julia. A documenta√ß√£o espec√≠fica do m√≥dulo `Printf` est√° dispon√≠vel em <https://docs.julialang.org/en/v1/stdlib/Printf/>.\n\nJulia vem com v√°rios m√≥dulos padr√£o que podem ser √∫teis:\n\n- `Statistics`: para c√°lculos estat√≠sticos (m√©dia, mediana, etc.)\n- `Dates`: para trabalhar com datas e horas\n- `Printf`: para formata√ß√£o avan√ßada de texto\n- `LinearAlgebra`: para opera√ß√µes de √°lgebra linear\n- `Random`: para gera√ß√£o de n√∫meros aleat√≥rios\n\nA comunidade de Julia tamb√©m desenvolve diversos m√≥dulos (pacotes) que podem ser instalados para expandir as funcionalidades da linguagem. Vamos aprender a fazer isso mais adiante no curso.\n\nAl√©m de m√≥dulos, Julia permite carregar c√≥digo de arquivos externos usando o comando `include()`. Este comando l√™ o arquivo especificado e executa todo seu conte√∫do no contexto atual. Como resultado, todas as fun√ß√µes, vari√°veis e defini√ß√µes do arquivo tornam-se dispon√≠veis no ambiente onde `include` foi chamado.\n\nNo Windows, os caminhos de arquivo tradicionalmente usam barras invertidas (`\\`). Por√©m, em Julia, podemos usar tanto barras normais (`/`) quanto barras invertidas. H√° um detalhe importante: quando usamos barras invertidas dentro de strings em Julia, precisamos duplic√°-las. Isso ocorre porque a barra invertida sozinha (`\\`) √© um caractere especial em strings, usado para representar caracteres como `\\n` (nova linha) ou `\\t` (tabula√ß√£o). Para indicar que queremos uma barra invertida literal, precisamos escrever duas (`\\\\`). Por esse motivo, caminhos com v√°rias pastas tornam-se mais dif√≠ceis de ler:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n# Caminho usando barras normais (recomendado)\ninclude(\"C:/Users/MeuUsuario/Documentos/arquivo.jl\")\n\n# Mesmo caminho usando barras invertidas (mais complicado)\ninclude(\"C:\\\\Users\\\\MeuUsuario\\\\Documentos\\\\arquivo.jl\")\n```\n:::\n\n\n\n\n\n\n\n\nSe o arquivo estiver no mesmo diret√≥rio que seu script ou REPL atual, basta usar o nome do arquivo:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\ninclude(\"funcoes.jl\")\n```\n:::\n\n\n\n\n\n\n\n\nPara arquivos em subdiret√≥rios do diret√≥rio atual:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\ninclude(\"utilitarios/matematica.jl\")\n```\n:::\n\n\n\n\n\n\n\n\nPara arquivos no diret√≥rio pai:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\ninclude(\"../exemplos.jl\")\n```\n:::\n\n\n\n\n\n\n\n\nVamos ver um exemplo pr√°tico. Suponha que voc√™ tenha criado um arquivo chamado `funcoes.jl` na pasta `C:/Projetos/Julia/` com o seguinte conte√∫do:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\nfunction ola(nome)\n    println(\"Ol√° \", nome)\nend\n\nfunction soma(a, b)\n    return a + b\nend\n```\n:::\n\n\n\n\n\n\n\n\nAgora voc√™ pode usar essas fun√ß√µes (mais sobre fun√ß√µes no @sec-functions) no REPL ou em outro arquivo:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n# No REPL ou em um arquivo na mesma pasta:\ninclude(\"funcoes.jl\")\n\n# Ou com caminho completo:\ninclude(\"C:/Projetos/Julia/funcoes.jl\")\n\n# Agora podemos usar as fun√ß√µes definidas em funcoes.jl\nola(\"Alfredo\")         # Imprime: Ol√° Alfredo\nresultado = soma(5, 3) # resultado = 8\nprintln(resultado)     # Imprime: 8\n```\n:::\n\n\n\n\n\n\n\n\nEsta funcionalidade √© especialmente √∫til para organizar seu c√≥digo em m√∫ltiplos arquivos, permitindo que voc√™ divida programas maiores em partes menores.\n\n### O que √© um arquivo `.jl`?\n\nUm arquivo `.jl` √© semelhante a um arquivo de texto `.txt`, por√©m com a extens√£o `.jl`. Embora seja poss√≠vel abri-lo com um editor de texto simples como o Bloco de Notas, n√£o √© recomendado utiliz√°-lo para programa√ß√£o. Os arquivos `.jl` s√£o arquivos de c√≥digo-fonte da linguagem Julia e s√£o geralmente editados com editores espec√≠ficos para programa√ß√£o, como Visual Studio Code, Atom ou Sublime Text.\n\nN√£o existe um editor de texto definitivamente superior aos demais, o importante √© escolher aquele com o qual voc√™ se sinta mais confort√°vel. Nossa recomenda√ß√£o √© o Visual Studio Code, que oferece recursos muito mais avan√ßados que um editor de texto comum e possui uma extens√£o dedicada √† linguagem Julia, facilitando significativamente a escrita de c√≥digo. Para come√ßar a usar o Visual Studio Code com Julia, os tutoriais a seguir podem ser √∫teis:\n\n- [https://code.visualstudio.com/docs/getstarted/getting-started](https://code.visualstudio.com/docs/getstarted/getting-started)\n- [https://code.visualstudio.com/docs/languages/julia](https://code.visualstudio.com/docs/languages/julia)\n\n## Verifique seu Aprendizado\n\n1. Qual a diferen√ßa entre os resultados obtidos pelos operadores `/` e `div` em Julia? Em quais situa√ß√µes cada um seria mais apropriado?\n2. Por que a express√£o `2.6 - 0.7 - 1.9` n√£o resulta exatamente em zero? O que isso nos ensina sobre c√°lculos computacionais?\n3. Explique o que significa 'tipagem din√¢mica' e como isso afeta o comportamento das vari√°veis quando atribu√≠mos diferentes tipos de valores a elas.\n4. Use a fun√ß√£o `big()` para calcular $2^{1000}$. Compare este resultado com o que acontece ao tentar calcular $2^{1000}$ sem usar `big()`.\n5. Armazene seu nome e sobrenome em vari√°veis separadas e depois combine-as para formar seu nome completo com um espa√ßo entre elas. Demonstre tamb√©m a opera√ß√£o de repeti√ß√£o de strings.\n6. Crie as vari√°veis `a = 10`, `b = 3` e `c = 4.5`. Realize os seguintes c√°lculos: `a + b + c`, `a * b * c`, `a % b` e verifique o tipo do resultado de cada opera√ß√£o usando `typeof()`.\n\n## Explore por Conta Pr√≥pria\n\n1. Procure na documenta√ß√£o duas fun√ß√µes matem√°ticas que n√£o foram mencionadas no cap√≠tulo e teste seu uso no REPL.\n2. O que acontece quando voc√™ tenta dividir um n√∫mero por zero em Julia? E quando calcula `0/0`? Teste e observe os resultados.\n3. Experimente o operador Unicode `‚âà` (digite `\\approx` seguido de **TAB**). Como ele se comporta ao comparar `0.1 + 0.2 ‚âà 0.3`?\n4. Investigue a fun√ß√£o `round()` e utilize-a para corrigir alguns dos problemas de precis√£o demonstrados no cap√≠tulo.\n\n",
    "supporting": [
      "02-calculadora-repl_files/figure-pdf"
    ],
    "filters": []
  }
}