{
  "hash": "01229e1191e88e56b9ed649ff182756b",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n# Usando o Interpretador (REPL) como Calculadora\n\nO objetivo deste capítulo é apresentar o interpretador de Julia como uma calculadora poderosa e introduzir os primeiros conceitos de programação: variáveis e funções. Mas primeiro é preciso instalar a linguagem Julia em seu computador. Mais detalhes sobre o processo de instalação podem ser encontrados neste [link](https://julialang.org/downloads/).\n\nMuito provavelmente seu sistema é Windows (10 ou 11) e sua arquitetura é de 64-bits. Há algumas formas de instalar Julia no Windows:\n\n1. Através de um arquivo executável (`.exe`).\n2. Através de comandos pelo terminal (`winget`).\n\nA princípio qualquer uma das opções é adequada. A primeira opção não requer nenhum programa adicional, enquanto que a segunda requer um terminal. Um terminal é um aplicativo que permite a comunicação com o sistema operacional por meio de uma interface de linha de comando (CLI). O terminal padrão do Windows é o Windows Terminal. É fortemente recomendado que você o tenha instalado e isso pode ser feito através da Microsoft Store.\n\nUma vez que você tenha acesso a um terminal há dois comandos possíveis para instalar Julia: `winget install julia -s msstore` ou `winget install -e --id Julialang.Julia`. Mais uma vez, qualquer uma das opções deve funcionar.\n\n## Explorando a Sessão Interativa de Julia\n\nVocê pode abrir uma sessão interativa (também conhecido como um *read-eval-print loop* ou REPL) de Julia digitando o comando `julia` na linha de comando do seu terminal. No Windows, após instalação da linguagem, é possível abrir uma sessão interativa clicando duas vezes no executável Julia. A sua janela deve ser parecida com\n\n```\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.3 (2025-01-21)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia>\n```\n\nDentro da sessão podemos inserir comandos que serão lidos, avaliados e impressos na tela. Um comando só é avaliado quando teclamos **Enter**. Vamos começar com operações com números inteiros. Para somar dois números podemos digitar:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n1 + 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara multiplicar outros dois número:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n40 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n160\n```\n:::\n:::\n\n\n\n\n\n\n\n\nComo esperado, podemos utilizar as operações básicas de soma (`+`), subtração (`-`) e multiplicação (`*`), e os resultados ocorrem como previsto. No entanto, observaremos a seguir que o comportamento da divisão apresenta algumas particularidades:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 84 \nb = 2\n\n# As variáveis a e b são do tipo Int64\n\nresultado = a / b\nprintln(resultado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNotem que, neste exemplo, ocorreu uma conversão de tipo, pois 84 e 2 são números inteiros, enquanto o resultado é um número em ponto flutuante (float). Os pontos flutuantes são representações binárias de números reais, tema que exploraremos com mais detalhes em breve. Esta conversão fica evidente pela representação do resultado como `42.0`, em vez de simplesmente `42`. Caso deseje obter o resultado como um número inteiro, é possível utilizar o operador `div`:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ndiv(84,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu de forma equivalente usando o operador `\\div` (para conseguir ver o símbolo da divisão é necessário digitar `\\div` seguido da tecla `<tab>`).\n\nAlém das operações básicas, é possível fazer exponenciação:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2^31\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2147483648\n```\n:::\n:::\n\n\n\n\n\n\n\n\nExpressões mais complexas também podem ser calculadas:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23 + 2 * 2 + 3 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\n\n\n\nSim, a precedência de operadores usual também é válida em Julia. Entretanto, lembre-se da primeira lição de programação: *Escreva para humanos, não para máquinas*. Podemos usar parênteses para separar as operações:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23 + (2 * 2) + (3 * 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\n\n\n\nLembra dos pontos flutuantes? Todas as operações vistas podem ser aplicadas em pontos flutuantes:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23.5 * 3.14\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n73.79\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n12.5 / 2.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n6.25\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\nO exemplo acima demonstra mais um código escrito de forma clara para pessoas, onde ao utilizarmos `2.0` deixamos explícito que o segundo parâmetro é um número de ponto flutuante (float). É fundamental compreender que números de ponto flutuante possuem precisão **limitada**, portanto não se surpreenda ao encontrar resultados inesperados como os demonstrados abaixo:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n1.2 - 1.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.19999999999999996\n```\n:::\n:::\n\n\n\n\n\n\n\n\nErros como esse são bastante raros, tanto que normalmente depositamos total confiança nas contas realizadas por computadores e calculadoras. No entanto, é importante reconhecer que existem limitações (veja os exemplos abaixo).\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2.6 - 0.7 - 1.9\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.220446049250313e-16\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n0.1 + 0.2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n10e15 + 1 - 10e15\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nEsses problemas de precisão estão ligados à limitação de como os números são representados no computador. De maneira simplificada, os valores no computador são codificados em palavras, formadas por bits. Nos computadores modernos, as palavras têm 64 bits, ou 8 bytes. Logo, uma outra limitação está relacionada aos números inteiros muito grandes.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2^63\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n-9223372036854775808\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNo entanto, para um curso introdutório, é suficiente estar ciente dessas limitações. O tratamento dessas questões faz parte de disciplinas mais avançadas. Vale ressaltar que o erro mencionado anteriormente é um *erro silencioso*, ou seja, ao trabalharmos com números inteiros, pode acontecer que o valor a ser representado exceda a capacidade do número de bits disponível, resultando em uma falha que ocorre sem notificação explícita.\n\nVoltando às contas. Um outro operador interessante é o `%` que calcula o resto da divisão\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n4 % 3\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAté agora vimos como trabalhar com um único valor, como se estivéssemos usando o visor de uma calculadora. Mas podemos ir além disso. Em vez de simples teclas de memória, o computador nos oferece **variáveis**. Essas são como nomes para valores que queremos armazenar e utilizar posteriormente.\n\nAlém das operações básicas também temos as operações matemáticas (funções), como por exemplo o seno, *sine* em inglês. Para saber como uma função funciona podemos pedir ajuda ao ambiente, usando uma `?` ou o macro `@doc`, e em seguida digitando o que queremos saber, como por exemplo em:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n@doc sin\n```\n:::\n\n\n\n\n\n\n\n\nA saída desse comando indica a operação que a função realiza e ainda apresenta alguns exemplos: \n\n```\nsin(x)\n\nCompute sine of x, where x is in radians.\n\nSee also sind, sinpi, sincos, cis, asin.\n\nExamples\n≡≡≡≡≡≡≡≡\n\njulia> round.(sin.(range(0, 2pi, length=9)'), digits=3)\n1×9 Matrix{Float64}:\n0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0\n```\n\nAmbos os comandos `? sin` e `@doc sin` possuem a mesma saída.\n\nNotem que nem tudo que foi apresentado faz sentido no momento, mas já dá para entender o uso de uma função como `sin`. Vejamos agora a raiz quadrada:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n@doc sqrt\n```\n:::\n\n\n\n\n\n\n\n\n```\nsqrt(x)\n\nReturn \\sqrt{x}.\n\nThrows DomainError for negative Real arguments. Use complex negative arguments instead. Note that sqrt has a branch cut\nalong the negative real axis.\n\nThe prefix operator √ is equivalent to sqrt.\n\nSee also: hypot\n...\n```\n\nNela vemos que é possível calcular a raiz como em:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAgora, observe que a documentação da função `big()` tem a seguinte ajuda:\n\n```\nbig(T::Type)\n\nCompute the type that represents the numeric type T with arbitrary precision. Equivalent to typeof(big(zero(T))).\n\nExamples\n≡≡≡≡≡≡≡≡\n\njulia> big(Rational)\nRational{BigInt}\n\njulia> big(Float64)\nBigFloat\n\njulia> big(Complex{Int})\nComplex{BigInt}\n\nbig(x)\n\nConvert a number to a maximum precision representation (typically BigInt or BigFloat). See BigFloat for information about\nsome pitfalls with floating-point numbers.\n```\n\nA função `big()` permite criar números de grande magnitude, representados pelos tipos `BigInt` ou `BigFloat`. Essa função é particularmente útil quando você precisa trabalhar com números muito grandes que ultrapassam os limites dos tipos padrão, como `Int64` ou `Int32`. Ao utilizar números do tipo `BigInt`, eliminamos problemas de estouro (overflow), conforme podemos observar abaixo:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nbig(2) ^ 1002\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504\n```\n:::\n:::\n\n\n\n\n\n\n\n\n## Variáveis e Tipos de Dados\n\nComo já introduzido, em Julia, temos o conceito de variáveis. Variáveis servem para armazenar dados diversos, como inteiros e floats. Podemos operar nas variáveis da mesma forma que operamos nos dados que elas guardam (veja o exemplo abaixo).\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 7\n2 + a\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n9\n```\n:::\n:::\n\n\n\n\n\n\n\n\nÉ importante destacar que as variáveis em Julia podem receber novos valores, e o tipo da variável é determinado pela última atribuição realizada. A função `typeof` pode ser usada para identificar o tipo da variável especificada.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 3\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = a + 1\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNo exemplo a seguir, a variável `b` começa com um valor de tipo inteiro. No entanto, após a operação de multiplicação, seu valor passa a ser do tipo ponto flutuante.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nb = 3\nb = b * 0.5\ntypeof(b)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n\n\n\n\n\nA capacidade de alterar o tipo da variável é conhecida como **tipagem dinâmica**. Esta característica apresenta diversas vantagens, como a flexibilidade de reutilizar variáveis para armazenar diferentes tipos de dados ao longo do tempo e a menor verbosidade, pois não é necessário especificar o tipo de cada variável, o que melhora a legibilidade do código. Neste contexto, podemos observar que Julia possui vários tipos primitivos, sendo os principais:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1.1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(\"Bom dia\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nString\n```\n:::\n:::\n\n\n\n\n\n\n\n\nFalando em **strings**, elas são definidas por conjuntos de caracteres entre aspas como:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Olha que legal\"\ns2 = \"Outra String\"\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Outra String\"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nTambém é possível realizar operações com strings, como concatenação:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Tenha um\"\ns2 = \" Bom dia\"\ns3 = s1 * s2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Tenha um Bom dia\"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu repetição usando o operador de potência:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns = \"Não vou mais fazer coisas que possam desagradar os meus colegas \"\ns ^ 10\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fa\" ⋯ 100 bytes ⋯ \" meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas \"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAinda sobre variáveis, há algumas regras referentes aos seus nomes: devem começar com uma letra (ou com `_`), podem conter dígitos e não podem ser palavras reservadas. Vale ressaltar que Julia, por ser uma linguagem moderna, aceita caracteres unicode e emojis nos nomes, como por exemplo o Δ (`\\Delta`).\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nΔ = 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n🐱 = 5 # \\:cat: <tab>\n🐶 = 3 # \\:dog: <tab>\n🏠 = 20 # \\:house: <tab>\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n20\n```\n:::\n:::\n\n\n\n\n\n\n\n\nIsso não adiciona nada do lado de algoritmos, mas é possível ter variáveis bem bonitinhas. A lista de figuras pode ser encontrada [aqui](https://docs.julialang.org/en/v1/manual/unicode-input/).\n\n## Saída de Dados\nPara fazer saídas usam-se dois comandos, `print()` e o `println()`, sendo que o primeiro não pula linha e o segundo pula.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nprint(\"Hello \")\nprintln(\"World!\")\nprintln(\"Ola, mundo!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World!\nOla, mundo!\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara evitar que se digitem muitos caracteres, por vezes podemos usar *açucares sintáticos*.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nx = 1\nx = x + 1\nx += 1  # forma equivalente a acima, o mesmo vale para os operadores *, - e /\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n\n\n\n\n\nO código acima utiliza comentários (tudo depois do `#`). Esses comentários são ignorados pelo interpretador e podem ser usados para tornar o código mais legível.\n\n## Arquivos Externos\n\nPodemos carregar funções de outros arquivos na sessão interativa (e em outros arquivos também) usando o comando `include(\"caminho/do/arquivo.jl\")`. Julia lê o arquivo especificado e executa todo o seu conteúdo no contexto atual. Isso significa que todas as funções, variáveis e definições no arquivo tornam-se disponíveis no ambiente onde `include` foi chamado.\n\nPor exemplo, suponha que temos um arquivo chamado `funcoes.jl` que possui a função `ola`:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction ola(nome)\n    println(\"Olá \", nome)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nola (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPodemos incluir essa função em um segundo arquivo utilizando o `include(\"funcoes.jl\")` e então usar a função definida no arquivo `funcoes.jl`:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\ninclude(\"funcoes.jl\")\nprintln(ola(\"Alfredo\"))\n```\n:::\n\n\n\n\n\n\n\n\nA saída deverá ser `Olá Alfredo`.\n\n### O que é um arquivo `.jl`?\n\nUm arquivo `.jl` é semelhante a um arquivo de texto `.txt`, porém com a extensão `.jl`. Embora seja possível abri-lo com um editor de texto simples como o Bloco de Notas, não é recomendado utilizá-lo para programação. Os arquivos `.jl` são arquivos de código-fonte da linguagem Julia e são geralmente editados com editores específicos para programação, como Visual Studio Code, Atom ou Sublime Text.\n\nNão existe um editor de texto definitivamente superior aos demais, o importante é escolher aquele com o qual você se sinta mais confortável. Nossa recomendação é o Visual Studio Code, que oferece recursos muito mais avançados que um editor de texto comum e possui uma extensão dedicada à linguagem Julia, facilitando significativamente a escrita de código. Para começar a usar o Visual Studio Code com Julia, os tutoriais a seguir podem ser úteis:\n\n- [https://code.visualstudio.com/docs/getstarted/getting-started](https://code.visualstudio.com/docs/getstarted/getting-started)\n- [https://code.visualstudio.com/docs/languages/julia](https://code.visualstudio.com/docs/languages/julia)\n\n## Verifique seu Aprendizado\n\n1. Qual a diferença entre os resultados obtidos pelos operadores `/` e `div` em Julia? Em quais situações cada um seria mais apropriado?\n2. Por que a expressão `2.6 - 0.7 - 1.9` não resulta exatamente em zero? O que isso nos ensina sobre cálculos computacionais?\n3. Explique o que significa 'tipagem dinâmica' e como isso afeta o comportamento das variáveis quando atribuímos diferentes tipos de valores a elas.\n4. Use a função `big()` para calcular $2^{1000}$. Compare este resultado com o que acontece ao tentar calcular $2^{1000}$ sem usar `big()`.\n5. Armazene seu nome e sobrenome em variáveis separadas e depois combine-as para formar seu nome completo com um espaço entre elas. Demonstre também a operação de repetição de strings.\n6. Crie as variáveis `a = 10`, `b = 3` e `c = 4.5`. Realize os seguintes cálculos: `a + b + c`, `a * b * c`, `a % b` e verifique o tipo do resultado de cada operação usando `typeof()`.\n\n## Explore por Conta Própria\n\n1. Procure na documentação duas funções matemáticas que não foram mencionadas no capítulo e teste seu uso no REPL.\n2. O que acontece quando você tenta dividir um número por zero em Julia? E quando calcula `0/0`? Teste e observe os resultados.\n3. Experimente o operador Unicode `≈` (digite `\\approx` seguido de **TAB**). Como ele se comporta ao comparar `0.1 + 0.2 ≈ 0.3`?\n4. Investigue a função `round()` e utilize-a para corrigir alguns dos problemas de precisão demonstrados no capítulo.\n\n",
    "supporting": [
      "02-calculadora-repl_files/figure-pdf"
    ],
    "filters": []
  }
}