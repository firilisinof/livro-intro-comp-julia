{
  "hash": "a2a1d8c946a438dea1caf6ef8a509e93",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n# Usando o Interpretador (REPL) como Calculadora\n\nO objetivo deste capítulo é apresentar o interpretador de Julia como uma calculadora poderosa e introduzir os primeiros conceitos de programação: variáveis e funções. Mas primeiro é preciso instalar a linguagem Julia em seu computador. Mais detalhes sobre o processo de instalação podem ser encontrados neste [link](https://julialang.org/downloads/).\n\nMuito provavelmente seu sistema é Windows (10 ou 11) e sua arquitetura é de 64-bits. Há algumas formas de instalar Julia no Windows:\n\n1. Através de um arquivo executável (`.exe`).\n2. Através de comandos pelo terminal (`winget`).\n\nA princípio qualquer uma das opções é adequada. A primeira opção não requer nenhum programa adicional, enquanto que a segunda requer um terminal. Um terminal é um aplicativo que permite a comunicação com o sistema operacional por meio de uma interface de linha de comando (CLI). O terminal padrão do Windows é o Windows Terminal. É fortemente recomendado que você o tenha instalado e isso pode ser feito através da Microsoft Store.\n\nUma vez que você tenha acesso a um terminal há dois comandos possíveis para instalar Julia: `winget install julia -s msstore` ou `winget install -e --id Julialang.Julia`. Mais uma vez, qualquer uma das opções deve funcionar.\n\n## Explorando a Sessão Interativa de Julia\n\nVocê pode abrir uma sessão interativa (também conhecido como um *read-eval-print loop* ou REPL) de Julia digitando o comando `julia` na linha de comando do seu terminal. No Windows, após instalação da linguagem, é possível abrir uma sessão interativa clicando duas vezes no executável Julia. A sua janela deve ser parecida com\n\n```\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.3 (2025-01-21)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia>\n```\n\nDentro da sessão podemos inserir comandos que serão lidos, avaliados e impressos na tela. Um comando só é avaliado quando teclamos **Enter**. Vamos começar com operações com números inteiros. Para somar dois números podemos digitar:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n1 + 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara multiplicar outros dois número:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n40 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n160\n```\n:::\n:::\n\n\n\n\n\n\n\n\nComo esperado, podemos utilizar as operações básicas de soma (`+`), subtração (`-`) e multiplicação (`*`), e os resultados ocorrem como previsto. No entanto, observaremos a seguir que o comportamento da divisão apresenta algumas particularidades:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 84 \nb = 2\n\n# As variáveis a e b são do tipo Int64\n\nresultado = a / b\nprintln(resultado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNotem que, neste exemplo, ocorreu uma conversão de tipo, pois 84 e 2 são números inteiros, enquanto o resultado é um número em ponto flutuante (float). Os pontos flutuantes são representações binárias de números reais, tema que exploraremos com mais detalhes em breve. Esta conversão fica evidente pela representação do resultado como `42.0`, em vez de simplesmente `42`. Caso deseje obter o resultado como um número inteiro, é possível utilizar o operador `div`:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ndiv(84,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu de forma equivalente usando o operador `\\div` (para conseguir ver o símbolo da divisão é necessário digitar `\\div` seguido da tecla `<tab>`).\n\nAlém das operações básicas, é possível fazer exponenciação:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2^31\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2147483648\n```\n:::\n:::\n\n\n\n\n\n\n\n\nExpressões mais complexas também podem ser calculadas:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23 + 2 * 2 + 3 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\n\n\n\nSim, a precedência de operadores usual também é válida em Julia. Entretanto, lembre-se da primeira lição de programação: *Escreva para humanos, não para máquinas*. Podemos usar parênteses para separar as operações:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23 + (2 * 2) + (3 * 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\n\n\n\nLembra dos pontos flutuantes? Todas as operações vistas podem ser aplicadas em pontos flutuantes:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23.5 * 3.14\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n73.79\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n12.5 / 2.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n6.25\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\nO exemplo acima demonstra mais um código escrito de forma clara para pessoas, onde ao utilizarmos `2.0` deixamos explícito que o segundo parâmetro é um número de ponto flutuante (float). É fundamental compreender que números de ponto flutuante possuem precisão **limitada**, portanto não se surpreenda ao encontrar resultados inesperados como os demonstrados abaixo:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n1.2 - 1.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.19999999999999996\n```\n:::\n:::\n\n\n\n\n\n\n\n\nErros como esse são bastante raros, tanto que normalmente depositamos total confiança nas contas realizadas por computadores e calculadoras. No entanto, é importante reconhecer que existem limitações (veja os exemplos abaixo).\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2.6 - 0.7 - 1.9\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.220446049250313e-16\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n0.1 + 0.2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n10e15 + 1 - 10e15\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nEsses problemas de precisão estão ligados à limitação de como os números são representados no computador. De maneira simplificada, os valores no computador são codificados em palavras, formadas por bits. Nos computadores modernos, as palavras têm 64 bits, ou 8 bytes. Logo, uma outra limitação está relacionada aos números inteiros muito grandes.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2^63\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n-9223372036854775808\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNo entanto, para um curso introdutório, é suficiente estar ciente dessas limitações. O tratamento dessas questões faz parte de disciplinas mais avançadas. Vale ressaltar que o erro mencionado anteriormente é um *erro silencioso*, ou seja, ao trabalharmos com números inteiros, pode acontecer que o valor a ser representado exceda a capacidade do número de bits disponível, resultando em uma falha que ocorre sem notificação explícita.\n\nVoltando às contas. Um outro operador interessante é o `%` que calcula o resto da divisão\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n4 % 3\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAté agora vimos como trabalhar com um único valor, como se estivéssemos usando o visor de uma calculadora. Mas podemos ir além disso. Em vez de simples teclas de memória, o computador nos oferece **variáveis**. Essas são como nomes para valores que queremos armazenar e utilizar posteriormente.\n\nAlém das operações básicas também temos as operações matemáticas (funções), como por exemplo o seno, *sine* em inglês. Para saber como uma função funciona podemos pedir ajuda ao ambiente, usando uma `?` ou o macro (funções especiais) `@doc`, e em seguida digitando o que queremos saber, como por exemplo em:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n@doc sin\n```\n:::\n\n\n\n\n\n\n\n\nA saída desse comando indica a operação que a função realiza e ainda apresenta alguns exemplos: \n\n```\nsin(x)\n\nCompute sine of x, where x is in radians.\n\nSee also sind, sinpi, sincos, cis, asin.\n\nExamples\n≡≡≡≡≡≡≡≡\n\njulia> round.(sin.(range(0, 2pi, length=9)'), digits=3)\n1×9 Matrix{Float64}:\n0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0\n```\n\nAmbos os comandos `? sin` e `@doc sin` possuem a mesma saída.\n\nNotem que nem tudo que foi apresentado faz sentido no momento, mas já dá para entender o uso de uma função como `sin`. Vejamos agora a raiz quadrada:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n@doc sqrt\n```\n:::\n\n\n\n\n\n\n\n\n```\nsqrt(x)\n\nReturn \\sqrt{x}.\n\nThrows DomainError for negative Real arguments. Use complex negative arguments instead. Note that sqrt has a branch cut\nalong the negative real axis.\n\nThe prefix operator √ is equivalent to sqrt.\n\nSee also: hypot\n...\n```\n\nNela vemos que é possível calcular a raiz como em:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAgora, observe que a documentação da função `big()` tem a seguinte ajuda:\n\n```\nbig(T::Type)\n\nCompute the type that represents the numeric type T with arbitrary precision. Equivalent to typeof(big(zero(T))).\n\nExamples\n≡≡≡≡≡≡≡≡\n\njulia> big(Rational)\nRational{BigInt}\n\njulia> big(Float64)\nBigFloat\n\njulia> big(Complex{Int})\nComplex{BigInt}\n\nbig(x)\n\nConvert a number to a maximum precision representation (typically BigInt or BigFloat). See BigFloat for information about\nsome pitfalls with floating-point numbers.\n```\n\nA função `big()` permite criar números de grande magnitude, representados pelos tipos `BigInt` ou `BigFloat`. Essa função é particularmente útil quando você precisa trabalhar com números muito grandes que ultrapassam os limites dos tipos padrão, como `Int64` ou `Int32`. Ao utilizar números do tipo `BigInt`, eliminamos problemas de estouro (overflow), conforme podemos observar abaixo:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nbig(2) ^ 1002\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504\n```\n:::\n:::\n\n\n\n\n\n\n\n\n## Variáveis e Tipos de Dados\n\nComo já introduzido, em Julia, temos o conceito de variáveis. Variáveis servem para armazenar dados diversos, como inteiros e floats. Podemos operar nas variáveis da mesma forma que operamos nos dados que elas guardam (veja o exemplo abaixo).\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 7\n2 + a\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n9\n```\n:::\n:::\n\n\n\n\n\n\n\n\nQuando escrevemos `a = 7`, estamos realizando uma operação chamada **atribuição**. O operador `=` em Julia (e na maioria das linguagens de programação) não representa igualdade matemática, mas sim uma instrução para armazenar o valor à direita na variável à esquerda. Podemos visualizar isso como se estivéssemos colocando o valor `7` dentro de uma caixa chamada `a`. \n\nÉ importante destacar que as variáveis em Julia podem receber novos valores, e o tipo da variável é determinado pela última atribuição realizada. A função `typeof` pode ser usada para identificar o tipo da variável especificada.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 3\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = a + 1\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n\n\n\n\n\nA atribuição sempre acontece da direita para a esquerda: primeiro calcula-se o valor da expressão à direita, e depois esse valor é armazenado na variável à esquerda. No exemplo a seguir, a variável `b` começa com um valor de tipo inteiro. No entanto, após a operação de multiplicação, seu valor passa a ser do tipo ponto flutuante.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nb = 3\nb = b * 0.5\ntypeof(b)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n\n\n\n\n\nA capacidade de alterar o tipo da variável é conhecida como **tipagem dinâmica**. Esta característica apresenta diversas vantagens, como a flexibilidade de reutilizar variáveis para armazenar diferentes tipos de dados ao longo do tempo e a menor verbosidade, pois não é necessário especificar o tipo de cada variável, o que melhora a legibilidade do código. Neste contexto, podemos observar que Julia possui vários tipos primitivos, sendo os principais:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1.1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(\"Bom dia\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nString\n```\n:::\n:::\n\n\n\n\n\n\n\n\nFalando em **strings**, eles são definidos por conjuntos de caracteres entre aspas como:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Olha que legal\"\ns2 = \"Outra String\"\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Outra String\"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nTambém é possível realizar operações com strings, como **concatenação**:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Tenha um\"\ns2 = \" Bom dia\"\ns3 = s1 * s2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Tenha um Bom dia\"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu repetição usando o operador de potência:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns = \"Não vou mais fazer coisas que possam desagradar os meus colegas \"\ns ^ 10\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fa\" ⋯ 100 bytes ⋯ \" meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas \"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara evitar que se digitem muitos caracteres, por vezes podemos usar *açucares sintáticos*.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nx = 1\nx = x + 1\nx += 1  # '+= 1' equivale a '= x + 1', também funciona para os operadores *, - e /\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n\n\n\n\n\nO código acima utiliza comentários (tudo depois do `#`). Esses comentários são ignorados pelo interpretador e podem ser usados para tornar o código mais legível.\n\nAinda sobre variáveis, há algumas regras referentes aos seus nomes: devem começar com uma letra (ou com `_`), podem conter dígitos e não podem ser palavras reservadas. Vale ressaltar que Julia, por ser uma linguagem moderna, aceita caracteres unicode e emojis nos nomes, como por exemplo o Δ (`\\Delta`).\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nΔ = 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n🐱 = 5 # \\:cat: <tab>\n🐶 = 3 # \\:dog: <tab>\n🏠 = 20 # \\:house: <tab>\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n20\n```\n:::\n:::\n\n\n\n\n\n\n\n\nIsso não adiciona nada do lado de algoritmos, mas é possível ter variáveis bem bonitinhas. A lista de figuras pode ser encontrada [aqui](https://docs.julialang.org/en/v1/manual/unicode-input/).\n\n## Saída de Dados\n\nPara imprimir informações no terminal, usamos as funções `print()` e o `println()`. A diferença entre elas é que a primeira não pula linha, enquanto que a segunda pula.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nprint(\"Hello \")\nprintln(\"World!\")\nprintln(\"Ola, mundo!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World!\nOla, mundo!\n```\n:::\n:::\n\n\n\n\n\n\n\n\nO comando `println()` pode receber múltiplos argumentos, que serão convertidos em strings e concatenados automaticamente:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nnome = \"Maria\"\nidade = 25\nprintln(\"Olá, meu nome é \", nome, \" e tenho \", idade, \" anos.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOlá, meu nome é Maria e tenho 25 anos.\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara formatações mais complexas, Julia oferece **interpolação de strings**, onde podemos inserir variáveis e expressões diretamente dentro de uma string usando o cifrão `$`:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nnome = \"João\"\naltura = 1.75\nprintln(\"$nome tem $altura metros de altura.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJoão tem 1.75 metros de altura.\n```\n:::\n:::\n\n\n\n\n\n\n\n\nTambém podemos incluir expressões dentro de chaves após o cifrão:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\npreco = 9.99\nquantidade = 3\nprintln(\"Total da compra: R\\$ $(preco * quantidade)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal da compra: R$ 29.97\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara formatação numérica, podemos usar a função `@sprintf` ou a macro `@printf` do módulo `Printf` (detalhes sobre módulos na @sec-files-modules):\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Printf\n\nvalor = 123.456\n@printf(\"Valor formatado: %.2f\\n\", valor)  # Exibe com 2 casas decimais\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValor formatado: 123.46\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu alternativamente:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nvalor = 123.456\ns = @sprintf(\"Valor formatado: %.2f\", valor)\nprintln(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValor formatado: 123.46\n```\n:::\n:::\n\n\n\n\n\n\n\n\n## Arquivos Externos e Módulos {#sec-files-modules}\n\nNo exemplo anterior usamos a sintaxe `using Printf`. Esta é a sintaxe para importar um módulo em Julia. Os módulos são coleções organizadas de código que podemos utilizar em nossos programas. O módulo `Printf` faz parte da **biblioteca padrão** de Julia e oferece funções para formatação de tipos no estilo da linguagem C. Ao escrever `using Printf`, informamos o interpretador que queremos acessar as funções deste módulo, como `@printf` e `@sprintf`. Para descobrir quais funções estão disponíveis neste e em outros módulos, consulte a documentação oficial de Julia. A documentação específica do módulo `Printf` está disponível em <https://docs.julialang.org/en/v1/stdlib/Printf/>.\n\nJulia vem com vários módulos padrão que podem ser úteis:\n\n- `Statistics`: para cálculos estatísticos (média, mediana, etc.)\n- `Dates`: para trabalhar com datas e horas\n- `Printf`: para formatação avançada de texto\n- `LinearAlgebra`: para operações de álgebra linear\n- `Random`: para geração de números aleatórios\n\nA comunidade de Julia também desenvolve diversos módulos (pacotes) que podem ser instalados para expandir as funcionalidades da linguagem. Vamos aprender a fazer isso mais adiante no curso.\n\nAlém de módulos, Julia permite carregar código de arquivos externos usando o comando `include()`. Este comando lê o arquivo especificado e executa todo seu conteúdo no contexto atual. Como resultado, todas as funções, variáveis e definições do arquivo tornam-se disponíveis no ambiente onde `include` foi chamado.\n\nNo Windows, os caminhos de arquivo tradicionalmente usam barras invertidas (`\\`). Porém, em Julia, podemos usar tanto barras normais (`/`) quanto barras invertidas. Há um detalhe importante: quando usamos barras invertidas dentro de strings em Julia, precisamos duplicá-las. Isso ocorre porque a barra invertida sozinha (`\\`) é um caractere especial em strings, usado para representar caracteres como `\\n` (nova linha) ou `\\t` (tabulação). Para indicar que queremos uma barra invertida literal, precisamos escrever duas (`\\\\`). Por esse motivo, caminhos com várias pastas tornam-se mais difíceis de ler:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n# Caminho usando barras normais (recomendado)\ninclude(\"C:/Users/MeuUsuario/Documentos/arquivo.jl\")\n\n# Mesmo caminho usando barras invertidas (mais complicado)\ninclude(\"C:\\\\Users\\\\MeuUsuario\\\\Documentos\\\\arquivo.jl\")\n```\n:::\n\n\n\n\n\n\n\n\nSe o arquivo estiver no mesmo diretório que seu script ou REPL atual, basta usar o nome do arquivo:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\ninclude(\"funcoes.jl\")\n```\n:::\n\n\n\n\n\n\n\n\nPara arquivos em subdiretórios do diretório atual:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\ninclude(\"utilitarios/matematica.jl\")\n```\n:::\n\n\n\n\n\n\n\n\nPara arquivos no diretório pai:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\ninclude(\"../exemplos.jl\")\n```\n:::\n\n\n\n\n\n\n\n\nVamos ver um exemplo prático. Suponha que você tenha criado um arquivo chamado `funcoes.jl` na pasta `C:/Projetos/Julia/` com o seguinte conteúdo:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\nfunction ola(nome)\n    println(\"Olá \", nome)\nend\n\nfunction soma(a, b)\n    return a + b\nend\n```\n:::\n\n\n\n\n\n\n\n\nAgora você pode usar essas funções (mais sobre funções no @sec-functions) no REPL ou em outro arquivo:\n\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n# No REPL ou em um arquivo na mesma pasta:\ninclude(\"funcoes.jl\")\n\n# Ou com caminho completo:\ninclude(\"C:/Projetos/Julia/funcoes.jl\")\n\n# Agora podemos usar as funções definidas em funcoes.jl\nola(\"Alfredo\")         # Imprime: Olá Alfredo\nresultado = soma(5, 3) # resultado = 8\nprintln(resultado)     # Imprime: 8\n```\n:::\n\n\n\n\n\n\n\n\nEsta funcionalidade é especialmente útil para organizar seu código em múltiplos arquivos, permitindo que você divida programas maiores em partes menores.\n\n### O que é um arquivo `.jl`?\n\nUm arquivo `.jl` é semelhante a um arquivo de texto `.txt`, porém com a extensão `.jl`. Embora seja possível abri-lo com um editor de texto simples como o Bloco de Notas, não é recomendado utilizá-lo para programação. Os arquivos `.jl` são arquivos de código-fonte da linguagem Julia e são geralmente editados com editores específicos para programação, como Visual Studio Code, Atom ou Sublime Text.\n\nNão existe um editor de texto definitivamente superior aos demais, o importante é escolher aquele com o qual você se sinta mais confortável. Nossa recomendação é o Visual Studio Code, que oferece recursos muito mais avançados que um editor de texto comum e possui uma extensão dedicada à linguagem Julia, facilitando significativamente a escrita de código. Para começar a usar o Visual Studio Code com Julia, os tutoriais a seguir podem ser úteis:\n\n- [https://code.visualstudio.com/docs/getstarted/getting-started](https://code.visualstudio.com/docs/getstarted/getting-started)\n- [https://code.visualstudio.com/docs/languages/julia](https://code.visualstudio.com/docs/languages/julia)\n\n## Verifique seu Aprendizado\n\n1. Qual a diferença entre os resultados obtidos pelos operadores `/` e `div` em Julia? Em quais situações cada um seria mais apropriado?\n2. Por que a expressão `2.6 - 0.7 - 1.9` não resulta exatamente em zero? O que isso nos ensina sobre cálculos computacionais?\n3. Explique o que significa 'tipagem dinâmica' e como isso afeta o comportamento das variáveis quando atribuímos diferentes tipos de valores a elas.\n4. Use a função `big()` para calcular $2^{1000}$. Compare este resultado com o que acontece ao tentar calcular $2^{1000}$ sem usar `big()`.\n5. Armazene seu nome e sobrenome em variáveis separadas e depois combine-as para formar seu nome completo com um espaço entre elas. Demonstre também a operação de repetição de strings.\n6. Crie as variáveis `a = 10`, `b = 3` e `c = 4.5`. Realize os seguintes cálculos: `a + b + c`, `a * b * c`, `a % b` e verifique o tipo do resultado de cada operação usando `typeof()`.\n\n## Explore por Conta Própria\n\n1. Procure na documentação duas funções matemáticas que não foram mencionadas no capítulo e teste seu uso no REPL.\n2. O que acontece quando você tenta dividir um número por zero em Julia? E quando calcula `0/0`? Teste e observe os resultados.\n3. Experimente o operador Unicode `≈` (digite `\\approx` seguido de **TAB**). Como ele se comporta ao comparar `0.1 + 0.2 ≈ 0.3`?\n4. Investigue a função `round()` e utilize-a para corrigir alguns dos problemas de precisão demonstrados no capítulo.\n\n",
    "supporting": [
      "02-calculadora-repl_files/figure-pdf"
    ],
    "filters": []
  }
}