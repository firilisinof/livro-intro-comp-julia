{
  "hash": "4743872be120018651727a46d7bdff59",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n# Usando o Interpretador (REPL) como Calculadora\n\nObjetivo: Ver o interpretador de Julia como uma calculadora poderosa, introduzir a noção de variáveis.\n\n## Começando com o modo interativo do Julia\n\nQuem quiser já pode instalar o ambiente de programação, usem esse [link](https://julialang.org/). Há também alguns ambientes que permitem o uso da linguagem no seu navegador, sugiro a busca pelas palavras chave `Julia Language online`.\n\nDentro do Julia (após chamar julia na linha de comando), vamos começar com contas com números inteiros:\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\n1 + 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n40 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n160\n```\n:::\n:::\n\n\n\n\n\n\n\n\nSim, como era de se esperar, podemos em Julia usar os operandos: `+`, `-` e `*`, o resultado será como o esperado. Vejamos a seguir que com a divisão fica um pouco diferente:\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\na = 84 \nb = 2\n\n# As variáveis a e b são do tipo Int64\n\nresultado = a / b\nprintln(resultado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNotem que nesse caso, houve uma mudança de tipos, pois 84 e 2 são inteiros e o resultado é um número em ponto flutuante (float), podemos ver isso, pois ao invés de 42, tivemos como resultado 42.0.\n\nTambém é possível pedir o resultado inteiro usando o operador `div`:\n\n\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\ndiv(84,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu de forma equivalente usando o operador `\\div` (para conseguir ver o símbolo da divisão é necessário digitar `\\div` seguido da tecla `<tab>`).\n\nAlém das contas básicas, também dá para fazer a exponenciação:\n\n\n\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n2^31\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2147483648\n```\n:::\n:::\n\n\n\n\n\n\n\n\nExpressões mais complexas também podem ser calculadas:\n\n\n\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n23 + 2 * 2 + 3 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\n\n\n\nSim, a precedência de operadores usual também é válida em Julia. Mas, segue a primeira lição de programação: *Escreva para humanos, não para máquinas*.\n\n\n\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\n23 + (2 * 2) + (3 * 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\n\n\n\nEm Julia também podemos fazer operações com números em ponto flutuante:\n\n\n\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\n23.5 * 3.14\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n73.79\n```\n:::\n:::\n\n\n\n\n\n\n\n\nou\n\n\n\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\n12.5 / 2.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n6.25\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAcima temos mais um exemplo de código escrito para pessoas, ao se escrever 2.0 estamos deixando claro que o segundo parâmetro é um número float.\n\nÉ importante saber que números em ponto flutuante tem precisão limitada, logo não se espante com resultados inesperados como abaixo:\n\n\n\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\n1.2 - 1.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.19999999999999996\n```\n:::\n:::\n\n\n\n\n\n\n\n\nErros como esse são bastante raros, tanto que usualmente confiamos plenamente nas contas feitas com computadores e calculadoras. Mas, é bom saber que existem limitações.\n\n\n\n\n\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\n2.6 - 0.7 - 1.9\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.220446049250313e-16\n```\n:::\n:::\n\n\n\n\n\n\n\n\nou\n\n\n\n\n\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\n0.1 + 0.2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n\n\n\n\n\n\nou ainda\n\n\n\n\n\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\n10e15 + 1 - 10e15\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nEsses problemas de precisão estão ligados a limitação de como os números são representados no computador. De maneira simplificada, os valores no computador são codificados em palavras, formadas por bits. Nos computadores modernos as palavras tem 64 bits, ou 8 bytes. Logo, uma outra limitação está ligada aos números inteiros muito grandes\n\n\n\n\n\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code}\n2^63\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n-9223372036854775808\n```\n:::\n:::\n\n\n\n\n\n\n\n\nMas, para um curso introdutório basta saber que existem essas limitações. Como lidar com elas é parte de um curso mais avançado.\n\nÉ importante notar que o erro acima é um *erro silencioso*, ou seja quanto estamos usando números inteiros, pode ocorrer que o número a ser representado não caiba no número de bits disponível, o que faz com que ocorra um erro.\n\nVoltando para as contas. Um outro operador interessante é o `%` que faz o resto da divisão\n\n\n\n\n\n\n::: {#30 .cell execution_count=1}\n``` {.julia .cell-code}\n4 % 3\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAté agora vimos como trabalhar com um único valor, ou seja, como se fosse no visor de uma calculadora. Mas, é possível ir além. Ao invés de termos teclas de memória, o computador nos oferece variáveis. Elas são como nomes para valores que queremos guardar e usar mais tarde.\n\nAlém das operações básicas também temos as operações matemáticas (funções), como por exemplo o seno, sin em inglês. Para saber como uma função funciona podemos pedir ajuda ao ambiente, usando uma `?` ou o macro `@doc`, e em seguida digitando o que queremos saber, como por exemplo em:\n\n\n\n\n\n\n::: {#32 .cell execution_count=0}\n``` {.julia .cell-code}\n@doc sin\n```\n:::\n\n\n\n\n\n\n\n\nA saída desse comando indica a operação que a função realiza e ainda apresenta alguns exemplos: \n\n```\n  sin(x)\n\n  Compute sine of x, where x is in radians.\n\n  See also sind, sinpi, sincos, cis, asin.\n\n  Examples\n  ≡≡≡≡≡≡≡≡\n\n  julia> round.(sin.(range(0, 2pi, length=9)'), digits=3)\n  1×9 Matrix{Float64}:\n   0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0\n```\n\n\nAmbos os comandos `? sin` `@doc sin` possuem a mesma saída.\n\n\nNotem que nem tudo que foi apresentado faz sentido no momento, mas já dá para entender o uso de uma função como sin. Vejamos agora a raiz quadrada:\n\n\n\n\n\n\n::: {#34 .cell execution_count=0}\n``` {.julia .cell-code}\n@doc sqrt\n```\n:::\n\n\n\n\n\n\n\n\nNela vemos que é possível calcular a raiz como em:\n\n\n\n\n\n\n::: {#36 .cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n::: {#38 .cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n\n\n\n\n\nMas, observamos também na documentação a função `big()`, que tem a seguinte ajuda:\n\n\n\n\n\n\n::: {#40 .cell execution_count=0}\n``` {.julia .cell-code}\n@doc BigInt\n```\n:::\n\n\n\n\n\n\n\n\nA função `big()` em Julia é usada para criar números inteiros grandes, representados pelo tipo BigInt. Essa função é especialmente útil quando você precisa lidar com números muito grandes que excedem o limite dos tipos inteiros padrão, como Int64 ou Int32.\n\nCom números BigInt, já não há problemas de estouro, como podemos ver abaixo:\n\n\n\n\n\n\n::: {#42 .cell execution_count=1}\n``` {.julia .cell-code}\nbig(2) ^ 1002\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\nPodemos ainda carregar funções de outros arquivos em nosso arquivo Julia ou no próprio terminal, para isso basta utilizar o comando `include(\"caminho/do/arquivo.jl\")`, Julia lê o arquivo especificado e executa todo o seu conteúdo no contexto atual. Isso significa que todas as funções, variáveis e definições no arquivo tornam-se disponíveis no ambiente onde `include` foi chamado.\n\nComo por exemplo no primeiro caso tenho um arquivo chamado `funcoes.jl` que possui a função soma:\n\n\n\n\n\n\n::: {#44 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction ola(nome)\n    println(\"Olá\", nome)\nend\n\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nola (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPodemos incluir essa função em um segundo arquivo utilizando o `include(\"funcoes.jl\")`, e utilizar a função definida no arquivo `funcoes.jl`\n\n```\n    include(\"funcoes.jl\")\n    println(ola(\"Alfredo\"))  \n```\n\nCuja saída deverá ser `Olá Alfredo`.\n\n## Variáveis e seus tipos\n\nEm Julia também temos o conceito de variáveis, que servem para armazenar os diferentes conteúdos de dados possíveis.\n\n\n\n\n\n\n::: {#46 .cell execution_count=1}\n``` {.julia .cell-code}\na = 7\n2 + a\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n9\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n### Tipagem dinâmica\n\nÉ importante notar que as variáveis em Julia podem receber novos valores e o tipo da variável depende do que foi atribuído por último.\n\n\n\n\n\n\n::: {#48 .cell execution_count=1}\n``` {.julia .cell-code}\na = 3\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {#50 .cell execution_count=1}\n``` {.julia .cell-code}\na = a + 1\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNeste próximo exemplo, a variável b é inicializada com um valor de tipo inteiro, contudo, após a operação de multiplicação, seu valor é do tipo ponto flutuante:\n\n\n\n\n\n\n::: {#52 .cell execution_count=1}\n``` {.julia .cell-code}\nb = 3\nb = b * 0.5\ntypeof(b)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n\n\n\n\n\nA tipagem dinâmica apresenta diversas vantagens, entre elas a flexibilidade, pois é possível reutilizar variáveis para armazenar diferentes tipos de dados ao longo do tempo; e menos verbosidade, pois não é necessário especificar o tipo de cada variável, o que melhora a legibilidade do código.\n\nAproveitando o momento, podemos ver que há vários tipos primitivos em Julia, sendo os principais:\n\n\n\n\n\n\n::: {#54 .cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {#56 .cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1.1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n::: {#58 .cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(\"Bom dia\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nString\n```\n:::\n:::\n\n\n\n\n\n\n\n\nFalando em Strings, elas são definidas por conjuntos de caracteres entre aspas como:\n\n\n\n\n\n\n::: {#60 .cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Olha que legal\"\ns2 = \"Outra String\"\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Outra String\"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nDá também para fazer operações com strings como concatenação:\n\n\n\n\n\n\n::: {#62 .cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Tenha um\"\ns2 = \" Bom dia\"\ns3 = s1 * s2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Tenha um Bom dia\"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nOu potência:\n\n\n\n\n\n\n::: {#64 .cell execution_count=1}\n``` {.julia .cell-code}\ns = \"Nao vou mais fazer coisas que possam desagradar os meus colegas \"\ns ^ 10\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fa\" ⋯ 98 bytes ⋯ \"s meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas \"\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAinda sobre variáveis, há umas regras com relação aos seus nomes, tem que começar com uma letra (ou com `_`), pode ter dígitos e não pode ser uma palavra reservada. É bom notar que Julia por ser uma linguagem moderna, aceita nomes de caracteres em unicode, por exemplo o Δ (`\\Delta`):\n\n\n\n\n\n\n::: {#66 .cell execution_count=1}\n``` {.julia .cell-code}\nΔ = 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2\n```\n:::\n:::\n\n\n\n\n\n\n\n\nMas, a linguagem vai bem além com caracteres de animais e símbolos:\n\n\n\n\n\n\n::: {#68 .cell execution_count=1}\n``` {.julia .cell-code}\n🐱 = 5 # \\:cat: <tab>\n🐶 = 3 # \\:dog: <tab>\n🏠 = 20 # \\:house: <tab>\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n20\n```\n:::\n:::\n\n\n\n\n\n\n\n\nIsso não adiciona nada do lado de algoritmos, mas é possível ter variáveis bem bonitinhas. A lista de figuras pode ser encontrada [aqui](   ://docs.julialang.org/en/v1/manual/unicode-input/).\n\n## Saída de dados\nPara fazer saídas usam-se dois comandos, `print()` e o `println()`, sendo que o primeiro não pula linha e o segundo pula.\n\n\n\n\n\n\n::: {#70 .cell execution_count=1}\n``` {.julia .cell-code}\nprint(\"Hello \")\nprintln(\"World!\")\nprintln(\"Ola, mundo!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World!\nOla, mundo!\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara evitar que se digitem muitos caracteres, por vezes podemos usar \"açucares sintáticos\".\n\n\n\n\n\n\n::: {#72 .cell execution_count=1}\n``` {.julia .cell-code}\nx = 1\nx = x + 1\nx += 1  # forma equivalente a acima, o mesmo vale para os operadores *, - e /\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAcima, vimos a forma de se inserir comentários em Julia (sim esses serão ignorados pelo computador).\n\n\nExercício:\nFaça o passo a passo para encontrar as raízes da equação de segundo grau $x^2 - 5 x + 6$, usando\nas váriaveis `a`, `b`, `c`, `\\Delta`, `x1` e `x2`. Após isso, compare com a solução a seguir:\n\n\n\n\n\n\n::: {#74 .cell execution_count=1}\n``` {.julia .cell-code}\n\n# Definição dos coeficientes\na = 1\nb = -5\nc = 6\n\n# Cálculo do discriminante\ndelta = b^2 - 4 * a * c\n\n# Cálculo das raízes\nif delta >= 0\n    x1 = (-b + sqrt(delta)) / (2 * a)\n    x2 = (-b - sqrt(delta)) / (2 * a)\n    println(\"As raízes são: x1 = $x1 e x2 = $x2\")\nelse\n    println(\"A equação não possui raízes reais.\")\nend\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAs raízes são: x1 = 3.0 e x2 = 2.0\n```\n:::\n:::\n\n\n",
    "supporting": [
      "02-calculadora-repl_files"
    ],
    "filters": [],
    "includes": {}
  }
}