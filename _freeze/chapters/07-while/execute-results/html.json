{
  "hash": "9bb481c61c5805541b3bc0d7d05fb3b7",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n\n# Uma outra forma de se fazer laços\n\nAté o momento vimos que o computador é muito bom para fazer contas \ne repetições. Fizemos isso até agora com funções recursivas. Mas, existe\num outro comando para isso, o while. A motivação é que enquanto alguma\ncondição for válida, o computador continua repetindo os comandos.\n\nO formato básico é o seguinte:\n\n``` \nwhile condição\n  # execute obloco\nend  \n```\n\nEnquanto a condição continuar verdadeira, o computador vai seguir repetindo o bloco\nque pode ser formado por várias intruções. Logo, para que a repetição, ou laço, não \nseja repetido indefinidamente, é essencial que algo ligado a condição seja atualizado \nno corpo do while.\n\nVejamos o exemplo simples da contagem regressiva:\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nn = 5\nwhile n > 0\n  println(n)\n  n = n - 1\nend\nprintln(\"Acabou\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n4\n3\n2\n1\nAcabou\n```\n:::\n:::\n\n\n\n\n\n\n\n\nMas, vamos ver abaixo um caso onde o uso de while deixa o código mais Claro \nque com a recursão (onde é ruim fazer uma com vários parãmetros). Veja a \nresolução da série de Taylor abaixo:\n\n\n\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n function sinTaylor2(x)\n   i = 1\n   termo = x\n   soma = 0.0\n   while i <= 15\n     soma = soma + termo\n     termo = -1 * termo * x * x / ((2 * i) * (2 * i + 1))\n     i = i + 1\n   end\n   return soma\nend\n\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsinTaylor2 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNela são calculados os 15 primeiros termos. \n\nObservem a versão recursiva:\n\n\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction sinTaylor(x)\n    return sinTaylorRec(1, 15, x, 1, x)\nend\n\nfunction sinTaylorRec(i, n, x, sinal, termo)\n    if n == i\n      return 0.0\n    else\n      return sinal * termo +\n         sinTaylorRec(i + 1, n, x, -1 * sinal, termo * x * x/ (2*i * (2*i+1)))\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsinTaylorRec (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\nPodemos também fazer operações com os dígitos de um número inteiro, para isso operações \ncomo o resto da divisão por 10 e a divisão inteira por 10 são bastante úteis. Abaixo \ntemos as duas versões que fazem a soma dos dígitos de um número inteiro.\n\n\n\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\nfunction testaSD()\n  @test sd(123) == 6\n  @test sd(321) == 6\n  @test sd(0) == 0\n  @test sd(1001) == 2\n  @test sd(3279) == 21\n  println(\"Fim dos testes\")\nend\n\nfunction sd(x)\n  if x == 0\n     return 0\n  else\n     d = x % 10\n     return d + sd(div(x, 10))\n  end\nend\n\nfunction sd1(x)\n  soma = 0\n  while x != 0\n   d = x % 10\n   soma = soma + d\n   x = div(x, 10)\n  end\n  return soma\nend\ntestaSD()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFim dos testes\n```\n:::\n:::\n\n\n",
    "supporting": [
      "07-while_files"
    ],
    "filters": [],
    "includes": {}
  }
}