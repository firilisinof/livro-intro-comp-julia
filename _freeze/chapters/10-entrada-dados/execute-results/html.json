{
  "hash": "bdfae29149e3a4ee81d56a86565a238d",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n\n# Entrada de dados e o começo de listas\nNessa aula, temos dois tópicos principais, como fazer a entrada de dados,\natravés de comandos de entrada e com argumentos na linha de comando. Além disso\ntambém veremos como tratar de um tipo especial de variável, onde é possível,\nguardar mais de um valor.\n\n## O comando input\nQuando queremos inserir dados, em Julia, basta colocar dados. Mas, como podemos\nfazer para entrar dados em um programa comum?\n\nPara isso temos o comando readline(), que interrompe a execução do programa e\nespera pela entrada de uma String, o que ocorre quando a tecla \"enter\" é\npressionada.\n\n\n\n\n\n\n::: {#2 .cell execution_count=0}\n``` {.julia .cell-code}\nprintln(\"Digite o seu nome\")\nresposta = readline()\nprintln(\"O seu nome é: \", resposta)\n```\n:::\n\n\n\n\n\n\n\n\nCaso, ao rodar o programa, você digitar `Maria`, e pressionar a tecla enter, a resposta final do seu programa será `O seu nome é: Maria`.\n\nComo o readline() lê Strings, se quisermos ler números, é\nnecessário usar o comando parse. O comando parse de forma simples \npossui dois parâmetros, o primeiro corresponde ao tipo que se quer \ntransformar, e o segundo o valor original.\n\n\n\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\nprintln(\"Digite um inteiro\")\nvalor = parse(Int64, readline())\nprintln(\"O numero digitado foi \", valor)\n```\n:::\n\n\n\n\n\n\n\n\n\nSabendo ler números do teclado, vamos a um exercício simples, ler uma\nsequência de números inteiros terminada por zero e devolver a sua soma.\n\n\n\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction somaVarios()\n    soma = 0.0\n    println(\"Digite um número\")\n    n = parse(Float64, readline())\n    while  n!=0\n        soma = soma + n\n        println(\"Digite um número\")\n        n = parse(Float64, readline())\n    end\n    println(\"A soma é: \", soma)\nend\n```\n:::\n\n\n\n\n\n\n\n\nObserve o seguinte exemplo que calcula os quadrados dos números de uma\nlista terminada por zero.\n\n\n\n\n\n\n::: {#8 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction leQ()\n  x = readline()\n  n = parse(Float64, x)\n  while n != 0\n    println(\"$n ao quadrado é \", n * n)\n    x = readline()\n    n = parse(Float64, x)\n  end\nend\n```\n:::\n\n\n\n\n\n\n\n\nNotem que o readline também pode receber uma variável de arquivo para\nque dados sejam lidos diretamente. Mas, nesse caso temos que tomar Ocuidado para\nabrir (open()) e fechar (close()) o arquivo. Como abaixo:\n\n\n\n\n\n\n::: {#10 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction leQ()\n    println(\"Digite um número\")\n    f = open(\"numeros.txt\", \"r+\")\n    x = readline(f)\n    n = parse(Float64, x)\n    while n != 0\n        println(\"$n ao quadrado é \", n * n)\n        println(\"Digite outro número\")\n        x = readline(f)\n        n = parse(Float64, x)\n    end\n    close(f)\nend\n```\n:::\n\n\n\n\n\n\n\n\n## Lendo através da linha de comando\n\nA outra forma de ler comandos é através da constante ARGS que é\npreparada na chamada de um programa. Para entender melhor isso, vamos\nver o seguinte programa.\n\n\n\n\n\n\n::: {#12 .cell execution_count=0}\n``` {.julia .cell-code}\nprintln(ARGS)\n```\n:::\n\n\n\n\n\n\n\n\nSe a linha acima está no arquivo args.jl, ao chamar julia args.jl com diversos\nparâmetros, teremos diversos resultados diferentes.\n\nPor exemplo ao chamar:\n\njulia args.jl 1 2 3 abc\n\nTeremos como resposta\n\n\n\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\n[\"1\", \"2\", \"3\", \"abc\"]\n```\n:::\n\n\n\n\n\n\n\n\nVamos analisar um pouco melhor essa resposta observando que cada\nparâmetro está em uma posição.\n\n\n\n\n\n\n::: {#16 .cell execution_count=0}\n``` {.julia .cell-code}\ntam = length(ARGS)\nprintln(\"O tamanho dos argumentos é: \", tam)\nfor i in 1:tam\n    println(ARGS[i])\nend\n```\n:::\n\n\n\n\n\n\n\n\n Olhando o código acima, podemos ver que a função length() devolve\no número de argumentos, ou seja, o tamanho da lista ARGS. Além disso\ncom os colchetes é possível acessar a cada posição da lista de forma\nindividual.\n\n\nO exemplo abaixo  soma os parâmetros inteiros dados como argumentos. Ele\ntambém ilustra uma boa prática que é, sempre colocar o código em módulos,\nno caso abaixo em funções:\n\n\n\n\n\n\n::: {#18 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction SomaEntrada()\n    tam = length(ARGS)\n    s = 0\n    i = 1\n    while i <= tam\n        valor = parse(Int, ARGS[i])\n        println(valor)\n        s = s + valor\n        i = i + 1\n    end\n    println(\"A soma foi: \", s)\nend\nSomaEntrada()\n```\n:::\n\n\n\n\n\n\n\n\nA flexibilidade que temos ao usar listas é enorme! Por isso,\nlistas ou vetores, merecem um tópico próprio.\n\n## Listas\n\nVamos primeiro brincar um pouco no console.\n\n\n\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\nvetor = [1, 2, 3]\nprintln(vetor[1])\nprintln(length(vetor))\nvetor[2] = vetor[2] + 1\nvetor[1] = 2 * vetor[3]\nprintln(vetor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n3\n[6, 3, 3]\n```\n:::\n:::\n\n\n\n\n\n\n\n\nComo disse antes, o for foi feito para manipular vetores,\nvamos ver umas funções, a primeira que imprime os elementos de um vetor\num por linha.\n\n\n\n\n\n\n::: {#22 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction imprimeVetor(v)\n    for el in v\n        println(el)\n    end\nend\n```\n:::\n\n\n\n\n\n\n\n\nIsso também pode ser feito por meio dos índices do vetor:\n\n\n\n\n\n\n::: {#24 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction imprimeVetor(v)\n    for i in 1:lenght(v)\n        println(v[i])\n    end\nend\n```\n:::\n\n\n\n\n\n\n\n\nComo cada posição é independente, podemos calcular a soma dos\nelementos ímpares de um vetor\n\n\n\n\n\n\n::: {#26 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction somaImpVetor(v)\n    soma = 0\n    for i in 1:length(v)\n        if v[i] % 2 == 1\n            soma = soma + v[i]\n        end\n    end\n    return soma\nend\n```\n:::\n\n\n\n\n\n\n\n\nTambém vimos em aula alguns outros exemplos, como calcular a média dos\nelementos em um vetor.\n\n\n\n\n\n\n::: {#28 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction mediaV(v)\n   soma = 0.0\n   for i in v\n      soma = soma + i\n   end\n   return soma / length(v)\nend\n```\n:::\n\n\n\n\n\n\n\n\nDevolver a soma dos elementos ímpares de um vetor\n\n\n\n\n\n\n::: {#30 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction somaImpar(v)\n    soma = 0\n    for i in v\n        if i % 2 == 1\n            soma = soma + i\n        end\n    end\n    return soma\nend\n```\n:::\n\n\n\n\n\n\n\n\nImprimir os números divisíveis por 5 de um vetor.\n\n\n\n\n\n\n::: {#32 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction imprimeDivisivelPor5(v)\n    for i in v\n        if i % 5 == 0\n            println(i)\n        end\n    end\nend\n```\n:::\n\n\n\n\n\n\n\n\nCom uma pequena variação e usando o comando push!() podemos ver como devolver\num vetor com os números divisíveis por 5.\n\n\n\n\n\n\n::: {#34 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction devolveDivisivelPor5(v)\n    x = []  # começa com um vetor vazio\n    for i in v\n        if i % 5 == 0\n            push!(x, i)  # adiciona um elemento ao vetor x\n        end\n    end\n    return x\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n### Álgebra linear e Listas\n\nA manipulação de listas é uma parte fundamental da álgebra linear, que estuda vetores e matrizes. Funções como o produto escalar de dois vetores são exemplos clássicos. Abaixo temos dois exemplos de produto escalar de dois vetores. lembrado esse é definido\ncomo a soma dos produtos de elementos em posições iguais.\n\n\n\n\n\n\n::: {#36 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction dotProduct(a, b)\n    soma = 0\n    if length(a) != length(b)\n       return soma   # o produto não está definido se os tamanhos são diferentes\n    end\n    for i in 1:length(a)\n        soma = soma + a[i] * b[i]\n    end\n    return soma\nend\n```\n:::\n\n\n\n\n\n\n\n\nAcima vimos que um caso especial do uso do for, consiste em fazer Ofor varias entre \n1 e um tamanho (1:lenght(a))\n\nObservem a diferença na versão abaixo:\n\n\n\n\n\n\n\n::: {#38 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction dotProduct(a, b)\n    soma = 0\n    if length(a) != length(b)\n       return soma   # o produto não está definido se os tamanhos são diferentes\n    end   \n    i = 1\n    for x in a\n        soma = soma + x * b[i]\n        i = i + 1\n    end \n    return soma\nend\n```\n:::\n\n\n\n\n\n\n\n\n### Exercício de permutação\n\nPara terminar, vamos fazer uma função onde dado um vetor de inteiros\nde tamanho $n$, verifica se esse vetor é uma permutação dos números de\n1 a $n$. Para isso, veremos se cada número de 1 a $n$ está no vetor.\n\nMas, sem esquecer dos testes:\n\n\n\n\n\n\n::: {#40 .cell execution_count=0}\n``` {.julia .cell-code}\n@testset \"Verifica Permutação\" begin\n    @test permuta([1,2,3])\n    @test permuta([3, 2, 1])\n    @test permuta([1])\n    @test permuta([2, 1])\n    @test permuta([4, 2, 3, 1])\n    @test !permuta([1, 1])\n    @test !permuta([1, 3])\n    @test permuta([])\nend\n```\n:::\n\n\n\n\n\n\n\n\ne o código:\n\n\n\n\n\n\n::: {#42 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction permuta(v)\n   tam = length(v)\n   for i in 1:tam\n      if  !(i in v)\n         return false\n      end\n   end\n   return true\nend\n```\n:::\n\n\n\n\n\n\n\n\nFoi usado o comando in de Julia que verifica se um elemento está no vetor.\n\n",
    "supporting": [
      "10-entrada-dados_files"
    ],
    "filters": [],
    "includes": {}
  }
}