{
  "hash": "e7828cfe3d922ec589aed0ec21580a57",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n# Testes automatizados e um pouco mais de código\n\nVamos começar o capítulo vendo uma forma mais simples de se rodar testes. Nos testes\nque vimos até agora sempre havia o teste de uma condição booleana associado a uma\nmensagem de erro quando não funcionasse. Mas, observando que a mensagem de erro geralmente\nestá ligada à condição, por vezes a condição pode ser auto-explicativa.\n\nLogo, uma forma elegante de expressar as condições pode ser útil na escrita dos testes.\nPara isso, vamos usar o módulo de testes. Em linguagens modernas, várias das situações\nrepetitivas que enfrentamos podem ser evitadas usando alguma técnica mais moderna.\n\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nusing Test  \n@testset \"Modelo de testes\" begin\n    @test 2 == 1 + 1\n    @test true\n    @test !false\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest Summary:    | Pass  Total  Time\nModelo de testes |    3      3  0.1s\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nTest.DefaultTestSet(\"Modelo de testes\", Any[], 3, false, false, true, 1.741131048930295e9, 1.741131049021716e9, false, \"/Users/lucas/Desktop/livro-intro-comp-julia/chapters/06-testes-automatizados.qmd\")\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNo trecho acima primeiro indicamos que queremos fazer testes. Em\nseguida usamos o *test* que espera uma condição ou valor\nbooleano. Finalmente todos os testes são reunidos em um *testset*.\n\nClaro que o teste dá infomações relevantes quando falha:\n\n\n\n\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\nusing Test\n@test 2 + 2 != 4\n```\n:::\n\n\n\n\n\n\n\n\n```\nTest Failed at REPL[2]:1\n  Expression: 2 + 2 != 4\n   Evaluated: 4 != 4\n```\n\nAgora sim, vamos pensar em problemas algoritmicos novos. Que tal fazer a soma\ndos dígitos de um número inteiro. Ou seja, pensar em um número dígito à dígito.\nVamos aos testes primeiro:\n\n\n\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\nusing Test\n@testset \"Teste da Soma de Dígitos\" begin\n    @test somaDig(0) == 0\n    @test somaDig(1) == 1\n    @test somaDig(100) == 1\n    @test somaDig(123) == 6\n    @test somaDig(321) == 6\n    @test somaDig(99) == 18\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\nVamos agora tentar pensar em como \"descascar\" um número, dado o número 123, uma\nforma seria pegar o resto por 10 (ou seja 3) e depois dividir por 10 (ou seja 12),\ne assim por diante. Ou seja.\n\n\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction somaDig(n)\n    if n <=0 return 0\n    else\n        return n % 10 + somaDig(n ÷ 10)\n    end\nend\n\nprintln(somaDig(1234))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n```\n:::\n:::\n\n\n\n\n\n\n\n\nVamos agora a um outro problema clássico, a verificação se um número é ou não é primo.\nNa prática para fazer isso, temos a definição, um número $n$ é primo apenas se for\ndivisível apenas por 1 e por ele mesmo. Ou seja, nenhum número entre 2 e $n - 1$ pode\nser divisor de um número primo.\n\nA forma de se fazer isso é relativamente simples. Vamos pensar em uma função que tenta\ndividir um número recursivamente, se conseguir devolve falso, se não conseguir devolve\nverdadeiro.\n\nVamos aos código:\n\n\n\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction divide(n, i)\n    if n % i == 0\n        return false\n    elseif i == n - 1\n        return true\n    else\n        return divide(n, i + 1)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ndivide (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\nQue pode ser chamada por:\n\n\n\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction éPrimo(n)\n    return divide(n, 2)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\néPrimo (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\nMais um exemplo, o método de Newton para o cálculo de raiz quadrada. Para achar\na raiz de $x$, a partir de um chute inicial (por exemplos $y= x /2$), chegamos a um\nnovo chute que é a média de $y$ e $x/y$.\n\nMas, sim, vamos começar com os testes. Como estamos usando números do tipo *double* é bom\nsempre ter uma tolerância, por isso vamos usar uma comparação aproximada. Também poderiamos ter\nusado a função *isapprox* da linguagem Julia.\n\n\n\n\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\nusing Test\nfunction quaseIgual(a, b)\n    if abs(a - b) <= 1e-10\n        return true\n    else\n        return false\n    end\nend\n\n\n@testset \"Teste da raiz pelo método de Newton\" begin\n    @test quaseIgual(3.0, raiz(3.0 * 3.0))\n    @test quaseIgual(33.7, raiz(33.7 * 33.7))\n    @test quaseIgual(223.7, raiz(223.7 * 223.7))\n    @test quaseIgual(0.7, raiz(0.7 * 0.7))\n    @test quaseIgual(1.0, raiz(1.0 * 1.0))\nend\n```\n:::\n\n\n\n\n\n\n\n\nNote que como estamos comparando números em ponto flutuante, não usamos a\ncomparação exata.\n\nA solução final é:\n\n\n\n\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction newton(c, n)\n    q = n / c\n    if quaseIgual(q, c)\n        return q\n    else\n        return newton( (c + q) / 2.0, n)\n    end\nend\n\n\nfunction raiz(n)\n    a =  newton(n / 2.0, n)\n    println(\"a raiz de \", n, \" é \", a)\n    return a\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nraiz (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n## Funções caóticas\n\nVamos brincar um pouco agora com funções caóticas :), isso é, funções, que\nconforme o comportamento de uma constante $k$, apresentam resultados que podem\nconvergir ou não. Isso é, a cada passo, quero saber o valor do próximo ponto\naplicando a função novamente, isso é:\n$$x_1 = f(x_0), x_2 = f(x_1), \\ldots, x_n  = f(x_{n - 1})$$\n\nAs funções caóticas desempenham um papel significativo em diversas áreas da matemática e da física, com aplicações que vão desde a modelagem de crescimento populacional até a previsão de padrões climáticos. Elas também são fundamentais na análise de circuitos elétricos não lineares, onde pequenas variações nas condições iniciais podem levar a resultados drasticamente diferentes.\n\nPara o nosso teste, a função $f$ é extremamente simples: $x_{i + 1}=x_i * (1 -  x_i) * k$.\n\nImplemente a função e imprima os 30 primeiros resultados.\nComece com um valor de $x$ entre 0 e 1, como 0.2. Use constantes $k = 2.1, 2.5, 2.8$ e $3.1$\no que ocorre com $k = 3.7$?\n\nEntregue o código e um pequeno relatório sobre o que acontece.\n\n",
    "supporting": [
      "06-testes-automatizados_files"
    ],
    "filters": [],
    "includes": {}
  }
}