{
  "hash": "e5017b1ccf96776e1f0e9d1308a7d961",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n\n# Continuando a modelagem\n\nNo capítulo anterior ficamos com uma partida, mas sem a verificação do vencedor,\nou seja o jogador com o maior valor, menor ou igual a 21. Uma decisão de projeto\né dizer que no caso de empate, os jogadores, com os maiores valores ganham e\ndividem o prêmio.\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction partida()\n  cards = criaBaralho()\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = jogador1(cards)\n  jogadores[2] = jogador2(cards)\n  jogadores[3] = jogador3(cards)\n  jogadores[4] = jogador4(cards)\n  jogadores[5] = jogador5(cards)\n  jogadores[6] = jogador6(cards)\n  return jogadores\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npartida (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nLogo, a partida devolve a pontuação de cada jogador, para podermos verificar na\nrotina ganhador quem ganhou.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction ganhador(v)\n    i = 1\n    maximo = 0\n    while i <= length(v)\n        if v[i] > 21  # se estourou é como se tivesse o menor valor\n            v[i] = 0\n        end\n        if v[i] > maximo\n            maximo = v[i]  # encontra o vencedor\n        end\n        i = i + 1\n    end\n    result = zeros(Int64, length(v))\n    i = 1\n        while i <= length(v)\n            if v[i] == maximo\n                result[i] = 1\n            end\n            i = i + 1\n        end\n    return result\nend\n\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nganhador (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nA rotinha ganhador devolve um vetor com os vencedores, com 1 na posição de quem ganhou\ne zero na posição dos perdedores. \n\nUma das vantagens de se usar um computador é que podemos ter milhares de partidas de 21\npara encontrar qual seria a melhor estratégia.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction porcentagem()\n    i = 1\n    porc = zeros(Int64, 6)\n    while i < 100000\n        porc = porc + ganhador(partida())\n        i = i + 1\n    end\n    println(porc)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nporcentagem (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAo simularmos o jogo 10000 vezes, podemos encontrar qual é a melhor estratégia\ndentre as que foram apresentadas.\n\nO código acima ficou relativamente grande, e uma das coisas que podemos notar é que\nhá muita duplicação nos códigos dos Jogadores a partir do segundo. Um dos maiores\nproblemas de código é a duplicação. No caso acima, podemos evitá-la adicionando\num parâmetro à função Jogador, de forma que esse seja o limite a ser considerado no\nlaço. A função jogador2 fica assim:\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction jogador2(cards, valor)\n    cartas = []\n    push!(cartas, pegarCarta(cards))\n    push!(cartas, pegarCarta(cards))\n    while somaCartas(cartas) < valor\n       push!(cartas, pegarCarta(cards))\n    end\n    return somaCartas(cartas)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\njogador2 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nComo a função tem um parâmetro novo, temos que acertar a partida. Mas,\nagora podemos usar todos os valores.\n\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction partida()\n   cards = criaBaralho()\n   jogadores = zeros(Int8, 6)\n   jogadores[1] = jogador1(cards)\n   jogadores[2] = jogador2(cards, 21)\n   jogadores[3] = jogador2(cards, 20)\n   jogadores[4] = jogador2(cards, 19)\n   jogadores[5] = jogador2(cards, 18)\n   jogadores[6] = jogador2(cards, 17)\n   return jogadores\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npartida (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNotem que não há mudança na função ganhador, que continua funcionando.\n\nPara terminar, podemos ter agora uma versão interativa que permite que\num jogador humano jogue com o computador.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction partidaComHumano()\n    cards = criaBaralho()\n    humano = []\n    computador = jogador2(cards, 19)\n    push!(humano, pegarCarta(cards))\n    push!(humano, pegarCarta(cards))\n    println(\"O humano tem \", humano, \" e soma \", somaCartas(humano))\n    println(\"O humano quer mais cartas (S/N)?\")\n    resp = readline()\n    while resp == \"S\" || resp == \"s\"\n         push!(humano, pegarCarta(cards))\n         println(\"O computador tem \", computador, \" e soma \", somaCartas(computador))\n         println(\"O humano tem \", humano, \" e soma \", somaCartas(humano))\n         println(\"O humano quer mais cartas (S/N)?\")\n         resp = readline()\n    end\n    println(\"O computador tem \", computador, \" e soma \", somaCartas(computador))\n    if somaCartas(computador) <= 21 && somaCartas(humano) <= 21\n         if somaCartas(computador) > somaCartas(humano)\n             println(\"Humano Perdeu\")\n         elseif somaCartas(computador) == somaCartas(humano)\n             println(\"Empate\")\n         else\n             println(\"Humano ganhou\")\n         end\n    elseif somaCartas(computador) > 21 && somaCartas(humano) > 21\n         println(\"os dois perderam\")\n    elseif somaCartas(computador) > 21\n         println(\"Humano ganhou\")\n    else\n         println(\"Computador ganhou\")\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npartidaComHumano (generic function with 1 method)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "13-blackjack-cont_files/figure-pdf"
    ],
    "filters": []
  }
}