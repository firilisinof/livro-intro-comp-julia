{
  "hash": "75d6bac68a8c8557c0edf492ad7f34db",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n\n# Mais algoritmos e introdução aos testes\n\nNessa aula,  vamos ver  algoritmos um  pouco mais  elaborados. Mas,  sabendo que\nvamos usar algo com um maior grau de sofisticação, que tal pensar em testes?\n\nDe  uma forma  geral, para  verificar o  funcionamento de  um programa,  podemos\nescrever testes que verificam o  funcionamento em algumas situações específicas.\n\nDado que o primeiro problema que queremos resolver é um algoritmo que encontra o\nn-ésimo número de Fibonacci. Por que não começar com testes?\n\nUma forma de se fazr testes, e de forma manual, mas isso não é reprodutível. A\nmelhor maneira de se fazer testes, é de forma automatizada, ou seja criar código\nque teste código. Isso pode parecer complicado, mas vamos ver abaixo que não é.\n\nEm uma  busca rápida,  podemos ver que  a sequência de  Fibonacci é  definida da\nseguinte forma,  os dois primeiros elementos  $F_1$ e $F_2$ valem  1, em seguida\ntemos a fórmula  $F_n = F_{n-1} +  F_{n-2}$. Mas, antes de pensar  em resolver o\nproblema vamos pensar em como testar.\n\nJá  sabemos os  primeiros  valores, além  disso, através  de  uma busca  rápida,\npodemos  descobrir alguns  valores  da sequência  como  $F_5 =  5$  e $F_{12}  =\n144$. Supondo que a função para o cálculo do n-ésimo número de Fibonacci chamará\nfibo(). Podemos escrever o seguinte trecho de código:\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction testafibo_versao1()\n    if fibo(1) == 1\n        println(\"Deu certo para 1\")\n    end\n    if fibo(2) == 1\n        println(\"Deu certo para 2\")\n    end\n    if fibo(5) == 5\n        println(\"Deu certo para 5\")\n    end\n    if fibo(12) == 144\n        println(\"Deu certo para 12\")\n    end\n    println(\"Final dos testes\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestafibo_versao1 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nA função de testes acima verifica se a função fibo() devolve o resultado correto\npara três casos. Mas, ela tem um defeito, ela imprime mensagens demais, o que\npode ser ruim. Considerando isso, vamos ver o primeiro fundamento importante com\nrelação a testes automatizados.\n\n*Se o teste passou, ele deve indicar apenas que deu certo!*\n\nLevando em conta o que foi escrito acima, podemos mudar o nosso teste para:\n\n\n\n\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction testafibo()\n    if fibo(1) != 1\n        println(\"Não deu certo para 1\")\n    end\n    if fibo(2) != 1\n        println(\"Não deu certo para 2\")\n    end\n    if fibo(5) != 5\n        println(\"Não eu certo para 5\")\n    end\n    if fibo(12) != 144\n        println(\"Não deu certo para 12\")\n    end\n    println(\"Final dos testes\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestafibo (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAgora de posse da nossa função de testes, podemos pensar em escrever a nossa função de Fibonacci.\nVamos ao caso fácil de n for menor que 2, a resposta é 1. Como vemos abaixo:\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction fibo(n)\n    if n <= 2\n        return 1\n    else\n        # ainda não sabemos o que colocar aqui...\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nfibo (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nMas, a resposta está na própria definição da função, ou seja:  $F_n = F_{n-1} +  F_{n-2}$.\nSe o $n$ for maior do que 2, temos que fazer a soma dos valores de Fibonacci de $n-1$ e de\n$n-2$. Ou seja:\n\n\n\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction fibo(n)\n    if n <= 2\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nend\n\nfibo(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n55\n```\n:::\n:::\n\n\n\n\n\n\n\n\nÉ interessante notar que apesar de ser um dos exemplos clássicos de uso de\nrecursão, o algoritmo acima é extremamente ineficiente. A razão é simples, cada\nvez que é feita a chamada, toda os valores de Fibonacci são recalculados para os\nvalores de $n$ e $n-1$.\n\nComo Julia é uma linguagem moderna podemos usar o conceito de Memoização, que evita calcular o que já foi calculado. O Memoize tem que ser instalado no Julia com\nos comandos `import Pkg` e  `Pkg.add(\"Memoize\")`.\n\n\n\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nusing Memoize\n@memoize function fibo(n)\n    if n <= 2\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nend\n\nfibo(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n55\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\nAs diferenças de tempo das duas versões podem ser verificada com o comando @time.\nDa seguinte forma:\n\n\n\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n@time fibo(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.000001 seconds\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n55\n```\n:::\n:::\n\n\n\n\n\n\n\n\nEsse tipo de comando, que começa com @ é conhecido como anotação, e tem o poder de\nmudar o comportamente de partes do código.\n\nVamos ao segundo algoritmo da aula, o MDC (Máximo Divisor Comum). A ideia é usar o\nalgoritmo de Euclides.\n\n\nBasicamente ele diz que o MDC de dois números a e b, é igual ao MDC de b e r,\nonde $r=a\\% b$. Quando esse resto for zero, chegamos a solução, que é b.\n\nVamos começar com os testes para alguns valores bem conhecidos. Por sinal começar\npelos testes antes de escrever o código é uma boa prática de programação conhecida por\nTDD (Test Driven Design).\n\n\n\n\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction testaMDC()\n    if MDC(3298, 2031) != 1\n        println(\"deu erro, para 3298 e 2031\")\n    end\n    if MDC(120, 36) != 12\n        println(\"deu erro, para 120 e 36\")\n    end\n    if MDC(36, 120) != 12\n        println(\"deu erro, para 36 e 120\")\n    end\n    println(\"Acabaram os testes\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestaMDC (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\nVamos pensar na função agora. Dessa vez, se o resto for 0, temos que devolver o segundo termo.\nCaso contrário temos que continuar com a regra\n\n\n\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction MDC(a, b)\n    r = a % b\n    if r == 0\n        return b\n    else\n        return MDC(b, r)\n    end\nend\n\ntestaMDC()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAcabaram os testes\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nAté agora usamos o modo interativo do Julia para fazer os nosso códigos. Mas, existe oura forma bem mais\nreutilizável, ou seja escrever o texto em arqivos. Isso é relativamente simples, basta usar um editor de texto\n(puro) da sua preferência, como o notepad, nano, juno, atom, vscode ou outro e salvar um\narquivo com a extensão .jl.\n\nMas, para que algo seja executado é importante colocar uma chamada ao final. Veja abaixo\num possível arquivo mdc.jl.\n\n\n\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction testeMDC()\n    if mdc(70, 5) != 5\n        println(\"Não funcionou para 70 e 5\")\n    end\n    if mdc(13, 7) != 1\n        println(\"Não funcionou para 13 e 7\")\n    end\n    if mdc(127, 15) != 1\n        println(\"Não funcionou para 127 e 15\")\n    end\n    if mdc(20, 15) != 5\n        println(\"Não funcionou para 20 e 15\")\n    end\n    if mdc(42, 3) != 3\n        println(\"Não funcionou para 42 e 3\")\n    end\n    if mdc(42, 8) != 2\n        println(\"Não funcionou para 42 e 8\")\n    end\n    println(\"Final dos testes\")\nend\n\nfunction mdc(a, b)\n    r = a % b\n    if r == 0\n        return b\n    else\n        mdc(b, r)\n    end\nend\n\ntesteMDC()\nprintln(\"O mdc entre 1227 e 321 é \", mdc(1227, 321))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFinal dos testes\nO mdc entre 1227 e 321 é 3\n```\n:::\n:::\n\n\n",
    "supporting": [
      "05-algoritmos-testes_files"
    ],
    "filters": [],
    "includes": {}
  }
}