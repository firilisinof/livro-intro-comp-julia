{
  "hash": "344f2e3ace8d8ddd6def725f29eb15af",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n\n# Modelando um problema maior\n\nNessa aula vamos modelar um jogo bem conhecido, o 21, ou BlackJack. Nele os jogadores\ndevem tentar chegar mais perto da soma de cartas 21, sem estourar. Quem chegar mais perto\nganha.\n\nCada jogador começa com duas cartas, sendo que as cartas tem o seu valor nominal, as\nfiguras (J, Q, K), que valem 10. Além disso, o Ás, pode valer 1 ou 11. O que for mais\nvantajoso para o jogador.\n\nPara começar vamos fazer uma simulação com um baralho, ou seja 52 cartas. Já que]\npara o jogo, não importa o naipe da carta, vamos supor que existem quatro cartas\nde cada. Para isso, vamos criar duas funções, uma que cria um baralho e o guarda\nem um vetor, e uma segunda que pega uma carta do baralho. Nessa segunda função temos\nque \"retirar\" a carta do vetor. Caso já não exista a carta do tipo desejado, temos\nque sortear uma nova carta.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction criaBaralho()\n  cards = zeros(Int8, 13)\n  i = 1\n  while i < 14\n    cards[i] = 4\n    i += 1\n  end\n  return cards\nend\n\nfunction pegarCarta(cards)\n  sorteio = rand(1:13)\n  while cards[sorteio] == 0\n    sorteio = rand(1:13)\n  end\n  cards[sorteio] -= 1\n  if sorteio > 10  # se a carta for figura, ela vale 10\n    sorteio = 10\n  end  \n  return sorteio\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npegarCarta (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\nDe posse dessas duas funções, podemos criar outras que simulam o comportamento dos\njogadores. Vamos usar algumas estratégias simples, como o jogador que fica com as\nduas cartas que recebeu.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction jogador1(cards)\n  carta1 = pegarCarta(cards)\n  carta2 = pegarCarta(cards)\n  if carta1 == 1 || carta2 == 1\n    return carta1 + carta2 + 10\n  else\n    return carta1 + carta2\n  end  \nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\njogador1 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNotem que acima, usamos a estratégia de usar o Ás da forma mais vantajosa.\n\nPara os outros jogadores, vamos usar estratégias mais elaboradas, ou seja o \njogador fica pegando cartas enquanto não chegar a um valor pré-determinado, como\npor exemplo 21, 19, 17, 15 e 13.\n\nComo cada jogador pode ter um número grande de cartas e no caso dele ter um \nÁs, a conta tem que ser feita da maneira mais vantajosa, vamos usar uma função\nque recebe um vetor de cartas e calcula a soma.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction somaCartas(c)\n  soma = 0\n  temAz = false\n  for i in c\n    soma += i\n    if c == 1 \n      temAz = true\n    end\n  end\n  if soma <= 11 && temAz\n      return soma + 10\n  else \n      return soma\n  end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsomaCartas (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nDe posse do soma cartas, podemos modelar os jogadores.\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction jogador2(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) < 21\n    push!(cartas, pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\nfunction jogador3(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) < 19\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\nfunction jogador4(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) < 17\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\n  function jogador5(cards)\n    cartas = []\n    push!(cartas, pegarCarta(cards))\n    push!(cartas, pegarCarta(cards))\n    while somaCartas(cartas) < 15\n      push!(cartas,pegarCarta(cards))\n    end\n    return somaCartas(cartas)\n  end\n\nfunction jogador6(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) < 13\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\njogador6 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAgora que temos todos os jogadores, podemos modelar uma partida.\nPara isso criamos um baralho e fazemos com que cada jogador siga \na sua estratégia\n\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction partida()\n  cards = criaBaralho()\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = jogador1(cards)\n  jogadores[2] = jogador2(cards)\n  jogadores[3] = jogador3(cards)\n  jogadores[4] = jogador4(cards)\n  jogadores[5] = jogador5(cards)\n  jogadores[6] = jogador6(cards)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npartida (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNão deu tempo de continuar, ficou para a próxima aula.\n\n",
    "supporting": [
      "12-blackjack_files/figure-pdf"
    ],
    "filters": []
  }
}