{
  "hash": "8297b48218fa06781c18191aa3c7864c",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n\n\n\n# Continuando a modelagem\n\n\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction jogador1(cards)\n  carta1 = pegarCarta(cards)\n  carta2 = pegarCarta(cards)\n  if carta1 == 1 || carta2 == 1\n    return carta1 + carta2 + 10\n  else\n    return carta1 + carta2\n  end  \nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\njogador1 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nNotem que acima, usamos a estratégia de usar o Ás da forma mais vantajosa.\n\nPara os outros jogadores, vamos usar estratégias mais elaboradas, ou seja o \njogador fica pegando cartas enquanto não chegar a um valor pré-determinado, como\npor exemplo 21, 19, 17, 15 e 13.\n\nComo cada jogador pode ter um número grande de cartas e no caso dele ter um \nÁs, a conta tem que ser feita da maneira mais vantajosa, vamos usar uma função\nque recebe um vetor de cartas e calcula a soma.\n\n\n\n\n\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction somaCartas(c)\n  soma = 0\n  temAz = false\n  for i in c\n    soma += i\n    if c == 1 \n      temAz = true\n    end\n  end\n  if soma <= 11 && temAz\n      return soma + 10\n  else \n      return soma\n  end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsomaCartas (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nDe posse do soma cartas, podemos modelar os jogadores.\n\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction jogador2(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) < 21\n    push!(cartas, pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\nfunction jogador3(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) < 19\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\nfunction jogador4(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) < 17\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\n  function jogador5(cards)\n    cartas = []\n    push!(cartas, pegarCarta(cards))\n    push!(cartas, pegarCarta(cards))\n    while somaCartas(cartas) < 15\n      push!(cartas,pegarCarta(cards))\n    end\n    return somaCartas(cartas)\n  end\n\nfunction jogador6(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) < 13\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\njogador6 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nAgora que temos todos os jogadores, podemos modelar uma partida.\nPara isso criamos um baralho e fazemos com que cada jogador siga \na sua estratégia\n\n\n\n\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction partida()\n  cards = criaBaralho()\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = jogador1(cards)\n  jogadores[2] = jogador2(cards)\n  jogadores[3] = jogador3(cards)\n  jogadores[4] = jogador4(cards)\n  jogadores[5] = jogador5(cards)\n  jogadores[6] = jogador6(cards)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npartida (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nNão deu tempo de continuar, ficou para a próxima aula.\n\nNo capítulo anterior ficamos com uma partida, mas sem a verificação do vencedor,\nou seja o jogador com o maior valor, menor ou igual a 21. Uma decisão de projeto\né dizer que no caso de empate, os jogadores, com os maiores valores ganham e\ndividem o prêmio.\n\n\n\n\n\n\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction partida()\n  cards = criaBaralho()\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = jogador1(cards)\n  jogadores[2] = jogador2(cards)\n  jogadores[3] = jogador3(cards)\n  jogadores[4] = jogador4(cards)\n  jogadores[5] = jogador5(cards)\n  jogadores[6] = jogador6(cards)\n  return jogadores\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npartida (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nLogo, a partida devolve a pontuação de cada jogador, para podermos verificar na\nrotina ganhador quem ganhou.\n\n\n\n\n\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction ganhador(v)\n    i = 1\n    maximo = 0\n    while i <= length(v)\n        if v[i] > 21  # se estourou é como se tivesse o menor valor\n            v[i] = 0\n        end\n        if v[i] > maximo\n            maximo = v[i]  # encontra o vencedor\n        end\n        i = i + 1\n    end\n    result = zeros(Int64, length(v))\n    i = 1\n        while i <= length(v)\n            if v[i] == maximo\n                result[i] = 1\n            end\n            i = i + 1\n        end\n    return result\nend\n\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nganhador (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nA rotinha ganhador devolve um vetor com os vencedores, com 1 na posição de quem ganhou\ne zero na posição dos perdedores. \n\nUma das vantagens de se usar um computador é que podemos ter milhares de partidas de 21\npara encontrar qual seria a melhor estratégia.\n\n\n\n\n\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction porcentagem()\n    i = 1\n    porc = zeros(Int64, 6)\n    while i < 100000\n        porc = porc + ganhador(partida())\n        i = i + 1\n    end\n    println(porc)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nporcentagem (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nAo simularmos o jogo 10000 vezes, podemos encontrar qual é a melhor estratégia\ndentre as que foram apresentadas.\n\nO código acima ficou relativamente grande, e uma das coisas que podemos notar é que\nhá muita duplicação nos códigos dos Jogadores a partir do segundo. Um dos maiores\nproblemas de código é a duplicação. No caso acima, podemos evitá-la adicionando\num parâmetro à função Jogador, de forma que esse seja o limite a ser considerado no\nlaço. A função jogador2 fica assim:\n\n\n\n\n\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction jogador2(cards, valor)\n    cartas = []\n    push!(cartas, pegarCarta(cards))\n    push!(cartas, pegarCarta(cards))\n    while somaCartas(cartas) < valor\n       push!(cartas, pegarCarta(cards))\n    end\n    return somaCartas(cartas)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\njogador2 (generic function with 2 methods)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nComo a função tem um parâmetro novo, temos que acertar a partida. Mas,\nagora podemos usar todos os valores.\n\n\n\n\n\n\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction partida()\n   cards = criaBaralho()\n   jogadores = zeros(Int8, 6)\n   jogadores[1] = jogador1(cards)\n   jogadores[2] = jogador2(cards, 21)\n   jogadores[3] = jogador2(cards, 20)\n   jogadores[4] = jogador2(cards, 19)\n   jogadores[5] = jogador2(cards, 18)\n   jogadores[6] = jogador2(cards, 17)\n   return jogadores\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npartida (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nNotem que não há mudança na função ganhador, que continua funcionando.\n\nPara terminar, podemos ter agora uma versão interativa que permite que\num jogador humano jogue com o computador.\n\n\n\n\n\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction partidaComHumano()\n    cards = criaBaralho()\n    humano = []\n    computador = jogador2(cards, 19)\n    push!(humano, pegarCarta(cards))\n    push!(humano, pegarCarta(cards))\n    println(\"O humano tem \", humano, \" e soma \", somaCartas(humano))\n    println(\"O humano quer mais cartas (S/N)?\")\n    resp = readline()\n    while resp == \"S\" || resp == \"s\"\n         push!(humano, pegarCarta(cards))\n         println(\"O computador tem \", computador, \" e soma \", somaCartas(computador))\n         println(\"O humano tem \", humano, \" e soma \", somaCartas(humano))\n         println(\"O humano quer mais cartas (S/N)?\")\n         resp = readline()\n    end\n    println(\"O computador tem \", computador, \" e soma \", somaCartas(computador))\n    if somaCartas(computador) <= 21 && somaCartas(humano) <= 21\n         if somaCartas(computador) > somaCartas(humano)\n             println(\"Humano Perdeu\")\n         elseif somaCartas(computador) == somaCartas(humano)\n             println(\"Empate\")\n         else\n             println(\"Humano ganhou\")\n         end\n    elseif somaCartas(computador) > 21 && somaCartas(humano) > 21\n         println(\"os dois perderam\")\n    elseif somaCartas(computador) > 21\n         println(\"Humano ganhou\")\n    else\n         println(\"Computador ganhou\")\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npartidaComHumano (generic function with 1 method)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "13-blackjack-cont_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}