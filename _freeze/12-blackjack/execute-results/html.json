{
  "hash": "b74653067069385c6152cd6fd08fd32b",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n\n\n# Modelando Blackjack\n\nNeste capítulo, vamos criar uma versão simplificada de terminal do jogo Blackjack e avaliar diferentes estratégias de jogo. Blackjack, também conhecido como vinte-e-um (21), é um jogo de cartas jogado por duas pessoas em que o objetivo é ter mais pontos que o adversário, mas sem ultrapassar 21 (o caso em que se perde). O objetivo é desenvolver nossa capacidade de modelar problemas reais usando programação.\n\n## Versão Interativa do Jogo\n\nO primeiro passo, antes de pensar na implementação, é entender o que desejamos modelar. Blackjack é jogado por duas pessoas: o jogador e o _dealer_ (banca ou casino). No nosso jogo, o dealer será o computador. Além disso, vamos considerar as seguintes regras de jogo:\n\n1. Inicialmente, o jogador e o dealer recebem duas cartas.\n2. Durante o turno do jogador, o jogador pode escolher duas opções: pegar outra carta (_hit_) ou não pegar mais cartas (_sit_).\n3. Durante o turno do dealer, o dealer irá adotar a seguinte estratégia: pegar cartas enquanto o total for inferior a 17 ou parar caso contrário.\n\nO objetivo do jogador é chegar mais perto de 21 do que o dealer, mas sem ultrapassar esse valor.\n\nO valor de cada carta corresponde ao seu valor nominal. As cartas Dama (Q), Valete (J) e Rei (K) valem 10 pontos. O Ás pode valer 1 ou 11 (a depender da estratégia do jogador). Vamos considerar que um Ás é contado como 11, a menos que isso faça com que a mão ultrapasse 21 (estourar). Nesse caso, o Ás vale 1. Agora que sabemos as regras do jogo podemos implementá-lo.\n\nVamos começar criando um baralho de 52 cartas. Uma maneira simples de representá-lo é usando um vetor (vamos chamar de `baralho`) onde cada elemento representa um tipo de carta e armazena a quantidade disponível desse tipo, ou seja, se `baralho[i]` valer 4, significa que há 4 cartas do tipo `i` disponíveis no baralho.\n\nPara a representação numérica das cartas, o Ás corresponde ao 1, o Dois ao 2, e assim sucessivamente até o 10. A Dama é representada pelo 11, o Valete pelo 12 e o Rei pelo 13. Como o naipe não importa, vamos considerar que existem quatro cartas de cada tipo no baralho completo.\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction criaBaralho()\n\tbaralho = zeros(Int8, 13)\n\n\ti = 1\n\twhile i < 14\n\t\tbaralho[i] = 4\n\t\ti = i + 1\n\tend\n\n\treturn baralho\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ncriaBaralho (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAlém de criar o baralho, precisamos de uma função para pegar uma carta dele. Na vida real, o baralho estaria embaralhado com as cartas viradas para baixo, e para pegar uma carta bastaria puxar aquela no topo. O problema é que nossa modelagem não permite esse tipo de comportamento, já que o vetor apenas representa o número de cartas de um determinado tipo.\n\nPara simular esse comportamento, podemos sortear um número aleatório entre 1 e 13 e verificar se existem cartas daquele tipo. Se existirem, removemos uma carta do baralho e retornamos o número sorteado. Caso contrário, continuamos sorteando números até encontrarmos um tipo que ainda possua cartas disponíveis.\n\n\n\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction pegaCarta(baralho)\n\ti = rand(1:13)\n\n\t# Verifica se existem cartas do tipo sorteado\n\twhile baralho[i] == 0\n\t\ti = rand(1:13)\n\tend\n\n\tbaralho[i] = baralho[i] - 1\n\n\treturn i\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npegaCarta (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAgora que temos um baralho e podemos pegar cartas dele, precisamos de uma função para calcular o valor de uma mão. Para representar as mãos do jogador e do dealer, vamos utilizar um vetor que armazena os valores das cartas recebidas. As duas mãos serão definidas numa função futura.\n\n\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction calculaValorMao(mao)\n\tases = 0\n    valor = 0\n\ttamanhoMao = length(mao)\n\n\ti = 1\n\twhile i <= tamanhoMao\n\t\tif mao[i] == 1 # Ás\n\t\t\tases = ases + 1\n\t\t\tvalor = valor + 11\n\t\telseif mao[i] >= 11 # Dama, Valete ou Rei\n\t\t\tvalor = valor + 10\n\t\telse\n\t\t\tvalor = valor + mao[i]\n\t\tend\n\t\ti = i + 1\n\tend\n\n\t# Ajusta o valor dos Ases se necessário\n\twhile ases > 0 && valor > 21\n\t\tvalor = valor - 10\n\t\tases = ases - 1\n\tend\n\n\treturn valor\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ncalculaValorMao (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nEssa função percorre todas as cartas da mão e calcula o valor total. Primeiro, assumimos que todos os Ases valem 11. Se o valor total ultrapassar 21 e ainda houver Ases contados como 11, convertemos um Ás por vez de 11 para 1 até que o valor fique dentro do limite ou não haja mais Ases para converter.\n\nVamos criar funções auxiliares para exibir as cartas de forma mais amigável:\n\n\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction nomeCartaTexto(carta)\n    nomes = [\"Ás\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Dama\", \"Valete\", \"Rei\"]\n    return nomes[carta]\nend\n\nfunction exibeMao(mao, jogador)\n    print(\"$jogador possui as cartas: \")\n\ti = 1\n\ttamanhoMao = length(mao)\n    while i <= tamanhoMao\n        print(nomeCartaTexto(mao[i]), \" \")\n\t\ti = i + 1\n    end\n\tprintln()\n    println(\"Valor da mão: $(calculaValorMao(mao))\")\n    println()\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nexibeMao (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAgora podemos implementar a lógica principal do jogo de acordo com as regras definidas anteriormente.\n\n\n\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction jogarBlackjack()\n\tbaralho = criaBaralho()\n\tmaoJogador = Int[]\n\tmaoDealer = Int[]\n\n\tpush!(maoJogador, pegaCarta(baralho))\n\tpush!(maoDealer, pegaCarta(baralho))\n\tpush!(maoJogador, pegaCarta(baralho))\n\tpush!(maoDealer, pegaCarta(baralho))\n\n\tprintln(\"=== BLACKJACK ===\")\n    println()\n\n\tprintln(\"Dealer possui a carta: $(nomeCartaTexto(maoDealer[1]))\")\n\tprintln()\n\n\texibeMao(maoJogador, \"Você\")\n\n\tvalorJogador = calculaValorMao(maoJogador)\n\twhile valorJogador < 21\n\t\tprint(\"Deseja pedir mais uma carta? (s/n): \")\n\t\tresposta = readline()\n\n\t\tif resposta == \"s\" || resposta == \"S\"\n            novaCarta = pegaCarta(baralho)\n            push!(maoJogador, novaCarta)\n\t\t\tvalorJogador = calculaValorMao(maoJogador)\n            println(\"Você recebeu: $(nomeCartaTexto(novaCarta))\")\n            println()\n            exibeMao(maoJogador, \"Você\")\n        else\n            break\n        end\n\tend\n\n\tif valorJogador > 21\n        println(\"Você estourou! Perdeu o jogo.\")\n        return\n    end\n\n\tprintln(\"Vez do dealer...\")\n\tprintln()\n\n\texibeMao(maoDealer, \"Dealer\")\n\n\tvalorDealer = calculaValorMao(maoDealer)\n\twhile valorDealer < 17\n\t\tnovaCarta = pegaCarta(baralho)\n\t\tpush!(maoDealer, novaCarta)\n\t\tvalorDealer = calculaValorMao(maoDealer)\n\t\tprintln(\"Dealer recebeu: $(nomeCartaTexto(novaCarta))\")\n\t\tprintln()\n\t\texibeMao(maoDealer, \"Dealer\")\n\tend\n\n\tif valorDealer > 21\n\t\tprintln(\"Dealer estourou! Você ganhou!\")\n    elseif valorJogador > valorDealer\n        println(\"Você ganhou com $valorJogador pontos contra $valorDealer do dealer!\")\n    elseif valorDealer > valorJogador\n        println(\"Dealer ganhou com $valorDealer pontos contra seus $valorJogador pontos!\")\n    else\n        println(\"Empate! Ambos fizeram $valorJogador pontos.\")\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\njogarBlackjack (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nA função principal `jogarBlackjack()` coordena todo o fluxo do jogo. Primeiro, cria um baralho novo e inicializa as mãos vazias. Em seguida, distribui duas cartas para cada jogador e exibe o estado inicial, ocultando uma das cartas do dealer para simular o jogo real.\n\nDurante o turno do jogador, o programa pergunta se ele deseja mais cartas até que ele pare ou estoure (ultrapasse 21). No turno do dealer, as regras são automáticas: ele deve pedir cartas enquanto o valor total for menor que 17.\n\nPor fim, o programa compara os valores finais e determina o vencedor. Se ambos os jogadores estourarem, o dealer vence (regra padrão do Blackjack).\n\nPara testar nosso jogo, basta chamar a função principal:\n\n\n\n\n\n\n::: {#12 .cell execution_count=0}\n``` {.julia .cell-code}\njogarBlackjack()\n```\n:::\n\n\n\n\n\n\n\n\n## Avaliando Estratégias\n\nCom o código que desenvolvemos até aqui, já conseguimos jogar uma partida de Blackjack. Ótimo. Mas você saberia responder a pergunta: como definimos uma boa estratégia? Poderíamos jogar várias partidas para determinar qual a melhor estratégia, mas isso seria um tanto tedioso. É aqui que o computador nos oferece uma grande vantagem: a capacidade de simular milhares de jogos (e testar diferentes estratégias) para, em pouco tempo, identificar qual delas é a mais vantajosa.\n\nVamos definir diferentes estratégias através de funções que retornam o valor final da mão após aplicar a estratégia em questão. A primeira estratégia será mais conservadora. O jogador fica apenas com as duas primeiras cartas e não pega mais nenhuma.\n\n\n\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction estrategia1(baralho)\n  mao = Int[]\n  push!(mao, pegaCarta(baralho))\n  push!(mao, pegaCarta(baralho))\n  return calculaValorMao(mao)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nestrategia1 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara os outros jogadores, vamos usar estratégias mais agressivas, ou seja o jogador pega cartas enquanto não chegar a um valor pré-determinado, por exemplo, 21, 19, 17, 15 e 13.\n\n\n\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction estrategia2(baralho, valorMaximo)\n  mao = Int[]\n  push!(mao, pegaCarta(baralho))\n  push!(mao, pegaCarta(baralho))\n\n  while calculaValorMao(mao) < valorMaximo\n    push!(mao, pegaCarta(baralho))\n  end\n  return calculaValorMao(mao)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nestrategia2 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nAgora que temos as estratégias, podemos definir uma partida que aplica diferentes estratégias e devolve a pontuação de cada jogador. Isso será útil para encontrar o vencedor.\n\n\n\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction partida()\n  baralho = criaBaralho()\n\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = estrategia1(baralho)\n  jogadores[2] = estrategia2(baralho, 21)\n  jogadores[3] = estrategia2(baralho, 20)\n  jogadores[4] = estrategia2(baralho, 19)\n  jogadores[5] = estrategia2(baralho, 18)\n  jogadores[6] = estrategia2(baralho, 17)\n\n  return jogadores\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npartida (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nPara encontar o vencedor podemos comparar o valor de todos os jogadores, verificando quem estourou e quem chegou mais próximo de 21.\n\n\n\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction vencedor(jogadores)\n\ttotalJogadores = length(jogadores)\n\tresultado = zeros(Int8, totalJogadores)\n\n\tmaximo = 0\n\ti = 1\n\n\t# Descobre a maior pontuação\n\twhile i <= totalJogadores\n\t\tpontuacaoAtual = jogadores[i]\n\n\t\tif pontuacaoAtual > maximo\n\t\t\tmaximo = pontuacaoAtual\n\t\tend\n\n\t\ti = i + 1\n\tend\n\n\ti = 1\n\t\n\t# Marca os jogadores com a maior pontuação como vencedores\n\twhile i <= totalJogadores\n\t\tpontuacaoAtual = jogadores[i]\n\n\t\tif pontuacaoAtual == maximo\n\t\t\tresultado[i] = 1\n\t\tend\n\n\t\ti = i + 1\n\tend\n\n\treturn resultado\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nvencedor (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\n\nA função a `vencedor` devolve um vetor com os vencedores. Esse vetor possui todas as entradas iguais a zero (0), exceto a entrada do vencedor cuja o valor é um (1). Note que em caso de empate estamos considerando os jogadores empatados como vencedores.\n\nPor fim, podemos simular milhares de partidas e descobrir qual a melhor estratégia.\n\n\n\n\n\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction melhorEstrategia()\n\tnumeroPartidas = 100000\n\tcontagemResultados = zeros(Int64, 6)\n\n\ti = 1\n\twhile i <= numeroPartidas\n\t\tcontagemResultados = contagemResultados + vencedor(partida())\n\t\ti = i + 1\n\tend\n\n\tprintln(contagemResultados / numeroPartidas)\nend\n\nmelhorEstrategia()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.0007, 0.49745, 0.28778, 0.18828, 0.11845, 0.06836]\n```\n:::\n:::\n\n\n\n\n\n\n\n\nO resultado indica que uma estratégia completamente agressiva (pegar cartas enquanto não der 21) é a mais vencedora.\n\n",
    "supporting": [
      "12-blackjack_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}