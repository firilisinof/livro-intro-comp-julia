[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Uma Introdu√ß√£o √† Computa√ß√£o com Julia",
    "section": "",
    "text": "Bem-vindos",
    "crumbs": [
      "Bem-vindos"
    ]
  },
  {
    "objectID": "chapters/03.html",
    "href": "chapters/03.html",
    "title": "3¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "",
    "text": "3.1 Come√ßando com o modo interativo do Julia\nObjetivo: Ver o interpretador de Julia como uma calculadora poderosa, introduzir a no√ß√£o de vari√°veis.\nQuem quiser j√° pode instalar o ambiente de programa√ß√£o, usem esse link. H√° tamb√©m alguns ambientes que permitem o uso da linguagem no seu navegador, sugiro a busca pelas palavras chave Julia Language online.\nDentro do Julia (ap√≥s chamar julia na linha de comando), vamos come√ßar com contas com n√∫meros inteiros:\n1 + 2\n\n3\n40 * 4\n\n160\nSim, como era de se esperar, podemos em Julia usar os operandos: +, - e *, o resultado ser√° como o esperado. Vejamos a seguir que com a divis√£o fica um pouco diferente:\na = 84 \nb = 2\n\n# As vari√°veis a e b s√£o do tipo Int64\n\nresultado = a / b\nprintln(resultado)\n\n42.0\nNotem que nesse caso, houve uma mudan√ßa de tipos, pois 84 e 2 s√£o inteiros e o resultado √© um n√∫mero em ponto flutuante (float), podemos ver isso, pois ao inv√©s de 42, tivemos como resultado 42.0.\nTamb√©m √© poss√≠vel pedir o resultado inteiro usando o operador div:\ndiv(84,2)\n\n42\nOu de forma equivalente usando o operador \\div (para conseguir ver o s√≠mbolo da divis√£o √© necess√°rio digitar \\div seguido da tecla &lt;tab&gt;).\nAl√©m das contas b√°sicas, tamb√©m d√° para fazer a exponencia√ß√£o:\n2^31\n\n2147483648\nExpress√µes mais complexas tamb√©m podem ser calculadas:\n23 + 2 * 2 + 3 * 4\n\n39\nSim, a preced√™ncia de operadores usual tamb√©m √© v√°lida em Julia. Mas, segue a primeira li√ß√£o de programa√ß√£o: Escreva para humanos, n√£o para m√°quinas.\n23 + (2 * 2) + (3 * 4)\n\n39\nEm Julia tamb√©m podemos fazer opera√ß√µes com n√∫meros em ponto flutuante:\n23.5 * 3.14\n\n73.79\nou\n12.5 / 2.0\n\n6.25\nAcima temos mais um exemplo de c√≥digo escrito para pessoas, ao se escrever 2.0 estamos deixando claro que o segundo par√¢metro √© um n√∫mero float.\n√â importante saber que n√∫meros em ponto flutuante tem precis√£o limitada, logo n√£o se espante com resultados inesperados como abaixo:\n1.2 - 1.0\n\n0.19999999999999996\nErros como esse s√£o bastante raros, tanto que usualmente confiamos plenamente nas contas feitas com computadores e calculadoras. Mas, √© bom saber que existem limita√ß√µes.\n2.6 - 0.7 - 1.9\n\n2.220446049250313e-16\nou\n0.1 + 0.2\n\n0.30000000000000004\nou ainda\n10e15 + 1 - 10e15\n\n0.0\nEsses problemas de precis√£o est√£o ligados a limita√ß√£o de como os n√∫meros s√£o representados no computador. De maneira simplificada, os valores no computador s√£o codificados em palavras, formadas por bits. Nos computadores modernos as palavras tem 64 bits, ou 8 bytes. Logo, uma outra limita√ß√£o est√° ligada aos n√∫meros inteiros muito grandes\n2^63\n\n-9223372036854775808\nMas, para um curso introdut√≥rio basta saber que existem essas limita√ß√µes. Como lidar com elas √© parte de um curso mais avan√ßado.\n√â importante notar que o erro acima √© um erro silencioso, ou seja quanto estamos usando n√∫meros inteiros, pode ocorrer que o n√∫mero a ser representado n√£o caiba no n√∫mero de bits dispon√≠vel, o que faz com que ocorra um erro.\nVoltando para as contas. Um outro operador interessante √© o % que faz o resto da divis√£o\n4 % 3\n\n1\nAt√© agora vimos como trabalhar com um √∫nico valor, ou seja, como se fosse no visor de uma calculadora. Mas, √© poss√≠vel ir al√©m. Ao inv√©s de termos teclas de mem√≥ria, o computador nos oferece vari√°veis. Elas s√£o como nomes para valores que queremos guardar e usar mais tarde.\nAl√©m das opera√ß√µes b√°sicas tamb√©m temos as opera√ß√µes matem√°ticas (fun√ß√µes), como por exemplo o seno, sin em ingl√™s. Para saber como uma fun√ß√£o funciona podemos pedir ajuda ao ambiente, usando uma ? ou o macro @doc, e em seguida digitando o que queremos saber, como por exemplo em:\n@doc sin\nA sa√≠da desse comando indica a opera√ß√£o que a fun√ß√£o realiza e ainda apresenta alguns exemplos:\nAmbos os comandos ? sin @doc sin possuem a mesma sa√≠da.\nNotem que nem tudo que foi apresentado faz sentido no momento, mas j√° d√° para entender o uso de uma fun√ß√£o como sin. Vejamos agora a raiz quadrada:\n@doc sqrt\nNela vemos que √© poss√≠vel calcular a raiz como em:\nsqrt(4)\n\n2.0\nsqrt(4.0)\n\n2.0\nMas, observamos tamb√©m na documenta√ß√£o a fun√ß√£o big(), que tem a seguinte ajuda:\n@doc BigInt\nA fun√ß√£o big() em Julia √© usada para criar n√∫meros inteiros grandes, representados pelo tipo BigInt. Essa fun√ß√£o √© especialmente √∫til quando voc√™ precisa lidar com n√∫meros muito grandes que excedem o limite dos tipos inteiros padr√£o, como Int64 ou Int32.\nCom n√∫meros BigInt, j√° n√£o h√° problemas de estouro, como podemos ver abaixo:\nbig(2) ^ 1002\n\n42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504\nPodemos ainda carregar fun√ß√µes de outros arquivos em nosso arquivo Julia ou no pr√≥prio terminal, para isso basta utilizar o comando include(\"caminho/do/arquivo.jl\"), Julia l√™ o arquivo especificado e executa todo o seu conte√∫do no contexto atual. Isso significa que todas as fun√ß√µes, vari√°veis e defini√ß√µes no arquivo tornam-se dispon√≠veis no ambiente onde include foi chamado.\nComo por exemplo no primeiro caso tenho um arquivo chamado funcoes.jl que possui a fun√ß√£o soma:\nfunction ola(nome)\n    println(\"Ol√°\", nome)\nend\n\nola (generic function with 1 method)\nPodemos incluir essa fun√ß√£o em um segundo arquivo utilizando o include(\"funcoes.jl\"), e utilizar a fun√ß√£o definida no arquivo funcoes.jl\nCuja sa√≠da dever√° ser Ol√° Alfredo.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/03.html#come√ßando-com-o-modo-interativo-do-julia",
    "href": "chapters/03.html#come√ßando-com-o-modo-interativo-do-julia",
    "title": "3¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "",
    "text": "sin(x)\n\n  Compute sine of x, where x is in radians.\n\n  See also sind, sinpi, sincos, cis, asin.\n\n  Examples\n  ‚â°‚â°‚â°‚â°‚â°‚â°‚â°‚â°\n\n  julia&gt; round.(sin.(range(0, 2pi, length=9)'), digits=3)\n  1√ó9 Matrix{Float64}:\n   0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    include(\"funcoes.jl\")\n    println(ola(\"Alfredo\"))",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/03.html#vari√°veis-e-seus-tipos",
    "href": "chapters/03.html#vari√°veis-e-seus-tipos",
    "title": "3¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "3.2 Vari√°veis e seus tipos",
    "text": "3.2 Vari√°veis e seus tipos\nEm Julia tamb√©m temos o conceito de vari√°veis, que servem para armazenar os diferentes conte√∫dos de dados poss√≠veis.\n\na = 7\n2 + a\n\n9\n\n\n\n3.2.1 Tipagem din√¢mica\n√â importante notar que as vari√°veis em Julia podem receber novos valores e o tipo da vari√°vel depende do que foi atribu√≠do por √∫ltimo.\n\na = 3\ntypeof(a)\n\nInt64\n\n\n\na = a + 1\ntypeof(a)\n\nInt64\n\n\nNeste pr√≥ximo exemplo, a vari√°vel b √© inicializada com um valor de tipo inteiro, contudo, ap√≥s a opera√ß√£o de multiplica√ß√£o, seu valor √© do tipo ponto flutuante:\n\nb = 3\nb = b * 0.5\ntypeof(b)\n\nFloat64\n\n\nA tipagem din√¢mica apresenta diversas vantagens, entre elas a flexibilidade, pois √© poss√≠vel reutilizar vari√°veis para armazenar diferentes tipos de dados ao longo do tempo; e menos verbosidade, pois n√£o √© necess√°rio especificar o tipo de cada vari√°vel, o que melhora a legibilidade do c√≥digo.\nAproveitando o momento, podemos ver que h√° v√°rios tipos primitivos em Julia, sendo os principais:\n\ntypeof(1)\n\nInt64\n\n\n\ntypeof(1.1)\n\nFloat64\n\n\n\ntypeof(\"Bom dia\")\n\nString\n\n\nFalando em Strings, elas s√£o definidas por conjuntos de caracteres entre aspas como:\n\ns1 = \"Olha que legal\"\ns2 = \"Outra String\"\n\n\"Outra String\"\n\n\nD√° tamb√©m para fazer opera√ß√µes com strings como concatena√ß√£o:\n\ns1 = \"Tenha um\"\ns2 = \" Bom dia\"\ns3 = s1 * s2\n\n\"Tenha um Bom dia\"\n\n\nOu pot√™ncia:\n\ns = \"Nao vou mais fazer coisas que possam desagradar os meus colegas \"\ns ^ 10\n\n\"Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fa\" ‚ãØ 98 bytes ‚ãØ \"s meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas \"\n\n\nAinda sobre vari√°veis, h√° umas regras com rela√ß√£o aos seus nomes, tem que come√ßar com uma letra (ou com _), pode ter d√≠gitos e n√£o pode ser uma palavra reservada. √â bom notar que Julia por ser uma linguagem moderna, aceita nomes de caracteres em unicode, por exemplo o Œî (\\Delta):\n\nŒî = 2\n\n2\n\n\nMas, a linguagem vai bem al√©m com caracteres de animais e s√≠mbolos:\n\nüê± = 5 # \\:cat: &lt;tab&gt;\nüê∂ = 3 # \\:dog: &lt;tab&gt;\nüè† = 20 # \\:house: &lt;tab&gt;\n\n20\n\n\nIsso n√£o adiciona nada do lado de algoritmos, mas √© poss√≠vel ter vari√°veis bem bonitinhas. A lista de figuras pode ser encontrada aqui.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/03.html#sa√≠da-de-dados",
    "href": "chapters/03.html#sa√≠da-de-dados",
    "title": "3¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "3.3 Sa√≠da de dados",
    "text": "3.3 Sa√≠da de dados\nPara fazer sa√≠das usam-se dois comandos, print() e o println(), sendo que o primeiro n√£o pula linha e o segundo pula.\n\nprint(\"Hello \")\nprintln(\"World!\")\nprintln(\"Ola, mundo!\")\n\nHello World!\nOla, mundo!\n\n\nPara evitar que se digitem muitos caracteres, por vezes podemos usar ‚Äúa√ßucares sint√°ticos‚Äù.\n\nx = 1\nx = x + 1\nx += 1  # forma equivalente a acima, o mesmo vale para os operadores *, - e /\n\n3\n\n\nAcima, vimos a forma de se inserir coment√°rios em Julia (sim esses ser√£o ignorados pelo computador).\nExerc√≠cio: Fa√ßa o passo a passo para encontrar as ra√≠zes da equa√ß√£o de segundo grau \\(x^2 - 5 x + 6\\), usando as v√°riaveis a, b, c, \\Delta, x1 e x2. Ap√≥s isso, compare com a solu√ß√£o a seguir:\n\n\n# Defini√ß√£o dos coeficientes\na = 1\nb = -5\nc = 6\n\n# C√°lculo do discriminante\ndelta = b^2 - 4 * a * c\n\n# C√°lculo das ra√≠zes\nif delta &gt;= 0\n    x1 = (-b + sqrt(delta)) / (2 * a)\n    x2 = (-b - sqrt(delta)) / (2 * a)\n    println(\"As ra√≠zes s√£o: x1 = $x1 e x2 = $x2\")\nelse\n    println(\"A equa√ß√£o n√£o possui ra√≠zes reais.\")\nend\n\nAs ra√≠zes s√£o: x1 = 3.0 e x2 = 2.0",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/04.html",
    "href": "chapters/04.html",
    "title": "4¬† Introdu√ß√£o √†s Fun√ß√µes",
    "section": "",
    "text": "4.1 O uso de fun√ß√µes √© uma abstra√ß√£o natural\nObjetivo: Come√ßar a entender como funcionam as fun√ß√µes em uma linguagem de programa√ß√£o\nNa aula passada j√° vimos umas fun√ß√µes e isso foi bem natural, foram elas:\nInclusive, aqui vale a pena ver que podemos pedir ajuda ao Julia para saber o que fazem as fun√ß√µes. Para isso, se usa o ? antes da fun√ß√£o:\nAo fazer isso, inclusive descobrimos que o div() pode ser usado tamb√©m como .\nUma outra fun√ß√£o bem √∫til √© a que permite transformar um tipo de valor em outro.\nPara convers√£o de valores em ponto flutuante para inteiros, temos a fun√ß√£o trunc.\nDe forma inversa temos o float.\nFinalmente, podemos transformar um valor em uma string, como em:\nou\nTamb√©m tem muitas fun√ß√µes matem√°ticas prontas como\nA melhor forma de se acostumar a usar as fun√ß√µes √© fazendo contas e verificando os resultados. Uma dica importante √© que para fun√ß√µes mais complexas, pode ser que j√° existam fun√ß√µes prontas em Julia. Para isso uma busca com as palavras chave. Um exemplo a seguir para procurar a fun√ß√£o para o c√°lculo de seno hiperb√≥lico: ‚Äújulia lang hiperbolic sin‚Äù. A busca pelo termo em ingl√™s √© uma boa dica para buscas em geral.\nEm julia tamb√©m √© poss√≠vel criar fun√ß√µes conforme as suas necessidades, como abaixo:\nfunction mensagemDeBomDia()\n   println(\"Tenha um bom dia!\")\nend\n\nmensagemDeBomDia (generic function with 1 method)\nPara usar uma fun√ß√£o, basta cham√°-la:\nFun√ß√µes, podem receber um ou mais par√¢metros:\nfunction imprime(a)\n   println(\" Vou imprimir \", a)\nend\nimprime(42)\n\n Vou imprimir 42\nTamb√©m √© poss√≠vel que uma fun√ß√£o chame outra fun√ß√£o como em:\nfunction imprimeduasvezes(a)\n   imprime(a)\n   imprime(a)\nend\nimprimeduasvezes(13)\n\n Vou imprimir 13\n Vou imprimir 13\nMais ainda, tamb√©m √© poss√≠vel diferenciar fun√ß√µes por meio da quantidade de par√¢metros.\nfunction recebe(a)\n  println(\"Recebi um parametro: \", a)\nend\nfunction recebe(a, b)\n  println(\"Recebi dois parametros: \", a, \" \", b)\nend\n\nrecebe (generic function with 2 methods)\nConforme a chamada, a fun√ß√£o chamada ser√° diferente:\nTamb√©m d√° para chamar fun√ß√µes com vari√°veis e com opera√ß√µes, como em:\nAs fun√ß√µes que vimos at√© agora imprimem mensagens, mas n√£o devolvem nada. O typeof() delas √© nothing, ou seja, algo que n√£o pode ser atribu√≠do.\nMas, tamb√©m √© poss√≠vel fazer fun√ß√µes que devolvem valores, como:\nNesse caso, se for passado um par√¢metro num√©rico, a fun√ß√£o devolver√° o valor incrementado (adicionado de 1).\nClaro que isso pode ser usado com f√≥rmulas mais complicadas como:\nfunction hipotenusa(a, b)\n  hip = a * a + b * b\n  return hip\nend\n\nhipotenusa (generic function with 1 method)\nExerc√≠cio: Fa√ßa uma fun√ß√£o para encontrar o de uma equa√ß√£o de segundo grau",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Introdu√ß√£o √†s Fun√ß√µes</span>"
    ]
  },
  {
    "objectID": "chapters/04.html#o-uso-de-fun√ß√µes-√©-uma-abstra√ß√£o-natural",
    "href": "chapters/04.html#o-uso-de-fun√ß√µes-√©-uma-abstra√ß√£o-natural",
    "title": "4¬† Introdu√ß√£o √†s Fun√ß√µes",
    "section": "",
    "text": "typeof() - Dado um par√¢metro devolve o seu tipo. Vari√°veis est√£o associadas a tipos;\ndiv() - Dados dois par√¢metros devolve a divis√£o inteira do primeiro pelo segundo;\nprint() e println() - Dados diversos par√¢metros os imprime, sem devolver nada.\n\n\n?typeof()\n?div()\n?print()\n\n\nparse(Float64, \"32\")\n\ntrunc(Int64, 2.25)\n\nfloat(2)\n\nstring(3)\n\nstring(3.57)\n\n\n\n\n\n\n\n\nFun√ß√£o\nDescri√ß√£o\n\n\n\n\nsin(x)\nCalcula o seno de ( x ) em radianos\n\n\ncos(x)\nCalcula o cosseno de ( x ) em radianos\n\n\ntan(x)\nCalcula a tangente de ( x ) em radianos\n\n\ndeg2rad(x)\nConverte ( x ) de graus em radianos\n\n\nrad2deg(x)\nConverte ( x ) de radianos em graus\n\n\nlog(x)\nCalcula o logaritmo natural de ( x )\n\n\nlog(b, x)\nCalcula o logaritmo de ( x ) na base ( b )\n\n\nlog2(x)\nCalcula o logaritmo de ( x ) na base 2\n\n\nlog10(x)\nCalcula o logaritmo de ( x ) na base 10\n\n\nexp(x)\nCalcula o expoente da base natural de ( x )\n\n\nabs(x)\nCalcula o m√≥dulo de ( x )\n\n\nsqrt(x)\nCalcula a raiz quadrada de ( x )\n\n\ncbrt(x)\nCalcula a raiz c√∫bica de ( x )\n\n\nfactorial(x)\nCalcula o fatorial de ( x )\n\n\n\n\n\n\n\nMensagemDeBomDia()\n\n\n\n\n\n\n\nrecebe(1)\nrecebe(1, 2)\n\na = 10\nrecebe(a)\nrecebe(a, a + 1)\n\n\nfunction soma1(a)\n  return a + 1\nend",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Introdu√ß√£o √†s Fun√ß√µes</span>"
    ]
  },
  {
    "objectID": "chapters/05.html",
    "href": "chapters/05.html",
    "title": "5¬† Compara√ß√µes, o comando if e recurs√£o",
    "section": "",
    "text": "5.1 Agora sim: Fun√ß√µes que se chamam\nAntes de falar em desvio (if), vamos ver um novo tipo de vari√°vel que foi introduzido de forma natural. O tipo booleando, ou seja uma vari√°vel que pode valer true (verdadeiro) ou false (falso). O seu uso est√° intimamente ligado ao if.\nObservem os seguintes exemplos:\nVale chamar a aten√ß√£o, como em linguagens de programa√ß√£o o = √© usado para atribui√ß√µes, para compara√ß√µes se usa o ==. Da mesma forma o != √© usado como diferente. Esses operadores, em conjunto com o &lt;, &lt;=, &gt; e &gt;= nos permitem comparar valores.\nSobre as vari√°veis booleanas vale tamb√©m observar o seu tipo. Uma explica√ß√£o mais aprofundada sobre como essas vari√°veis funcionam ser√° fornecida quando abordarmos os operadores condicionais:\nFinalmente, tamb√©m podemos negar vari√°veis booleanas para inverter o seu valor:\nNessa aula, vamos aprender um novo comando. O desvio condicional, atrav√©s dele √© poss√≠vel alterar o fluxo de execu√ß√£o de um programa. At√© o momento n√£o t√≠nhamos comentado isso explicitamente, mas a ordem de execu√ß√£o de instru√ß√µes segue a ordem em que elas est√£o. Vejamos o exemplo abaixo:\nA ordem de impress√£o ser√° Oi, um e dois.\nDa mesma forma n√£o temos problema ao executar o c√≥digo abaixo.\nApesar da vari√°vel denominador come√ßar inicialmente com 0, antes de se fazer a divis√£o, ela estar√° valendo 2.\nComo √© de se esperar nem sempre queremos que essa ordem seja respeitada. Observe o seguinte exemplo:\nO exemplo acima √© claro, se uma condi√ß√£o for verdadeira, o c√≥digo que est√° no escopo do if (isso √© entre a condi√ß√£o e o end) ser√° executado.\nUm outro exemplo:\nSitua√ß√µes muito comuns em computa√ß√£o devem ser favorecidas pela linguagem, nesse caso do if, √© muito comum termos duas ou mais situa√ß√µes. Nesse sentido em Julia podemos tamb√©m ter alternativas como abaixo:\nNo caso de termos mais de uma altenativa, n√£o basta termos s√≥ uma condi√ß√£o, nesse caso temos que usar elseif.\nConhecendo o if, agora, escreva uma fun√ß√£o que recebe os coeficientes, a, b e c de uma equa√ß√£o de segundo grau e imprime as suas ra√≠zes reais.\nSim, a forma de se aprender a programar √© programando.\nVamos agora a parte mais importante do curso, lembrando que at√© o momento aprendemos: - valores - var√≠aveis e alguns dos seus tipos - alguma fun√ß√µes j√° prontas como div(), typeof(), parse(), string(), println(), sin(), etc - como fazer as nossas fun√ß√µes com a palavra reservada function e que termina por end - lembrando que a fun√ß√£o pode ou n√£o devolver algo atrav√©s do return - lembrando tamb√©m que uma fun√ß√£o pode chamar outra fun√ß√£o - como mudar o fluxo de execu√ß√£o normal com o if, elseif\nAgora podemos, ir ao t√≥pico principal da aula.\nObserve a seguinte fun√ß√£o imprime().\nfunction imprime()\n    println(\"Mensagem positiva\")\n    imprime()\nend\n\nimprime (generic function with 1 method)\nAo ser chamada, o que acontece? O computador far√° chamadas seguidas a fun√ß√£o, imprimindo a mensagem, at√© o momento que ocorra uma limita√ß√£o de mem√≥ria. Logo, fazer chamadas onde uma fun√ß√£o se chama, sem controle n√£o √© uma boa ideia.\nPor outro lado, podemos pensar em uma forma de chamada controlada, onde a pr√≥pria fun√ß√£o decide o momento de parar de se chamar. Para isso, vamos pegar uma fun√ß√£o matem√°tica bem conhecida, o fatorial.\nSabemos que 5! = 5.4.3.2.1. Mais, ainda dado um n√∫mero n, sabemos que n! = n.(n - 1)! Continuando, temos que (n - 1)! = (n - 1).(n - 2)! e assim por diante. Para reproduzir isso no computador precisamos saber quando parar. Para isso, podemos usar que o fatorial de zero √© 1, ou 0! = 1. Logo j√° temos a primeira parte da fun√ß√£o:\nfunction fatorial(n)\n if n == 0\n   return 1\n else\n   # o que vamos colocar aqui?\nend\nNo c√≥digo acima, temos o crit√©rio de parada, ou seja quando n for igual a zero, a resposta ser√° 1. Mas, e se n n√£o for zero. Nesse caso, temos que seguir a f√≥rmula da recurs√£o ou seja n.(n - 1)!. Como (n - 1)! pode ser escrito como fatorial(n - 1). Ficamos com a express√£o n * fatorial(n - 1).\nfunction fatorial(n)\n # Crit√©rio de parada: quando n √© igual a 0, a recurs√£o termina\n if n == 0\n   return 1\n else\n   return n * fatorial(n - 1) # Chamada recursiva\n end\nend\nfatorial(5)\n\n120\nVamos a um segundo exemplo, a contagem regressiva. Mais uma vez, quando se chega a zero, podemos considerar que a contagem terminou. Al√©m disso, a cada n√∫mero, o pr√≥ximo passo √© o n√∫mero menos 1.\nfunction contagem(n)\n   if n &lt; 0\n       println(\"Bum!\")\n   else\n       print(n, \" \")\n       contagem(n - 1)\n   end\nend\ncontagem(5)\n\n5 4 3 2 1 0 Bum!\nEssa estrutura √© bem poderosa, pois permite que opera√ß√µes sejam executadas um n√∫mero controlado de vezes. Voltando ao countdown, imagine que ao inv√©s de imprimir uma mensagem quis√©ssemos fazer uma conta com o que ser√° devolvido.\nfunction soma(n)\n if n &gt; 0\n   return n + soma(n - 1)\n else\n   return 0\n end\nend\n\nsoma(11)\n\n66\nEssa estrutura √© bastante poderosa e pode ser usada para o c√°lculo de produto, nesse caso, a mudan√ßa √© bem pequena.\nDa mesma forma segue um exemplo para o c√°lculo dos n primeiros elementos da soma h√¢rmonica.\nfunction somaharmonica(atual, n)\n # Caso base: se 'atual' √© maior ou igual a 'n'\n if atual &gt;= n\n   # Retorna o rec√≠proco de 'atual' (√∫ltimo termo da soma)\n   return 1.0 / atual\n else\n   # Caso recursivo: soma o rec√≠proco de 'atual' e chama a fun√ß√£o para o pr√≥ximo n√∫mero\n   return 1.0 / atual + somaharmonica(atual + 1, n)\n end\nend\n\nsomaharmonica(1, 10)\n\n2.9289682539682538",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Compara√ß√µes, o comando if e recurs√£o</span>"
    ]
  },
  {
    "objectID": "chapters/06.html",
    "href": "chapters/06.html",
    "title": "6¬† Mais algoritmos e introdu√ß√£o aos testes",
    "section": "",
    "text": "Nessa aula, vamos ver algoritmos um pouco mais elaborados. Mas, sabendo que vamos usar algo com um maior grau de sofistica√ß√£o, que tal pensar em testes?\nDe uma forma geral, para verificar o funcionamento de um programa, podemos escrever testes que verificam o funcionamento em algumas situa√ß√µes espec√≠ficas.\nDado que o primeiro problema que queremos resolver √© um algoritmo que encontra o n-√©simo n√∫mero de Fibonacci. Por que n√£o come√ßar com testes?\nUma forma de se fazr testes, e de forma manual, mas isso n√£o √© reprodut√≠vel. A melhor maneira de se fazer testes, √© de forma automatizada, ou seja criar c√≥digo que teste c√≥digo. Isso pode parecer complicado, mas vamos ver abaixo que n√£o √©.\nEm uma busca r√°pida, podemos ver que a sequ√™ncia de Fibonacci √© definida da seguinte forma, os dois primeiros elementos \\(F_1\\) e \\(F_2\\) valem 1, em seguida temos a f√≥rmula \\(F_n = F_{n-1} +  F_{n-2}\\). Mas, antes de pensar em resolver o problema vamos pensar em como testar.\nJ√° sabemos os primeiros valores, al√©m disso, atrav√©s de uma busca r√°pida, podemos descobrir alguns valores da sequ√™ncia como \\(F_5 =  5\\) e \\(F_{12}  =\n144\\). Supondo que a fun√ß√£o para o c√°lculo do n-√©simo n√∫mero de Fibonacci chamar√° fibo(). Podemos escrever o seguinte trecho de c√≥digo:\n\nfunction testafibo_versao1()\n    if fibo(1) == 1\n        println(\"Deu certo para 1\")\n    end\n    if fibo(2) == 1\n        println(\"Deu certo para 2\")\n    end\n    if fibo(5) == 5\n        println(\"Deu certo para 5\")\n    end\n    if fibo(12) == 144\n        println(\"Deu certo para 12\")\n    end\n    println(\"Final dos testes\")\nend\n\ntestafibo_versao1 (generic function with 1 method)\n\n\nA fun√ß√£o de testes acima verifica se a fun√ß√£o fibo() devolve o resultado correto para tr√™s casos. Mas, ela tem um defeito, ela imprime mensagens demais, o que pode ser ruim. Considerando isso, vamos ver o primeiro fundamento importante com rela√ß√£o a testes automatizados.\nSe o teste passou, ele deve indicar apenas que deu certo!\nLevando em conta o que foi escrito acima, podemos mudar o nosso teste para:\n\nfunction testafibo()\n    if fibo(1) != 1\n        println(\"N√£o deu certo para 1\")\n    end\n    if fibo(2) != 1\n        println(\"N√£o deu certo para 2\")\n    end\n    if fibo(5) != 5\n        println(\"N√£o eu certo para 5\")\n    end\n    if fibo(12) != 144\n        println(\"N√£o deu certo para 12\")\n    end\n    println(\"Final dos testes\")\nend\n\ntestafibo (generic function with 1 method)\n\n\nAgora de posse da nossa fun√ß√£o de testes, podemos pensar em escrever a nossa fun√ß√£o de Fibonacci. Vamos ao caso f√°cil de n for menor que 2, a resposta √© 1. Como vemos abaixo:\n\nfunction fibo(n)\n    if n &lt;= 2\n        return 1\n    else\n        # ainda n√£o sabemos o que colocar aqui...\n    end\nend\n\nfibo (generic function with 1 method)\n\n\nMas, a resposta est√° na pr√≥pria defini√ß√£o da fun√ß√£o, ou seja: \\(F_n = F_{n-1} +  F_{n-2}\\). Se o \\(n\\) for maior do que 2, temos que fazer a soma dos valores de Fibonacci de \\(n-1\\) e de \\(n-2\\). Ou seja:\n\nfunction fibo(n)\n    if n &lt;= 2\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nend\n\nfibo(10)\n\n55\n\n\n√â interessante notar que apesar de ser um dos exemplos cl√°ssicos de uso de recurs√£o, o algoritmo acima √© extremamente ineficiente. A raz√£o √© simples, cada vez que √© feita a chamada, toda os valores de Fibonacci s√£o recalculados para os valores de \\(n\\) e \\(n-1\\).\nComo Julia √© uma linguagem moderna podemos usar o conceito de Memoiza√ß√£o, que evita calcular o que j√° foi calculado. O Memoize tem que ser instalado no Julia com os comandos import Pkg e Pkg.add(\"Memoize\").\n\nusing Memoize\n@memoize function fibo(n)\n    if n &lt;= 2\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nend\n\nfibo(10)\n\n55\n\n\nAs diferen√ßas de tempo das duas vers√µes podem ser verificada com o comando @time. Da seguinte forma:\n\n@time fibo(10)\n\n  0.000001 seconds\n\n\n55\n\n\nEsse tipo de comando, que come√ßa com @ √© conhecido como anota√ß√£o, e tem o poder de mudar o comportamente de partes do c√≥digo.\nVamos ao segundo algoritmo da aula, o MDC (M√°ximo Divisor Comum). A ideia √© usar o algoritmo de Euclides.\nBasicamente ele diz que o MDC de dois n√∫meros a e b, √© igual ao MDC de b e r, onde \\(r=a\\% b\\). Quando esse resto for zero, chegamos a solu√ß√£o, que √© b.\nVamos come√ßar com os testes para alguns valores bem conhecidos. Por sinal come√ßar pelos testes antes de escrever o c√≥digo √© uma boa pr√°tica de programa√ß√£o conhecida por TDD (Test Driven Design).\n\nfunction testaMDC()\n    if MDC(3298, 2031) != 1\n        println(\"deu erro, para 3298 e 2031\")\n    end\n    if MDC(120, 36) != 12\n        println(\"deu erro, para 120 e 36\")\n    end\n    if MDC(36, 120) != 12\n        println(\"deu erro, para 36 e 120\")\n    end\n    println(\"Acabaram os testes\")\nend\n\ntestaMDC (generic function with 1 method)\n\n\nVamos pensar na fun√ß√£o agora. Dessa vez, se o resto for 0, temos que devolver o segundo termo. Caso contr√°rio temos que continuar com a regra\n\nfunction MDC(a, b)\n    r = a % b\n    if r == 0\n        return b\n    else\n        return MDC(b, r)\n    end\nend\n\ntestaMDC()\n\nAcabaram os testes\n\n\nAt√© agora usamos o modo interativo do Julia para fazer os nosso c√≥digos. Mas, existe oura forma bem mais reutiliz√°vel, ou seja escrever o texto em arqivos. Isso √© relativamente simples, basta usar um editor de texto (puro) da sua prefer√™ncia, como o notepad, nano, juno, atom, vscode ou outro e salvar um arquivo com a extens√£o .jl.\nMas, para que algo seja executado √© importante colocar uma chamada ao final. Veja abaixo um poss√≠vel arquivo mdc.jl.\n\nfunction testeMDC()\n    if mdc(70, 5) != 5\n        println(\"N√£o funcionou para 70 e 5\")\n    end\n    if mdc(13, 7) != 1\n        println(\"N√£o funcionou para 13 e 7\")\n    end\n    if mdc(127, 15) != 1\n        println(\"N√£o funcionou para 127 e 15\")\n    end\n    if mdc(20, 15) != 5\n        println(\"N√£o funcionou para 20 e 15\")\n    end\n    if mdc(42, 3) != 3\n        println(\"N√£o funcionou para 42 e 3\")\n    end\n    if mdc(42, 8) != 2\n        println(\"N√£o funcionou para 42 e 8\")\n    end\n    println(\"Final dos testes\")\nend\n\nfunction mdc(a, b)\n    r = a % b\n    if r == 0\n        return b\n    else\n        mdc(b, r)\n    end\nend\n\ntesteMDC()\nprintln(\"O mdc entre 1227 e 321 √© \", mdc(1227, 321))\n\nFinal dos testes\nO mdc entre 1227 e 321 √© 3",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Mais algoritmos e introdu√ß√£o aos testes</span>"
    ]
  },
  {
    "objectID": "chapters/07.html",
    "href": "chapters/07.html",
    "title": "7¬† Testes automatizados e um pouco mais de c√≥digo",
    "section": "",
    "text": "7.1 Fun√ß√µes ca√≥ticas\nVamos come√ßar o cap√≠tulo vendo uma forma mais simples de se rodar testes. Nos testes que vimos at√© agora sempre havia o teste de uma condi√ß√£o booleana associado a uma mensagem de erro quando n√£o funcionasse. Mas, observando que a mensagem de erro geralmente est√° ligada √† condi√ß√£o, por vezes a condi√ß√£o pode ser auto-explicativa.\nLogo, uma forma elegante de expressar as condi√ß√µes pode ser √∫til na escrita dos testes. Para isso, vamos usar o m√≥dulo de testes. Em linguagens modernas, v√°rias das situa√ß√µes repetitivas que enfrentamos podem ser evitadas usando alguma t√©cnica mais moderna.\nNo trecho acima primeiro indicamos que queremos fazer testes. Em seguida usamos o test que espera uma condi√ß√£o ou valor booleano. Finalmente todos os testes s√£o reunidos em um testset.\nClaro que o teste d√° infoma√ß√µes relevantes quando falha:\nAgora sim, vamos pensar em problemas algoritmicos novos. Que tal fazer a soma dos d√≠gitos de um n√∫mero inteiro. Ou seja, pensar em um n√∫mero d√≠gito √† d√≠gito. Vamos aos testes primeiro:\nVamos agora tentar pensar em como ‚Äúdescascar‚Äù um n√∫mero, dado o n√∫mero 123, uma forma seria pegar o resto por 10 (ou seja 3) e depois dividir por 10 (ou seja 12), e assim por diante. Ou seja.\nVamos agora a um outro problema cl√°ssico, a verifica√ß√£o se um n√∫mero √© ou n√£o √© primo. Na pr√°tica para fazer isso, temos a defini√ß√£o, um n√∫mero \\(n\\) √© primo apenas se for divis√≠vel apenas por 1 e por ele mesmo. Ou seja, nenhum n√∫mero entre 2 e \\(n - 1\\) pode ser divisor de um n√∫mero primo.\nA forma de se fazer isso √© relativamente simples. Vamos pensar em uma fun√ß√£o que tenta dividir um n√∫mero recursivamente, se conseguir devolve falso, se n√£o conseguir devolve verdadeiro.\nVamos aos c√≥digo:\nQue pode ser chamada por:\nMais um exemplo, o m√©todo de Newton para o c√°lculo de raiz quadrada. Para achar a raiz de \\(x\\), a partir de um chute inicial (por exemplos \\(y= x /2\\)), chegamos a um novo chute que √© a m√©dia de \\(y\\) e \\(x/y\\).\nMas, sim, vamos come√ßar com os testes. Como estamos usando n√∫meros do tipo double √© bom sempre ter uma toler√¢ncia, por isso vamos usar uma compara√ß√£o aproximada. Tamb√©m poderiamos ter usado a fun√ß√£o isapprox da linguagem Julia.\nNote que como estamos comparando n√∫meros em ponto flutuante, n√£o usamos a compara√ß√£o exata.\nA solu√ß√£o final √©:\nVamos brincar um pouco agora com fun√ß√µes ca√≥ticas :), isso √©, fun√ß√µes, que conforme o comportamento de uma constante \\(k\\), apresentam resultados que podem convergir ou n√£o. Isso √©, a cada passo, quero saber o valor do pr√≥ximo ponto aplicando a fun√ß√£o novamente, isso √©: \\[x_1 = f(x_0), x_2 = f(x_1), \\ldots, x_n  = f(x_{n - 1})\\]\nAs fun√ß√µes ca√≥ticas desempenham um papel significativo em diversas √°reas da matem√°tica e da f√≠sica, com aplica√ß√µes que v√£o desde a modelagem de crescimento populacional at√© a previs√£o de padr√µes clim√°ticos. Elas tamb√©m s√£o fundamentais na an√°lise de circuitos el√©tricos n√£o lineares, onde pequenas varia√ß√µes nas condi√ß√µes iniciais podem levar a resultados drasticamente diferentes.\nPara o nosso teste, a fun√ß√£o \\(f\\) √© extremamente simples: \\(x_{i + 1}=x_i * (1 -  x_i) * k\\).\nImplemente a fun√ß√£o e imprima os 30 primeiros resultados. Comece com um valor de \\(x\\) entre 0 e 1, como 0.2. Use constantes \\(k = 2.1, 2.5, 2.8\\) e \\(3.1\\) o que ocorre com \\(k = 3.7\\)?\nEntregue o c√≥digo e um pequeno relat√≥rio sobre o que acontece.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Testes automatizados e um pouco mais de c√≥digo</span>"
    ]
  },
  {
    "objectID": "chapters/08.html",
    "href": "chapters/08.html",
    "title": "8¬† Uma outra forma de se fazer la√ßos",
    "section": "",
    "text": "At√© o momento vimos que o computador √© muito bom para fazer contas e repeti√ß√µes. Fizemos isso at√© agora com fun√ß√µes recursivas. Mas, existe um outro comando para isso, o while. A motiva√ß√£o √© que enquanto alguma condi√ß√£o for v√°lida, o computador continua repetindo os comandos.\nO formato b√°sico √© o seguinte:\nwhile condi√ß√£o\n  # execute obloco\nend  \nEnquanto a condi√ß√£o continuar verdadeira, o computador vai seguir repetindo o bloco que pode ser formado por v√°rias intru√ß√µes. Logo, para que a repeti√ß√£o, ou la√ßo, n√£o seja repetido indefinidamente, √© essencial que algo ligado a condi√ß√£o seja atualizado no corpo do while.\nVejamos o exemplo simples da contagem regressiva:\n\nn = 5\nwhile n &gt; 0\n  println(n)\n  n = n - 1\nend\nprintln(\"Acabou\")\n\n5\n4\n3\n2\n1\nAcabou\n\n\nMas, vamos ver abaixo um caso onde o uso de while deixa o c√≥digo mais Claro que com a recurs√£o (onde √© ruim fazer uma com v√°rios par√£metros). Veja a resolu√ß√£o da s√©rie de Taylor abaixo:\n\n function sinTaylor2(x)\n   i = 1\n   termo = x\n   soma = 0.0\n   while i &lt;= 15\n     soma = soma + termo\n     termo = -1 * termo * x * x / ((2 * i) * (2 * i + 1))\n     i = i + 1\n   end\n   return soma\nend\n\nsinTaylor2 (generic function with 1 method)\n\n\nNela s√£o calculados os 15 primeiros termos.\nObservem a vers√£o recursiva:\n\nfunction sinTaylor(x)\n    return sinTaylorRec(1, 15, x, 1, x)\nend\n\nfunction sinTaylorRec(i, n, x, sinal, termo)\n    if n == i\n      return 0.0\n    else\n      return sinal * termo +\n         sinTaylorRec(i + 1, n, x, -1 * sinal, termo * x * x/ (2*i * (2*i+1)))\n    end\nend\n\nsinTaylorRec (generic function with 1 method)\n\n\nPodemos tamb√©m fazer opera√ß√µes com os d√≠gitos de um n√∫mero inteiro, para isso opera√ß√µes como o resto da divis√£o por 10 e a divis√£o inteira por 10 s√£o bastante √∫teis. Abaixo temos as duas vers√µes que fazem a soma dos d√≠gitos de um n√∫mero inteiro.\n\nusing Test\nfunction testaSD()\n  @test sd(123) == 6\n  @test sd(321) == 6\n  @test sd(0) == 0\n  @test sd(1001) == 2\n  @test sd(3279) == 21\n  println(\"Fim dos testes\")\nend\n\nfunction sd(x)\n  if x == 0\n     return 0\n  else\n     d = x % 10\n     return d + sd(div(x, 10))\n  end\nend\n\nfunction sd1(x)\n  soma = 0\n  while x != 0\n   d = x % 10\n   soma = soma + d\n   x = div(x, 10)\n  end\n  return soma\nend\ntestaSD()\n\nFim dos testes",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Uma outra forma de se fazer la√ßos</span>"
    ]
  },
  {
    "objectID": "chapters/09.html",
    "href": "chapters/09.html",
    "title": "9¬† Aula de exerc√≠cios",
    "section": "",
    "text": "9.1 Revisitando o c√°lculo do fatorial, recursivo e interativo\nAgora que aprendemos a fazer tamb√©m repeti√ß√µes com o comando while, sempre √© bom pensar em qual o comando mais adequado. Vejamos o exemplo abaixo com duas vers√µes da fun√ß√£o para o c√°lculo do Fatorial.\nfunction fatorial_recursivo(n::Int64) # Com o ::Int64 estamos definindo que o par√¢metro da fun√ß√£o deve ser um n√∫mero inteiro\n    # Caso base do fatorial: 0! e 1! s√£o iguais a 1\n    if n == 0 || n == 1\n        return 1\n    # Chamada recursiva: n! = n * (n-1)!\n    else\n        return n * fatorial_recursivo(n - 1)\n    end\nend\n\nfunction fatorial_iterativo(n::Int64)\n    # Inicializa o resultado como 1 (j√° que o fatorial de 0 √© 1)\n    resultado = 1\n\n    # No loop estamos fazendo a multiplica√ß√£o: n * (n-1) * ... * 2\n    while n &gt; 1\n        # Multiplica o resultado pelo valor atual de n\n        resultado *= n\n\n        # Decrementa n em 1 para continuar o c√°lculo do fatorial\n        n -= 1\n    end\n    return resultado\nend\n\nprintln(fatorial_recursivo(3))\n\n6\nNo c√≥digo acima temos uma novidade, nos par√¢metros da fun√ß√£o, o tipo est√° sendo declarado expicitamente. No caso, estamos dizendo que o valor n que a fun√ß√£o vai receber √© de um tipo espec√≠fico. Ou seja um Inteiro de 64 bits.\nO estilo de c√≥digo est√° um pouco diferente do que antes, pois foi escrito por outra pessoa. A monitora. Vemos que ela tem o h√°bito de usar nomes de vari√°veis maiores al√©m do que usar contra√ß√µes como += e *=.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Aula de exerc√≠cios</span>"
    ]
  },
  {
    "objectID": "chapters/09.html#aproxima√ß√£o-da-raiz-quadrada",
    "href": "chapters/09.html#aproxima√ß√£o-da-raiz-quadrada",
    "title": "9¬† Aula de exerc√≠cios",
    "section": "9.2 Aproxima√ß√£o da raiz quadrada",
    "text": "9.2 Aproxima√ß√£o da raiz quadrada\nPara o pr√≥ximo exemplo, vamos ver o m√©todo de Newthon-Raphson para o c√°lculo da raiz quadrada. √â um m√©todo recursivo no qual o pr√≥ximo valor √© baseado no valor anterior. Quanto mais chamadas forem feitas, mais pr√≥ximo do valor final vai se chegar.\nMais informa√ß√µes sobre o m√©todo podem ser encontradas em aqui. Mas para o momento temos que pensar na seguinte implementa√ß√£o. Para se calcular a raiz, podemos usar a seguinte f√≥rmula, a partir de um palpite inicial r, para o valor da raiz de x.\n\\[ r_{n+1} = 0.5 * (r + x / r)\\]\nComo o c√≥digo abaixo √© mais complicado, foram usados coment√°rios.\n\nfunction aproxima_raiz(x::Float64, epsilon::Float64)::Float64\n    if x &lt; 0\n        return nothing\n    end\n\n    # Chute inicial \n    aproximacao = x/2\n    melhor_aproximicao = aproximacao\n\n    while true\n        # F√≥rmula para aproxima√ß√£o de raiz quadrada utilizando o m√©todo de Newthon-Raphson\n        melhor_aproximicao = 0.5 * (aproximacao + x/aproximacao)\n\n        # Se a dist√¢ncia absoluta entre os dois pontos √© menor do que epsilon, ent√£o podemos parar o m√©todo\n        if abs(aproximacao - melhor_aproximicao) &lt;= epsilon\n            break\n        end\n\n        # Se a aproxima√ß√£o ainda n√£o for boa o sufuciente, ent√£o atualizamos a aproxima√ß√£o para a pr√≥xima itera√ß√£o\n        aproximacao = melhor_aproximicao\n    end\n\n    return melhor_aproximicao\n\nend\n\naproxima_raiz (generic function with 1 method)\n\n\nNotem que foi introduzido um comando novo, o break, esse comando apenas interrompe a execu√ß√£o do while. Ou seja, for√ßa a sa√≠da do la√ßo.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Aula de exerc√≠cios</span>"
    ]
  },
  {
    "objectID": "chapters/09.html#verificar-se-um-n√∫mero-√©-primo",
    "href": "chapters/09.html#verificar-se-um-n√∫mero-√©-primo",
    "title": "9¬† Aula de exerc√≠cios",
    "section": "9.3 Verificar se um n√∫mero √© primo",
    "text": "9.3 Verificar se um n√∫mero √© primo\nNo pr√≥ximo exemplo, vamos verificar se um n√∫mero √© primo, ou seja, se os seus √∫nicos divisores s√£o 1 e o pr√≥prio. A forma mais simples de se fazer isso √© procurando dividir o n√∫mero por outros. Se algum dividir, o n√∫mero n√£o √© primo.\n\nfunction verifica_primo(num :: Int64)\n    if num &lt;= 1\n        return false\n    end\n    i=2\n    # pode ser melhorado com i&lt;=num/2\n    # ou tamb√©m com i&lt;= sqrt(num): baseado no fato que um n√∫mero composto deve ter um fator menor ou igual a raiz desse n√∫mero\n    while i&lt;num\n        if num % i == 0\n            return false\n        end\n        i+=1\n    end\n    return true\nend\n\nverifica_primo (generic function with 1 method)\n\n\nAssim, como o comando break √© usado para interromper a execu√ß√£o de um la√ßo, o comando return, pode ser usado para terminar a execu√ß√£o de uma fun√ß√£o, a qualquer momento.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Aula de exerc√≠cios</span>"
    ]
  },
  {
    "objectID": "chapters/09.html#verificar-se-um-n√∫mero-√©-pal√≠ndromo",
    "href": "chapters/09.html#verificar-se-um-n√∫mero-√©-pal√≠ndromo",
    "title": "9¬† Aula de exerc√≠cios",
    "section": "9.4 Verificar se um n√∫mero √© pal√≠ndromo",
    "text": "9.4 Verificar se um n√∫mero √© pal√≠ndromo\nUm n√∫mero pal√≠ndromo √© um n√∫mero que √© sim√©trico. Ou seja, a leitura dos d√≠gitos da esquerda para a direita √© igual a leitura dos d√≠gitos na ordem inversa. Por exemplo, o n√∫mero 121 √© pal√≠ndromo, assim como o 11 e o 25677652. Os n√∫meros de um d√≠gito tamb√©m s√£o.\n\nfunction e_palindromo(n::Int64)\n    #=\n        Guarda os d√≠gitos de n que ainda devem ser invertidos\n        A vari√°vel auxiliar √© necess√°ria para que o valor de n n√£o seja, perdido, e possamos usar ele posteriormente.\n    =#\n    aux = n\n    # Guarda a invers√£o do n√∫mero n \n    n_inv = 0\n\n    #=\n        Continuamos o while enquanto ainda h√° n√∫meros a serem invertidos,\n        ou seja, enquanto aux for maior que 0.\n    =#\n    while aux &gt; 0 \n        # Coloca o √∫ltimo d√≠gito de aux na vari√°vel que guarda a invers√£o\n        resto = aux % 10\n        n_inv= n_inv * 10 + resto\n\n        # Retira o √∫ltimo d√≠gito de aux\n        aux = div(aux,10)\n    end\n\n    if n == n_inv\n        println(\"O n√∫mero $n √© pal√≠ndromo\")\n    else\n        println(\"O n√∫mero $n n√£o √© pal√≠ndromo\")\n    end \nend\n\ne_palindromo(2002)\ne_palindromo(1234)\n\nO n√∫mero 2002 √© pal√≠ndromo\nO n√∫mero 1234 n√£o √© pal√≠ndromo",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Aula de exerc√≠cios</span>"
    ]
  },
  {
    "objectID": "chapters/10.html",
    "href": "chapters/10.html",
    "title": "10¬† Revisitando a aula passada",
    "section": "",
    "text": "10.1 Aleatoreidade\nAl√©m de discutirmos o que vimos na aula passada. Nessa aula, vimos uma nova solu√ß√£o para o problema de verificar de um n√∫mero √© pal√≠ndromo.\nPara isso usamos uma t√©cnica um pouco diferente, ou seja, ao inv√©s de inverter o n√∫mero e compar√°-lo com o original. Verificamos se os seus extremos s√£o iguais.\nObserve o n√∫mero 234432, o primeiro passo seria verificar que nos extremos, mais significativo e menos significativo, temos os n√∫meros 2. Em seguida, podemos continuar com a verifica√ß√£o para o n√∫mero 3443. Se em algum momento a verifica√ß√£o falhar o n√∫mero n√£o √© pal√≠ndromo.\nSeguem os testes e o c√≥digo abaixo.\nEm julia temos a fun√ß√£o rand() que devolve um n√∫mero em ponto flutuante entre 0 e 1. Conforme os par√¢metros, podemos ter outros tipos de n√∫mero como:\nrand(Int)  # devolve um inteiro\nrand(1:10) # devolve um n√∫mero entre 1 e 10\nrand(Bool) # devolve verdadeiro ou falso\n\nfalse\nMas, antes de ver um c√≥digo com rand(). Vamos pensar em um problema da vida real. Imagine que temos que fazer um sorteio justo, e o √∫nico instrumento que possu√≠mos para o sorteio √© uma moeda viciada. Que tem como resultado muito mais faces do que coroas. D√° para usar essa moeda em um sorteio justo?\nA ideia para resolver o problema √© olhar para pares de sorteios. Ou seja, vamos ignorar sorteios onde tenhamos duas faces ou duas coroas. Nos outros, teremos uma coroa e uma face ou vice versa. As chances das duas ser√£o de 50%. Logo podemos assim, corrigir a moeda viciada.\nPara simplificar o exerc√≠cio, a moeda pode devolver 0, ou 1, correspondentes a cara ou a coroa. Observe a seguinte fun√ß√£o que simula uma moeda viciada.\nfunction sorteio()\n  if rand() &gt; 0.90\n    return 1\n  else \n    return 0\n  end\nend\n\nsorteio (generic function with 1 method)\nPode se observar que a fun√ß√£o devolve 0 na maior parte das vezes. Podemos inclusive ver isso, fazendo mil sorteios:\nfunction verificaSorteio()\n   cara = 0\n   coroa = 0\n   i = 0\n   while i &lt; 1000\n     if sorteio() == 0\n        cara = cara + 1\n     else\n        coroa = coroa + 1\n     end\n     i = i + 1\n   end\n   println(\"O n√∫mero de caras foi: \", cara,\" e de coroas foi :\", coroa)\nend\n\nverificaSorteio (generic function with 1 method)\nMas, podemos corrigir o sorteio da seguinte forma:\nfunction sorteioBom()\n   sorteio1 = sorteio()\n   sorteio2 = sorteio()\n   while sorteio1 == sorteio2 # se forem iguais, tente novamente\n     sorteio1 = sorteio()\n     sorteio2 = sorteio()\n   end\n   return sorteio1   # ao termos um diferente, podemos devolver o primeiro sorteio\nend\n\nsorteioBom (generic function with 1 method)\nPodemos usar o verificaSorteio para ver a diferen√ßa.\nfunction verificaSorteio()\n   cara = 0\n   coroa = 0\n   i = 0\n   while i &lt; 1000\n     if sorteioBom() == 0\n        cara = cara + 1\n     else\n        coroa = coroa + 1\n     end\n     i = i + 1\n   end\n   println(\"O n√∫mero de caras foi: \", cara,\" e de coroas foi :\", coroa)\nend\n\nverificaSorteio (generic function with 1 method)\nPodemos ainda aproximar o n√∫mero de Euler (ùëí), constante matem√°tica que √© a base dos logaritmos naturais, usando uma simula√ß√£o probabil√≠stica. A ideia por tr√°s desse c√≥digo √© que o n√∫mero m√©dio de tentativas necess√°rias para que a soma de n√∫meros aleat√≥rios entre 0 e 1 ultrapasse 1 se aproxima do valor de ùëí. Isso √© baseado em uma rela√ß√£o matem√°tica que conecta essa situa√ß√£o ao n√∫mero ùëí.\nfunction calculaEuler(total)\n    soma_tentativas = 0\n    for i in 1:total\n        soma = 0.0\n        tentativas = 0      \n        while soma &lt;= 1   # Continue gerando n√∫meros at√© a soma ultrapassar 1\n            soma += rand()     # Gera n√∫mero aleat√≥rio entre 0 e 1\n            tentativas += 1\n        end        \n        soma_tentativas += tentativas     # Somar o n√∫mero de tentativas necess√°rias\n    end \n    return soma_tentativas / total     # A m√©dia do n√∫mero de tentativas ser√° uma estimativa de e\nend\n\nprintln(\"Estimativa de e (1000 itera√ß√µes): \", calculaEuler(1000))\nprintln(\"Estimativa de e (100000 itera√ß√µes): \", calculaEuler(100000))\nprintln(\"Estimativa de e (100000000 itera√ß√µes): \", calculaEuler(100000000))\n\nEstimativa de e (1000 itera√ß√µes): 2.733\nEstimativa de e (100000 itera√ß√µes): 2.71502\nEstimativa de e (100000000 itera√ß√µes): 2.71837432\nPara terminar a aula vamos aplicar o m√©todo de Monte Carlo para o c√°lculo de Pi. Imaginem o primeiro quadrante, onde temos um semi-c√≠rculo de raio 1, dentro de um quadrado de lado 1. Podemos sortear valores, os que sairem dentro do c√≠rculo podem contar para a √°rea desse. Mais informa√ß√µes podem ser vistas aqui (https://pt.wikipedia.org/wiki/M%C3%A9todo_de_Monte_Carlo)\nfunction calculaPi(total)\n   noAlvo = 0\n   i = 0\n   while i &lt; total\n     x = rand() / 2.0 # gera um n√∫mero entre 0 e 0.5\n     y = rand() / 2.0\n     if sqrt(x * x + y * y) &lt;= 0.5\n       noAlvo = noAlvo + 1\n     end\n     i = i + 1\n   end\n   return 4 * (noAlvo / total)  # precisamos multiplicar para ter a √°rea de 4 quadrantes\nend \n\nprintln(calculaPi(100))\nprintln(calculaPi(1000000))\nprintln(calculaPi(1000000000))\n\n3.16\n3.142916\n3.141652384",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Revisitando a aula passada</span>"
    ]
  },
  {
    "objectID": "chapters/11.html",
    "href": "chapters/11.html",
    "title": "11¬† Entrada de dados e o come√ßo de listas",
    "section": "",
    "text": "11.1 O comando input\nNessa aula, temos dois t√≥picos principais, como fazer a entrada de dados, atrav√©s de comandos de entrada e com argumentos na linha de comando. Al√©m disso tamb√©m veremos como tratar de um tipo especial de vari√°vel, onde √© poss√≠vel, guardar mais de um valor.\nQuando queremos inserir dados, em Julia, basta colocar dados. Mas, como podemos fazer para entrar dados em um programa comum?\nPara isso temos o comando readline(), que interrompe a execu√ß√£o do programa e espera pela entrada de uma String, o que ocorre quando a tecla ‚Äúenter‚Äù √© pressionada.\nprintln(\"Digite o seu nome\")\nresposta = readline()\nprintln(\"O seu nome √©: \", resposta)\nCaso, ao rodar o programa, voc√™ digitar Maria, e pressionar a tecla enter, a resposta final do seu programa ser√° O seu nome √©: Maria.\nComo o readline() l√™ Strings, se quisermos ler n√∫meros, √© necess√°rio usar o comando parse. O comando parse de forma simples possui dois par√¢metros, o primeiro corresponde ao tipo que se quer transformar, e o segundo o valor original.\nprintln(\"Digite um inteiro\")\nvalor = parse(Int64, readline())\nprintln(\"O numero digitado foi \", valor)\nSabendo ler n√∫meros do teclado, vamos a um exerc√≠cio simples, ler uma sequ√™ncia de n√∫meros inteiros terminada por zero e devolver a sua soma.\nfunction somaVarios()\n    soma = 0.0\n    println(\"Digite um n√∫mero\")\n    n = parse(Float64, readline())\n    while  n!=0\n        soma = soma + n\n        println(\"Digite um n√∫mero\")\n        n = parse(Float64, readline())\n    end\n    println(\"A soma √©: \", soma)\nend\nObserve o seguinte exemplo que calcula os quadrados dos n√∫meros de uma lista terminada por zero.\nfunction leQ()\n  x = readline()\n  n = parse(Float64, x)\n  while n != 0\n    println(\"$n ao quadrado √© \", n * n)\n    x = readline()\n    n = parse(Float64, x)\n  end\nend\nNotem que o readline tamb√©m pode receber uma vari√°vel de arquivo para que dados sejam lidos diretamente. Mas, nesse caso temos que tomar Ocuidado para abrir (open()) e fechar (close()) o arquivo. Como abaixo:\nfunction leQ()\n    println(\"Digite um n√∫mero\")\n    f = open(\"numeros.txt\", \"r+\")\n    x = readline(f)\n    n = parse(Float64, x)\n    while n != 0\n        println(\"$n ao quadrado √© \", n * n)\n        println(\"Digite outro n√∫mero\")\n        x = readline(f)\n        n = parse(Float64, x)\n    end\n    close(f)\nend",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Entrada de dados e o come√ßo de listas</span>"
    ]
  },
  {
    "objectID": "chapters/11.html#lendo-atrav√©s-da-linha-de-comando",
    "href": "chapters/11.html#lendo-atrav√©s-da-linha-de-comando",
    "title": "11¬† Entrada de dados e o come√ßo de listas",
    "section": "11.2 Lendo atrav√©s da linha de comando",
    "text": "11.2 Lendo atrav√©s da linha de comando\nA outra forma de ler comandos √© atrav√©s da constante ARGS que √© preparada na chamada de um programa. Para entender melhor isso, vamos ver o seguinte programa.\n\nprintln(ARGS)\n\nSe a linha acima est√° no arquivo args.jl, ao chamar julia args.jl com diversos par√¢metros, teremos diversos resultados diferentes.\nPor exemplo ao chamar:\njulia args.jl 1 2 3 abc\nTeremos como resposta\n\n[\"1\", \"2\", \"3\", \"abc\"]\n\nVamos analisar um pouco melhor essa resposta observando que cada par√¢metro est√° em uma posi√ß√£o.\n\ntam = length(ARGS)\nprintln(\"O tamanho dos argumentos √©: \", tam)\nfor i in 1:tam\n    println(ARGS[i])\nend\n\nOlhando o c√≥digo acima, podemos ver que a fun√ß√£o length() devolve o n√∫mero de argumentos, ou seja, o tamanho da lista ARGS. Al√©m disso com os colchetes √© poss√≠vel acessar a cada posi√ß√£o da lista de forma individual.\nO exemplo abaixo soma os par√¢metros inteiros dados como argumentos. Ele tamb√©m ilustra uma boa pr√°tica que √©, sempre colocar o c√≥digo em m√≥dulos, no caso abaixo em fun√ß√µes:\n\nfunction SomaEntrada()\n    tam = length(ARGS)\n    s = 0\n    i = 1\n    while i &lt;= tam\n        valor = parse(Int, ARGS[i])\n        println(valor)\n        s = s + valor\n        i = i + 1\n    end\n    println(\"A soma foi: \", s)\nend\nSomaEntrada()\n\nA flexibilidade que temos ao usar listas √© enorme! Por isso, listas ou vetores, merecem um t√≥pico pr√≥prio.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Entrada de dados e o come√ßo de listas</span>"
    ]
  },
  {
    "objectID": "chapters/11.html#listas",
    "href": "chapters/11.html#listas",
    "title": "11¬† Entrada de dados e o come√ßo de listas",
    "section": "11.3 Listas",
    "text": "11.3 Listas\nVamos primeiro brincar um pouco no console.\n\nvetor = [1, 2, 3]\nprintln(vetor[1])\nprintln(length(vetor))\nvetor[2] = vetor[2] + 1\nvetor[1] = 2 * vetor[3]\nprintln(vetor)\n\n1\n3\n[6, 3, 3]\n\n\nComo disse antes, o for foi feito para manipular vetores, vamos ver umas fun√ß√µes, a primeira que imprime os elementos de um vetor um por linha.\n\nfunction imprimeVetor(v)\n    for el in v\n        println(el)\n    end\nend\n\nIsso tamb√©m pode ser feito por meio dos √≠ndices do vetor:\n\nfunction imprimeVetor(v)\n    for i in 1:lenght(v)\n        println(v[i])\n    end\nend\n\nComo cada posi√ß√£o √© independente, podemos calcular a soma dos elementos √≠mpares de um vetor\n\nfunction somaImpVetor(v)\n    soma = 0\n    for i in 1:length(v)\n        if v[i] % 2 == 1\n            soma = soma + v[i]\n        end\n    end\n    return soma\nend\n\nTamb√©m vimos em aula alguns outros exemplos, como calcular a m√©dia dos elementos em um vetor.\n\nfunction mediaV(v)\n   soma = 0.0\n   for i in v\n      soma = soma + i\n   end\n   return soma / length(v)\nend\n\nDevolver a soma dos elementos √≠mpares de um vetor\n\nfunction somaImpar(v)\n    soma = 0\n    for i in v\n        if i % 2 == 1\n            soma = soma + i\n        end\n    end\n    return soma\nend\n\nImprimir os n√∫meros divis√≠veis por 5 de um vetor.\n\nfunction imprimeDivisivelPor5(v)\n    for i in v\n        if i % 5 == 0\n            println(i)\n        end\n    end\nend\n\nCom uma pequena varia√ß√£o e usando o comando push!() podemos ver como devolver um vetor com os n√∫meros divis√≠veis por 5.\n\nfunction devolveDivisivelPor5(v)\n    x = []  # come√ßa com um vetor vazio\n    for i in v\n        if i % 5 == 0\n            push!(x, i)  # adiciona um elemento ao vetor x\n        end\n    end\n    return x\nend\n\n\n11.3.1 √Ålgebra linear e Listas\nA manipula√ß√£o de listas √© uma parte fundamental da √°lgebra linear, que estuda vetores e matrizes. Fun√ß√µes como o produto escalar de dois vetores s√£o exemplos cl√°ssicos. Abaixo temos dois exemplos de produto escalar de dois vetores. lembrado esse √© definido como a soma dos produtos de elementos em posi√ß√µes iguais.\n\nfunction dotProduct(a, b)\n    soma = 0\n    if length(a) != length(b)\n       return soma   # o produto n√£o est√° definido se os tamanhos s√£o diferentes\n    end\n    for i in 1:length(a)\n        soma = soma + a[i] * b[i]\n    end\n    return soma\nend\n\nAcima vimos que um caso especial do uso do for, consiste em fazer Ofor varias entre 1 e um tamanho (1:lenght(a))\nObservem a diferen√ßa na vers√£o abaixo:\n\nfunction dotProduct(a, b)\n    soma = 0\n    if length(a) != length(b)\n       return soma   # o produto n√£o est√° definido se os tamanhos s√£o diferentes\n    end   \n    i = 1\n    for x in a\n        soma = soma + x * b[i]\n        i = i + 1\n    end \n    return soma\nend\n\n\n\n11.3.2 Exerc√≠cio de permuta√ß√£o\nPara terminar, vamos fazer uma fun√ß√£o onde dado um vetor de inteiros de tamanho \\(n\\), verifica se esse vetor √© uma permuta√ß√£o dos n√∫meros de 1 a \\(n\\). Para isso, veremos se cada n√∫mero de 1 a \\(n\\) est√° no vetor.\nMas, sem esquecer dos testes:\n\n@testset \"Verifica Permuta√ß√£o\" begin\n    @test permuta([1,2,3])\n    @test permuta([3, 2, 1])\n    @test permuta([1])\n    @test permuta([2, 1])\n    @test permuta([4, 2, 3, 1])\n    @test !permuta([1, 1])\n    @test !permuta([1, 3])\n    @test permuta([])\nend\n\ne o c√≥digo:\n\nfunction permuta(v)\n   tam = length(v)\n   for i in 1:tam\n      if  !(i in v)\n         return false\n      end\n   end\n   return true\nend\n\nFoi usado o comando in de Julia que verifica se um elemento est√° no vetor.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Entrada de dados e o come√ßo de listas</span>"
    ]
  },
  {
    "objectID": "chapters/12.html",
    "href": "chapters/12.html",
    "title": "12¬† Exerc√≠cios com vetores",
    "section": "",
    "text": "12.1 Permuta√ß√£o\nOs vetores permitem que sejam realizados algoritmos bem mais complexos, nesse cap√≠tulo veremos algums exerc√≠cios.\nDado um vetor com inteiros, queremos verificar se esse vetor cont√©m uma permuta√ß√£o. Para isso, temos que verificar em um vetor de tamanho n, se ele cont√©m os n√∫meros de 1 a n exatamente uma vez cada 1. O vetor [3, 1, 2] √© uma permuta√ß√£o, pois tem tamanho 3 e os elementos de 1 a 3 aparecem uma vez.\nUma forma de se resolver esse problema √© por meio de um indicador de passagem. Inicialmente vamos supor que o vetor √© uma permuta√ß√£o, em seguida verificamos se todos os n√∫meros entre 1 e n est√£o no vetor. Isso pode ser feito com comando in, que verifica se um elemento pertence ao vetor.\nfunction permuta√ß√£o(l)\n    perm = true\n    tamanho = length(l)\n    i = 1\n    while i &lt;= tamanho\n        if !(i in l)\n            perm = false\n        end    \n        i += 1\n    end\n    return perm\nend\n\npermuta√ß√£o (generic function with 1 method)\nUma outra alternativa √© verificar se para cada elemento do vetor, se ele est√° entre 1 e n, e √© unico. Ou seja, verificamos se o primeiro elemento est√° entre 1 e n, e depois percorremos o vetor para ver se ele √© √∫nico. Em seguida fazemos isso para os elementos seguintes. O c√≥digo fica:\nfunction permuta√ß√£o(l)\n    perm = true\n    tamanho = length(l)\n    i = 1\n    while i &lt;= tamanho\n        if (l[i] &gt; tamanho || l[i] &lt;= 0)\n            perm = false\n        end\n        j = i +1\n        while j &lt;= tamanho\n            if l[j] == l[i]\n                perm = false\n            end\n            j += 1\n        end\n        i += 1\n    end\n    return perm\nend\n\npermuta√ß√£o (generic function with 1 method)\nUma outra alternativa √© ter um vetor auxiliar onde contamos as ocorr√™ncias de cada n√∫mero entre 1 e n. Ao final, todos os elementos desse vetor auxiliar tem que valer 1. Dessa vez, aproveitamos e j√° colocamos os testes automatizados.\nusing Test\nfunction permuta√ß√£o(l)\n    perm = true\n    tamanho = length(l)\n    aux = zeros(Int8, tamanho)\n    for i in l\n      if i &lt; 1 || i &gt; tamanho\n        perm = false\n      else\n        aux[i] += 1\n      end\n    end\n    for i in aux\n      if i != 1\n        perm = false\n      end\n    end  \n    return perm\nend\n\n@testset \"Verifica Permuta√ß√£o\" begin\n    @test permuta√ß√£o([1,2,3])\n    @test permuta√ß√£o([3, 2, 1])\n    @test permuta√ß√£o([1])\n    @test permuta√ß√£o([2, 1])\n    @test permuta√ß√£o([4, 2, 3, 1])\n    @test !permuta√ß√£o([1, 1])\n    @test !permuta√ß√£o([1, 3])\n    @test !permuta√ß√£o([4, 2, 3, -1])\n    @test !permuta√ß√£o([5, 2, 3, 1])\n    @test permuta√ß√£o([])\n    @test !permuta√ß√£o([0, 3, 3])\n    @test !permuta√ß√£o([2, 2, 2])\nend\n\nTest Summary:       | Pass  Total  Time\nVerifica Permuta√ß√£o |   12     12  0.1s\n\n\nTest.DefaultTestSet(\"Verifica Permuta√ß√£o\", Any[], 12, false, false, true, 1.737500420375648e9, 1.737500420476822e9, false, \"/Users/lucas/ws/livro-alfredo/chapters/12.qmd\")",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Exerc√≠cios com vetores</span>"
    ]
  },
  {
    "objectID": "chapters/12.html#histograma",
    "href": "chapters/12.html#histograma",
    "title": "12¬† Exerc√≠cios com vetores",
    "section": "12.2 Histograma",
    "text": "12.2 Histograma\nJ√° que vimos o exemplo anterior onde ‚Äúcontamos‚Äù o n√∫mero, podemos ir um pouco al√©m e calcular o histograma de um vetor com n√∫meros entre 1 e 10.\n\nusing Test\n\nfunction histograma(l)\n    result = [0,0,0,0,0,0,0,0,0,0]\n    i = 1\n    while i &lt;= length(l)\n        valor_atual = l[i]\n        if valor_atual &gt;= 1 && valor_atual &lt;= 10\n           result[valor_atual] += 1\n        end\n        i += 1\n    end\n    return result\nend\n\n@testset \"Verifica Histograma\" begin\n    @test [1,0,0,0,0,0,0,0,0,0] == histograma([1])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([-1])\n    @test [0,0,1,0,0,0,0,0,0,0] == histograma([3])\n    @test [0,0,0,0,0,0,0,0,0,1] == histograma([10])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([11])\n    @test [1,4,0,2,5,1,0,1,0,0] == histograma([5,6,5,4,5,5,4,2,8,2,1,2,5,2])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([])\n    end\n\nTest Summary:       | Pass  Total  Time\nVerifica Histograma |    7      7  0.0s\n\n\nTest.DefaultTestSet(\"Verifica Histograma\", Any[], 7, false, false, true, 1.737500420717199e9, 1.737500420758469e9, false, \"/Users/lucas/ws/livro-alfredo/chapters/12.qmd\")",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Exerc√≠cios com vetores</span>"
    ]
  },
  {
    "objectID": "chapters/12.html#modelando-problemas-com-o-computador",
    "href": "chapters/12.html#modelando-problemas-com-o-computador",
    "title": "12¬† Exerc√≠cios com vetores",
    "section": "12.3 Modelando problemas com o computador",
    "text": "12.3 Modelando problemas com o computador\nO computador pode ser uma ferramenta bem poderosa para a modelagem de problemas reais. Para isso vamos pegar o caso do problema dos anivers√°rios. Esse problema tamb√©m √© conhecido pelo paradoxo do anivers√°rio: Calcular a probabilidade de que em uma sala com n pessoas, pelo menos duas possuam a mesma data de anivers√°rio. Esse problema pode ser resolvido usando probabilidade, por meio da qual se descobre que se a sala tem 23 pessoas a chance de duas terem a mesma data √© de pouco mais de 50%.\nMas, tamb√©m podemos modelar esse problema computacionalmente. Para isso, o primeiro passo √© simplificar as datas, ao inv√©s de m√™s e ano, podemos codificar os dias em um n√∫mero entre 1 e 365, sendo que 1 corresponderia a primeiro de janeiro. Para resolver o problema, podemos sortear n datas, e ver se h√° alguma repeti√ß√£o, se houver encontramos duas pessoas com a mesma data.\nIsso est√° representado na fun√ß√£o experimento_niver abaixo. Mas, para saber a chance real, temos que repetr o experimento v√°rias vezes. Na fun√ß√£o main() abaixo, pedimos a quantidade de experimentos e o n√∫mero de pessoas para executar a simula√ß√£o.\n\nfunction experimento_niver(n)\n    repetiu = false\n    i = 1\n    nivers = []\n    while i &lt;= n && (repetiu == false)\n        niver = rand(1:365)\n        if niver in nivers\n            repetiu = true\n        end\n        push!(nivers, niver)\n        i += 1\n    end\n    return repetiu\nend\n\nfunction main()\n    print(\"Quantos experimentos? \")\n    quantas = readline()\n    print(\"Quantas pessoas? \")\n    npessoas = readline()\n    quantas = parse(Int64, quantas)\n    npessoas = parse(Int64, npessoas)\n    sucessos = 0\n    i = 1\n    while i &lt;= quantas\n        if experimento_niver(npessoas)\n            sucessos += 1\n        end\n        i += 1\n    end\n    println(\"A probabilidade estimada √© \", 100*sucessos/quantas, \"%\")\nend\nmain()\n\nA parte interessante √© que podemos com pequenas varia√ß√µes ter outros experimentos, como verificar se mais do que duas pessoas fazem anivers√°rio na mesma data. Para isso, abaixo, contamos o n√∫mero de repeti√ß√µes.\n\nfunction experimento_niver(n)\n    repetiu = 0\n    i = 1\n    nivers = []\n    while i &lt;= n\n        niver = rand(1:365)\n        if niver in nivers\n            repetiu += 1\n        end\n        push!(nivers, niver)\n        i += 1\n    end\n    return repetiu &gt;= 2\nend\n\nexperimento_niver (generic function with 1 method)",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Exerc√≠cios com vetores</span>"
    ]
  },
  {
    "objectID": "chapters/13.html",
    "href": "chapters/13.html",
    "title": "13¬† Modelando um problema maior",
    "section": "",
    "text": "Nessa aula vamos modelar um jogo bem conhecido, o 21, ou BlackJack. Nele os jogadores devem tentar chegar mais perto da soma de cartas 21, sem estourar. Quem chegar mais perto ganha.\nCada jogador come√ßa com duas cartas, sendo que as cartas tem o seu valor nominal, as figuras (J, Q, K), que valem 10. Al√©m disso, o √Ås, pode valer 1 ou 11. O que for mais vantajoso para o jogador.\nPara come√ßar vamos fazer uma simula√ß√£o com um baralho, ou seja 52 cartas. J√° que] para o jogo, n√£o importa o naipe da carta, vamos supor que existem quatro cartas de cada. Para isso, vamos criar duas fun√ß√µes, uma que cria um baralho e o guarda em um vetor, e uma segunda que pega uma carta do baralho. Nessa segunda fun√ß√£o temos que ‚Äúretirar‚Äù a carta do vetor. Caso j√° n√£o exista a carta do tipo desejado, temos que sortear uma nova carta.\n\nfunction criaBaralho()\n  cards = zeros(Int8, 13)\n  i = 1\n  while i &lt; 14\n    cards[i] = 4\n    i += 1\n  end\n  return cards\nend\n\nfunction pegarCarta(cards)\n  sorteio = rand(1:13)\n  while cards[sorteio] == 0\n    sorteio = rand(1:13)\n  end\n  cards[sorteio] -= 1\n  if sorteio &gt; 10  # se a carta for figura, ela vale 10\n    sorteio = 10\n  end  \n  return sorteio\nend\n\npegarCarta (generic function with 1 method)\n\n\nDe posse dessas duas fun√ß√µes, podemos criar outras que simulam o comportamento dos jogadores. Vamos usar algumas estrat√©gias simples, como o jogador que fica com as duas cartas que recebeu.\n\nfunction jogador1(cards)\n  carta1 = pegarCarta(cards)\n  carta2 = pegarCarta(cards)\n  if carta1 == 1 || carta2 == 1\n    return carta1 + carta2 + 10\n  else\n    return carta1 + carta2\n  end  \nend\n\njogador1 (generic function with 1 method)\n\n\nNotem que acima, usamos a estrat√©gia de usar o √Ås da forma mais vantajosa.\nPara os outros jogadores, vamos usar estrat√©gias mais elaboradas, ou seja o jogador fica pegando cartas enquanto n√£o chegar a um valor pr√©-determinado, como por exemplo 21, 19, 17, 15 e 13.\nComo cada jogador pode ter um n√∫mero grande de cartas e no caso dele ter um √Ås, a conta tem que ser feita da maneira mais vantajosa, vamos usar uma fun√ß√£o que recebe um vetor de cartas e calcula a soma.\n\nfunction somaCartas(c)\n  soma = 0\n  temAz = false\n  for i in c\n    soma += i\n    if c == 1 \n      temAz = true\n    end\n  end\n  if soma &lt;= 11 && temAz\n      return soma + 10\n  else \n      return soma\n  end\nend\n\nsomaCartas (generic function with 1 method)\n\n\nDe posse do soma cartas, podemos modelar os jogadores.\n\nfunction jogador2(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 21\n    push!(cartas, pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\nfunction jogador3(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 19\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\nfunction jogador4(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 17\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\n  function jogador5(cards)\n    cartas = []\n    push!(cartas, pegarCarta(cards))\n    push!(cartas, pegarCarta(cards))\n    while somaCartas(cartas) &lt; 15\n      push!(cartas,pegarCarta(cards))\n    end\n    return somaCartas(cartas)\n  end\n\nfunction jogador6(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 13\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\njogador6 (generic function with 1 method)\n\n\nAgora que temos todos os jogadores, podemos modelar uma partida. Para isso criamos um baralho e fazemos com que cada jogador siga a sua estrat√©gia\n\nfunction partida()\n  cards = criaBaralho()\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = jogador1(cards)\n  jogadores[2] = jogador2(cards)\n  jogadores[3] = jogador3(cards)\n  jogadores[4] = jogador4(cards)\n  jogadores[5] = jogador5(cards)\n  jogadores[6] = jogador6(cards)\nend\n\npartida (generic function with 1 method)\n\n\nN√£o deu tempo de continuar, ficou para a pr√≥xima aula.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Modelando um problema maior</span>"
    ]
  },
  {
    "objectID": "chapters/14.html",
    "href": "chapters/14.html",
    "title": "14¬† Continuando a modelagem",
    "section": "",
    "text": "No cap√≠tulo anterior ficamos com uma partida, mas sem a verifica√ß√£o do vencedor, ou seja o jogador com o maior valor, menor ou igual a 21. Uma decis√£o de projeto √© dizer que no caso de empate, os jogadores, com os maiores valores ganham e dividem o pr√™mio.\n\nfunction partida()\n  cards = criaBaralho()\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = jogador1(cards)\n  jogadores[2] = jogador2(cards)\n  jogadores[3] = jogador3(cards)\n  jogadores[4] = jogador4(cards)\n  jogadores[5] = jogador5(cards)\n  jogadores[6] = jogador6(cards)\n  return jogadores\nend\n\npartida (generic function with 1 method)\n\n\nLogo, a partida devolve a pontua√ß√£o de cada jogador, para podermos verificar na rotina ganhador quem ganhou.\n\nfunction ganhador(v)\n    i = 1\n    maximo = 0\n    while i &lt;= length(v)\n        if v[i] &gt; 21  # se estourou √© como se tivesse o menor valor\n            v[i] = 0\n        end\n        if v[i] &gt; maximo\n            maximo = v[i]  # encontra o vencedor\n        end\n        i = i + 1\n    end\n    result = zeros(Int64, length(v))\n    i = 1\n        while i &lt;= length(v)\n            if v[i] == maximo\n                result[i] = 1\n            end\n            i = i + 1\n        end\n    return result\nend\n\nganhador (generic function with 1 method)\n\n\nA rotinha ganhador devolve um vetor com os vencedores, com 1 na posi√ß√£o de quem ganhou e zero na posi√ß√£o dos perdedores.\nUma das vantagens de se usar um computador √© que podemos ter milhares de partidas de 21 para encontrar qual seria a melhor estrat√©gia.\n\nfunction porcentagem()\n    i = 1\n    porc = zeros(Int64, 6)\n    while i &lt; 100000\n        porc = porc + ganhador(partida())\n        i = i + 1\n    end\n    println(porc)\nend\n\nporcentagem (generic function with 1 method)\n\n\nAo simularmos o jogo 10000 vezes, podemos encontrar qual √© a melhor estrat√©gia dentre as que foram apresentadas.\nO c√≥digo acima ficou relativamente grande, e uma das coisas que podemos notar √© que h√° muita duplica√ß√£o nos c√≥digos dos Jogadores a partir do segundo. Um dos maiores problemas de c√≥digo √© a duplica√ß√£o. No caso acima, podemos evit√°-la adicionando um par√¢metro √† fun√ß√£o Jogador, de forma que esse seja o limite a ser considerado no la√ßo. A fun√ß√£o jogador2 fica assim:\n\nfunction jogador2(cards, valor)\n    cartas = []\n    push!(cartas, pegarCarta(cards))\n    push!(cartas, pegarCarta(cards))\n    while somaCartas(cartas) &lt; valor\n       push!(cartas, pegarCarta(cards))\n    end\n    return somaCartas(cartas)\nend\n\njogador2 (generic function with 1 method)\n\n\nComo a fun√ß√£o tem um par√¢metro novo, temos que acertar a partida. Mas, agora podemos usar todos os valores.\n\nfunction partida()\n   cards = criaBaralho()\n   jogadores = zeros(Int8, 6)\n   jogadores[1] = jogador1(cards)\n   jogadores[2] = jogador2(cards, 21)\n   jogadores[3] = jogador2(cards, 20)\n   jogadores[4] = jogador2(cards, 19)\n   jogadores[5] = jogador2(cards, 18)\n   jogadores[6] = jogador2(cards, 17)\n   return jogadores\nend\n\npartida (generic function with 1 method)\n\n\nNotem que n√£o h√° mudan√ßa na fun√ß√£o ganhador, que continua funcionando.\nPara terminar, podemos ter agora uma vers√£o interativa que permite que um jogador humano jogue com o computador.\n\nfunction partidaComHumano()\n    cards = criaBaralho()\n    humano = []\n    computador = jogador2(cards, 19)\n    push!(humano, pegarCarta(cards))\n    push!(humano, pegarCarta(cards))\n    println(\"O humano tem \", humano, \" e soma \", somaCartas(humano))\n    println(\"O humano quer mais cartas (S/N)?\")\n    resp = readline()\n    while resp == \"S\" || resp == \"s\"\n         push!(humano, pegarCarta(cards))\n         println(\"O computador tem \", computador, \" e soma \", somaCartas(computador))\n         println(\"O humano tem \", humano, \" e soma \", somaCartas(humano))\n         println(\"O humano quer mais cartas (S/N)?\")\n         resp = readline()\n    end\n    println(\"O computador tem \", computador, \" e soma \", somaCartas(computador))\n    if somaCartas(computador) &lt;= 21 && somaCartas(humano) &lt;= 21\n         if somaCartas(computador) &gt; somaCartas(humano)\n             println(\"Humano Perdeu\")\n         elseif somaCartas(computador) == somaCartas(humano)\n             println(\"Empate\")\n         else\n             println(\"Humano ganhou\")\n         end\n    elseif somaCartas(computador) &gt; 21 && somaCartas(humano) &gt; 21\n         println(\"os dois perderam\")\n    elseif somaCartas(computador) &gt; 21\n         println(\"Humano ganhou\")\n    else\n         println(\"Computador ganhou\")\n    end\nend\n\npartidaComHumano (generic function with 1 method)",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Continuando a modelagem</span>"
    ]
  },
  {
    "objectID": "chapters/15.html",
    "href": "chapters/15.html",
    "title": "15¬† Boas pr√°ticas",
    "section": "",
    "text": "15.1 Uso de contratos\nVamos come√ßar apresentando 3 boas pr√°ticas de programa√ß√£o. Na verdade h√° uma √°rea que cuida de desenvolvimento de software, a Engenharia de Software. Vamos a elas:\nSempre que poss√≠vel o c√≥digo deve ser modular, ou seja estar repartido em arquivos e ou fun√ß√µes. Cada tipo de fun√ß√£o deve deixar claro quais s√£o os seus par√¢metros e o que ela devolve. Isso pode ser feito usando tipos.\nfunction fatorial(n::Int64)::Int64\n    if n &lt; 2 \n        return 1\n    else  \n        return n * fatorial(n - 1)\n    end\nend\n\nfatorial (generic function with 1 method)\nCom isso, fica claro o que a fun√ß√£o recebe e devolve, e se for enviado um tipo diferente do esperado, temos em erro imediato.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Boas pr√°ticas</span>"
    ]
  },
  {
    "objectID": "chapters/15.html#uso-de-contratos",
    "href": "chapters/15.html#uso-de-contratos",
    "title": "15¬† Boas pr√°ticas",
    "section": "",
    "text": "15.1.1 Boa pr√°tica 1: Use tipos",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Boas pr√°ticas</span>"
    ]
  },
  {
    "objectID": "chapters/15.html#testes-automatizados",
    "href": "chapters/15.html#testes-automatizados",
    "title": "15¬† Boas pr√°ticas",
    "section": "15.2 Testes automatizados",
    "text": "15.2 Testes automatizados\nPara evitar que apare√ßam erros, ou os populates bugs, uma forma eficaz √© escrever c√≥digo que verifica o funcionamento do c√≥digo. Se isso for feito de forma autom√°tica, temos os testes automatizados.\n\nusing Test\nfunction testaFat()\n  @test fatorial(3) == 6\n  @test fatorial(5) == 120\n  @test fatorial(1) == 1\n  @test fatorial(0) == 1\n  @test fatorial(4) == 24\nend\n\ntestaFat (generic function with 1 method)\n\n\n\n15.2.1 Boa pr√°tica 2: Sempre que poss√≠vel fa√ßa testes",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Boas pr√°ticas</span>"
    ]
  },
  {
    "objectID": "chapters/15.html#escreva-c√≥digo-para-humanos-n√£o-para-computadores",
    "href": "chapters/15.html#escreva-c√≥digo-para-humanos-n√£o-para-computadores",
    "title": "15¬† Boas pr√°ticas",
    "section": "15.3 Escreva c√≥digo para humanos, n√£o para computadores",
    "text": "15.3 Escreva c√≥digo para humanos, n√£o para computadores\nApesar dos computadores serem capazes de ler c√≥digo nem sempre bem formatado, √© bem dif√≠cil para humanos lerem c√≥digo de forma n√£o padr√£o. Por isso algumas dicas importantes s√£o:\n\nUse identa√ß√£o. Com isso, os blocos ficam bem claros e √© f√°cil identificar os la√ßos, blocos de if e corpos de fun√ß√£o;\nEscolha bem o nome das vari√°veis e fun√ß√µes, isso ajuda muito quem for ler o c√≥digo\nSempre que voc√™ identificar uma possibilidade de melhoria no c√≥digo, implemente. Ainda melhor se voc√™ tiver testes automatizados, para verificar que a melhoria n√£o quebrou o c√≥digo.\n\n\n15.3.1 Boa pr√°tica 3: Escreva c√≥digo para que outros leiam",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Boas pr√°ticas</span>"
    ]
  },
  {
    "objectID": "chapters/15.html#aplicando-as-boas-pr√°ticas",
    "href": "chapters/15.html#aplicando-as-boas-pr√°ticas",
    "title": "15¬† Boas pr√°ticas",
    "section": "15.4 Aplicando as boas pr√°ticas",
    "text": "15.4 Aplicando as boas pr√°ticas\nVamos agora resolver o seguinte problema, aplicando as pr√°ticas acima. Dada um vetor com n√∫meros reais, determinar os n√∫meros que est√£o no vetor e o n√∫mero de vezes que cada um deles ocorre na mesma.\nAo analizar o problema, vemos que temos como entrada um vetor de n√∫mero reais, que pode conter repeti√ß√µes. Para determinar os n√∫meros que est√£o no vetor, podemos usar um outro vetor de sa√≠da. Sendo que o de entrada e o de sa√≠da devem ser do tipo Float64. Al√©m disso, para o vetor que fornece a quantidade de n√∫meros temos um vetor de inteiros. De posse disso, j√° temos a assinatura da fun√ß√£o.\n\nfunction contHist(v::Vector{Float64}, el::Vector{Float64}, qtd::Vector{Int64})\nend\n\ncontHist (generic function with 1 method)\n\n\nDe posse dessa assinatura, j√° podemos escrever os testes.\n\nfunction verifica(v::Vector{Float64}, elementos::Vector{Float64}, \n     quant::Vector{Int64})\n     el = Float64[]\n     quan = Int64[]\n     contHist(v, el, quan)\n     if el == elementos && quan == quant\n        return true\n     else\n        return false\n     end\nend\n\nfunction testaLista()\n  @test verifica([1.3, 1.2, 0.0, 1.3], [1.3, 1.2, 0.0], [2, 1, 1])\n  @test verifica([1.0, 1.0, 1.0, 1.0], [1.0], [4])\n  @test verifica([8.3], [8.3], [1])\n  @test verifica([3.14, 2.78, 2.78], [3.14, 2.78], [1, 2])\nend\n\ntestaLista (generic function with 1 method)\n\n\nFinalmente, podemos escrever o c√≥digo. A idea para escrever a solu√ß√£o √© simples, vamos percorrer o vetor de entrada. Para cada elemento, temos duas possibilidades, se ele n√£o tiver aparecido antes, temos que adicionar o n√∫mero ao vetor sa√≠da e marcar 1 ocorr√™ncia. Se j√° apareceu, basta incrementar o n√∫mero de ocorr√™ncias.\n\nfunction contHist(v::Vector{Float64}, el::Vector{Float64}, qtd::Vector{Int64})\n    for a in v\n        if a in el\n            i = 1\n            while el[i] != a\n               i += 1\n            end\n            qtd[i] += 1\n        else\n            push!(el, a)\n            push!(qtd, 1)\n        end\n    end\nend\n\ncontHist (generic function with 1 method)",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Boas pr√°ticas</span>"
    ]
  },
  {
    "objectID": "chapters/16.html",
    "href": "chapters/16.html",
    "title": "16¬† Indo al√©m de uma dimens√£o (Matrizes)",
    "section": "",
    "text": "At√© o momento trabalhamos com estruturas com mais de uma dimens√£o, mas sem olharmos muito bem o seu tipo. Nessa aula vamos procurar entender as diferen√ßas entre elas e como isso pode ser usado ao nosso favor.\nVamos come√ßar com as listas:\n\nv = [1, 2, 3]\ntypeof(v)\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\nO tipo devolvido √©: Vector{Int64} (alias for Array{Int64, 1}). No caso isso significa que v √© um vetor de inteiros, ou um array de uma dimens√£o. Da mesma forma\n\nv = zeros(Int64, 3)\ntypeof(v)\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\nMas, vetores podem ser mais flex√≠veis, como por exemplo abaixo:\n\nv = [1, 2.0, \"tr√™s\"]\ntypeof(v)\n\nVector{Any} (alias for Array{Any, 1})\n\n\nNesse caso o tipo de vetor, deixa de ser de inteiros e passa a ser ‚ÄúAny‚Äù, ou seja Vector{Any} (alias for Array{Any, 1}).\nMais ainda, imaginem a seguinte situa√ß√£o:\n\na = [1, 2, 3]\npush!(v, a)\ntypeof(v)\n\nVector{Any} (alias for Array{Any, 1})\n\n\nNesse caso, o vetor continua sendo do tipo Any, mas na quarta posi√ß√£o temos um vetor com tr√™s inteiros. Com isso podemos ver que as estruturas de vetores podem ser bem flex√≠veis. Mas, apesar disso, quando temos estruturas de tipos diferentes, com muita flexibilidade, geralmente h√° alguma penalidade de uso, geralmente no desempenho.\nPor outro lado, podemos ter estruturas com mais de uma dimens√£o, no caso elas s√£o denominadas matrizes. Elas podem ser criadas com a fun√ß√£o zeros que j√° usamos acima.\n\nm = zeros(Int64, 3, 2)\ntypeof(m)\n\nMatrix{Int64} (alias for Array{Int64, 2})\n\n\nAcima foi criada uma matriz de duas dimens√µes com 3 linhas e duas colunas. Seus elementos podem se acessados como em um vetor, mas agora com dois ind√≠ces.\n\nm[1, 2]  = 10\n\n10\n\n\n\nfunction imprime(m::Array{Int64,2})\n    println(m)\nend\n\nimprime (generic function with 1 method)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    println(m[1])\n    println(m[2])\nend\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    for i in m\n        println(i)\n    end\n end\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    for i in m\n        for j in m[i]\n            println(j,\"  \")\n        end   \n    end\nend\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    for i in m\n        print(\"|\")\n        for j in i\n            print(j,\"  \")\n        end\n        println(\"|\")   \n    end\nend\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprimeMatriz(m::Matrix{Int64})\n    println(m)\nend\n\nimprimeMatriz (generic function with 1 method)\n\n\n\nfunction imprimeMatriz(m::Matrix{Int64})\n    i = 1\n    while i &lt; size(m)[1]\n        println(m[1])\n        i += 1\n    end\nend\n\nimprimeMatriz (generic function with 1 method)\n\n\n\nfunction imprimeMatriz(m::Matrix{Int64})\n    i = 1\n    while i &lt; size(m)[1]\n        j = 1\n        while j &lt; size(m)[2]\n            print(m[i, j], \" \")\n            j += 1\n        end\n        println()   \n        i += 1\n    end\nend\n\nimprimeMatriz (generic function with 1 method)\n\n\n\nfunction preencheMatriz(m::Matrix{Int64})\n    i = 1\n    while i &lt;= length(m)\n        m[i] = rand(Int) % 10\n        i += 1\n    end\nend\n\npreencheMatriz (generic function with 1 method)\n\n\n\nfunction criaIdentidate(tam::Int64)\n    m = zeros(Int64, tam, tam)\n    i = 1\n    while i &lt;= tam\n        m[i, i] = 1\n    end\n    return m  \nend\n\ncriaIdentidate (generic function with 1 method)\n\n\nOpera√ß√µes diretas com matrizes tipo +, - e *",
    "crumbs": [
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Indo al√©m de uma dimens√£o (Matrizes)</span>"
    ]
  },
  {
    "objectID": "chapters/17.html",
    "href": "chapters/17.html",
    "title": "17¬† Aula de exerc√≠cios sobre Strings",
    "section": "",
    "text": "17.1 Concatena√ß√£o de letras\nNesta aula, vamos explorar fun√ß√µes que manipulam strings e criar testes para verificar sua corre√ß√£o. Em algumas fun√ß√µes, vamos notar que h√° diversas formas de se obter o mesmo resultado\nA primeira fun√ß√£o concatena concatena as primeiras duas e as √∫ltimas duas letras de uma string.\nfunction concatena(s::String)::String\n    if length(s) &lt; 2\n        return \"Erro: tamanho da string menor do que 2\"\n    end\n    resposta = s[1:2]*s[end-1:end]\n    return resposta\nend\n\nconcatena (generic function with 1 method)\nAwui utulizamos s[1:2] para obter as duas primeiras letras de s, que √© uma forma mais concisa de acessar mais de um √≠ndice de um objeto. Alternativamente, poder√≠amos acessar esses dois √≠ndices separadamente com o comando s[1]*s[2].\nPara verificar se a fun√ß√£o est√° funcionando corretamente, podemos utilizar o seguinte teste:\nusing Test\n\nfunction testeConcatena()\n  @test concatena(\"Ola Bom Dia\") == \"Olia\"\n  @test concatena(\"oi\") == \"oioi\"\n  @test concatena(\"tre\") == \"trre\"\n  @test concatena(\"a\") == \"Erro: tamanho da string menor do que 2\"\n  @test concatena(\"a123\") == \"a123\"\nend\n\ntesteConcatena (generic function with 1 method)",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/17.html#invers√£o-de-string",
    "href": "chapters/17.html#invers√£o-de-string",
    "title": "17¬† Aula de exerc√≠cios sobre Strings",
    "section": "17.2 Invers√£o de String",
    "text": "17.2 Invers√£o de String\nDevemos criar uma fun√ß√£o que interte uma string, retornando os caracteres na ordem reversa.\n\nfunction inverte(s::String)::String\n    # Inicializamos uma string vazia\n    inversa=\"\"\n\n    # Intervalo de lenght(s) at√© 1, a passos de -1\n    for i in length(s):-1:1\n        # Concatena cada caractere na ordem inversa\n        inversa*=s[i]\n    end\n\n    return inversa\nend\n\ninverte (generic function with 1 method)\n\n\nPara obter o resultado que desejamos, fazemos um la√ßo for que itera do √∫ltimo √≠ndice da string, representado por length(s), at√© o primeiro, concatenando os caracteres nessa ordem na string de retorno. O la√ßo √© configurado para decrementar o √≠ndice a cada itera√ß√£o, especificando -1 como passo. Isso nos permite acessar cada caractere da string de tr√°s para frente. E em cada itera√ß√£o, concatenamos o caractere atual, s[i], √† string inversa. Dessa forma, os caracteres s√£o adicionados na ordem inversa.\nAgora podemos criar uma fun√ß√£o de teste para verificar o funcionamento da nossa fun√ß√£o inverte.\n\nusing Test\n\nfunction testeInverte()\n  @test inverte(\"123\") == \"321\"\n  @test inverte(\"x\") == \"x\"\n  @test inverte(\"SOS\") == \"SOS\"\n  @test inverte(\"tres\") == \"sert\"\nend\n\ntesteInverte (generic function with 1 method)\n\n\n\n17.2.1 Fun√ß√£o reverse\n√â interessante notar que Julia j√° fornece uma fun√ß√£o chamada reverse, que pode ser utilizada para inverter tanto vetores quanto strings. Por exemplo:\n\nreversa = reverse(\"exemplo\")\n\n\"olpmexe\"\n\n\nNeste exemplo, a fun√ß√£o reverse recebe como par√¢metro apenas o objeto a ser invertido, mas no caso de vetores, podemos ainda informar exatamente o intervalo que desejamos que seja invertido.\n\nvetor = [1, 2, 3, 4, 5]\nreversa = reverse(vetor, 2, 4)\n\n5-element Vector{Int64}:\n 1\n 4\n 3\n 2\n 5",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/17.html#modifica√ß√£o-de-string",
    "href": "chapters/17.html#modifica√ß√£o-de-string",
    "title": "17¬† Aula de exerc√≠cios sobre Strings",
    "section": "17.3 Modifica√ß√£o de String",
    "text": "17.3 Modifica√ß√£o de String\nA terceira fun√ß√£o modifica altera uma string que termina com ‚Äúing‚Äù para adicionar ‚Äúly‚Äù ou, caso contr√°rio, adiciona ‚Äúing‚Äù.\n\nfunction modifica(s::String)::String\n    if length(s) &lt; 3\n        return \"Erro: tamanho da string menor do que 3\"\n    end\n    \n    if s[end-2:end] == \"ing\"\n        s = s*\"ly\"\n    else    \n        s = s*\"ing\"                \n    end\n\n\n    return s\nend\n\nmodifica (generic function with 1 method)\n\n\nNeste exemplo, verificamos manualmente os √∫ltimos tr√™s caracteres da string s. No entanto, Julia oferece uma fun√ß√£o mais pr√°tica e leg√≠vel chamada endswith, que podemos usar para simplificar essa verifica√ß√£o.\n\nfunction modifica(s::String)::String\n    if length(s) &lt; 3\n        return \"Erro: tamanho da string menor do que 3\"\n    end\n    \n    if endswith(s, \"ing\")\n        s = s*\"ly\"\n    else    \n        s = s*\"ing\"                \n    end\n\n    return s\nend\n\nmodifica (generic function with 1 method)\n\n\nVamos ent√£o escrever o teste que verifica o correto funcionamento das fun√ß√µes anteriores\n\nusing Test\nfunction testaModifica()\n  @test modifica(\"doing\") == \"doingly\"\n  @test modifica(\"sing\") == \"singly\"\n  @test modifica(\"run\") == \"runing\"\n  @test modifica(\"talk\") == \"talking\"\nend\n\ntestaModifica (generic function with 1 method)",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/17.html#rearranjo-de-letras",
    "href": "chapters/17.html#rearranjo-de-letras",
    "title": "17¬† Aula de exerc√≠cios sobre Strings",
    "section": "17.4 Rearranjo de letras",
    "text": "17.4 Rearranjo de letras\nA segunda fun√ß√£o rearranja recebe uma string e devolve uma string que cont√©m as letras min√∫sculas primeiro, seguidas pelas letras mai√∫sculas.\nPodemos verificar se uma letra √© mai√∫scula ou min√∫scula usando a tabela ASCII, que codifica caracteres em n√∫meros inteiros. Na tabela, as letras mai√∫sculas est√£o no intervalo de 65 a 90, e as letras min√∫sculas no intervalo de 97 a 122.\nPara saber mais sobre a tabela ASCII voc√™ pode acessar essa p√°gina.\n\nfunction rearranja(s::String)::String\n    maiusculos=\"\"\n    minusculos=\"\"\n\n    for i in 1:length(s)\n        if Int(s[i]) &gt;= 65 && Int(s[i]) &lt;= 90 \n            maiusculos = maiusculos*s[i]\n        elseif Int(s[i]) &gt;= 97 && Int(s[i]) &lt;= 122\n            minusculos = minusculos*s[i]\n        end \n    end\n\n    return minusculos*maiusculos\n     \nend\n\nrearranja (generic function with 1 method)\n\n\nUma abordagem mais leg√≠vel √© utilizar as fun√ß√µes islowercase e isuppercase, que verificam se uma letra √© min√∫scula ou mai√∫scula, respectivamente.\n\nfunction rearranja(s::String)::String\n    maiusculos=\"\"\n    minusculos=\"\"\n\n    for i in 1:length(s)\n        if isuppercase(s[i]) \n            maiusculos = maiusculos*s[i]\n        elseif islowercase(s[i])\n            minusculos = minusculos*s[i]\n        end \n    end\n\n    return minusculos*maiusculos\n     \nend\n\nrearranja (generic function with 1 method)\n\n\nPodemos ent√£o escrever o teste para nossas fun√ß√µes.\n\nusing Test\n\nfunction testaRearranja()\n  @test rearranja1(\"PaRaLelO\") == \"aaelPRLO\"\n  @test rearranja1(\"ELEfantE\") == \"fantELEE\"\n  @test rearranja1(\"Ol√°\") == \"lO\"\n  @test rearranja1(\"13La2\") == \"aL\"\n  @test rearranja2(\"PaRaLelO\") == \"aaelPRLO\"\n  @test rearranja2(\"ELEfantE\") == \"fantELEE\"\n  @test rearranja2(\"Ol√°\") == \"l√°O\"\n  @test rearranja2(\"13La2\") == \"aL\"\nend\n\ntestaRearranja (generic function with 1 method)",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/17.html#encontrar-a-maior-palavra",
    "href": "chapters/17.html#encontrar-a-maior-palavra",
    "title": "17¬† Aula de exerc√≠cios sobre Strings",
    "section": "17.5 Encontrar a maior palavra",
    "text": "17.5 Encontrar a maior palavra\nNossa √∫ltima fun√ß√£o deve receber uma lista de palavras e retornar a maior delas, junto de seu tamanho.\n\nfunction maior_palavra(vetor::Vector{String})\n    # Inicialmente, a maoior palavra que encontramos √© uma string vazia\n    maior_palavra = \"\"\n    maior_tamanho = 0\n\n    for palavra in vetor\n        #  Verifica se a palavra atual √© maior que a maior encontrada at√© agora\n        if length(palavra) &gt; maior_tamanho \n            maior_palavra = palavra\n            maior_tamanho = length(palavra)\n        end\n    end\n\n    return maior_palavra, maior_tamanho\n\nend\n\nmaior_palavra (generic function with 1 method)\n\n\nApesar de parecer correto, esse c√≥digo n√£o lida com o caso de haver mais de uma palavra com o maior tamanho. Como por exemplo:\n\nvetor = [\"boa\", \"bem\", \"oi\"]\nmaior_palavra(vetor)\n\n(\"boa\", 3)\n\n\nNesse caso, apenas a palavra ‚Äúboa‚Äù ser√° retornada, mesmo que ‚Äúbem‚Äù tenha o mesmo tamanho. Para consertar a fun√ß√£o devemos alterar a vari√°vel em que guardamos a maior palavra, para que possamos armazenar mais de uma palavra, para isso vamos usar um vetor de strings.\n\nfunction maiores_palavras(vetor::Vector{String})\n    maiores_palavras = String[]\n    maior_tamanho = 0\n\n    for palavra in vetor\n        # Se a palavra √© maior do que o maior tamanho salvo, \n        # ent√£o todas as palavras que est√£o no vetor maior_palavra s√£o menores do que a palavra atual\n        if length(palavra) &gt; maior_tamanho \n            # Limpa o vetor e salva a palavra atual\n            maiores_palavras = String[]\n            push!(maiores_palavras, palavra)\n            maior_tamanho = length(palavra)\n\n        # Se √© igual ao tamanho salvo, ent√£o √© do mesmo tamanho que as palavras j√° salvas no vetor maiores_palavras,\n        # apenas damos push na palavra atual\n        elseif length(palavra) == maior_tamanho\n            push!(maiores_palavras, palavra) \n        end\n    end\n\n    return maiores_palavras, maior_tamanho\n\nend\n\nmaiores_palavras (generic function with 1 method)\n\n\nAssim podemos escrever testes para esta √∫ltima fun√ß√£o .\n\nusing Test\n\nfunction testeMaioresPalavras()\n    vetor1 = [\"gato\", \"elefante\", \"cachorro\"]\n    @test maiores_palavras(vetor1) == ([\"elefante\", \"cachorro\"], 8)  \n    \n    vetor2 = [\"a\", \"ab\", \"abc\"]\n    @test maiores_palavras(vetor2) == ([\"abc\"], 3)        \n    \n    vetor3 = [\"bem\", \"boa\", \"bom\", \"oi\"]\n    @test maiores_palavras(vetor3) == ([\"bem\", \"boa\", \"bom\"], 3)       \n\n    vetor4 = [\"\", \" \", \"teste\"]\n    @test maiores_palavras(vetor4) == ([\"teste\"], 5)      \n\n    vetor5 = String[]\n    @test maiores_palavras(vetor5) == ([], 0)              \n\n    vetor6 = [\"a\", \"ab\", \"abc\", \"xyz\", \"xy\"]\n    @test maiores_palavras(vetor6) == ([\"abc\", \"xyz\"], 3)  \nend\n\ntesteMaioresPalavras (generic function with 1 method)",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/17.html#retorno-de-m√∫ltiplos-valores",
    "href": "chapters/17.html#retorno-de-m√∫ltiplos-valores",
    "title": "17¬† Aula de exerc√≠cios sobre Strings",
    "section": "17.6 Retorno de m√∫ltiplos valores",
    "text": "17.6 Retorno de m√∫ltiplos valores\nComo visto no exerc√≠cio anterior, Julia permite que uma fun√ß√£o retorne m√∫ltiplos valores. Isso permite que voc√™ envie mais de um resultado ao chamar uma fun√ß√£o, tornando o c√≥digo mais conciso e f√°cil de entender. Essa funcionalidade √© especialmente √∫til em situa√ß√µes onde voc√™ precisa de mais de um resultado, como em opera√ß√µes matem√°ticas, decomposi√ß√µes, ou processamento de dados.\nPara retornar m√∫ltiplos valores em Julia, voc√™ pode simplesmente separ√°-los por v√≠rgulas. Aqui est√° um exemplo simples:\n\nfunction troca(a,b)\n    aux = a\n    a = b\n    b = aux\n\n    return a, b\nend\n\ntroca (generic function with 1 method)\n\n\nAo chamar essa fun√ß√£o, voc√™ pode capturar os m√∫ltiplos valores retornados em vari√°veis separadas:\n\na, b = troca(1, 10)\n\n(10, 1)",
    "crumbs": [
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "agradecimentos.html",
    "href": "agradecimentos.html",
    "title": "Agradecimentos",
    "section": "",
    "text": "Diversas pessoas contribu√≠ram, direta ou indiretamente, para a realiza√ß√£o deste livro.\nO autor principal √© o Professor Alfredo Goldman. A revis√£o do texto e o suporte t√©cnico ficaram a cargo de Lucas de Sousa Rosa, seu orientando de doutorado. Agradecemos, em especial, a Beatriz Viana Costa, que colaborou na reda√ß√£o de alguns cap√≠tulos. Agradecemos tamb√©m os alunos da disciplina MAC0115 (Introdu√ß√£o √† Computa√ß√£o para Ci√™ncias Exatas e Tecnologia), turma de 2024, por suas contribui√ß√µes na revis√£o do conte√∫do.",
    "crumbs": [
      "Agradecimentos"
    ]
  }
]