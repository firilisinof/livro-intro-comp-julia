[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Uma Introdução à Computação com Julia",
    "section": "",
    "text": "Página Inicial\nSeja bem-vindo(a) ao livro “Uma Introdução à Computação com Julia”. Este livro reúne as notas de aula da disciplina MAC0115 - Introdução à Computação para Ciências Exatas e Tecnologia. Com linguagem simples e objetiva, o livro apresenta os principais conceitos de programação, complementados por exemplos práticos de código.\nEsta disciplina visa introduzir os fundamentos da computação através de um percurso histórico até conceitos práticos de programação utilizando a linguagem Julia. Cobre algoritmos, arquitetura de computadores, linguagens algorítmicas (com expressões, comandos, estruturas de dados e funções), metodologias de desenvolvimento e boas práticas de programação, além de proporcionar uma extensa prática de programação e depuração, formando uma base técnica completa para iniciantes.\nO livro está sendo atualizado juntamente com a disciplina. Podem ocorrer mudanças na ordem e nos exemplos, mas nada que afete o conteúdo ministrado. Não se preocupe se algo não estiver exatamente onde você esperava encontrar.",
    "crumbs": [
      "Página Inicial"
    ]
  },
  {
    "objectID": "agradecimentos.html",
    "href": "agradecimentos.html",
    "title": "Agradecimentos",
    "section": "",
    "text": "Diversas pessoas contribuíram, direta ou indiretamente, para a realização deste livro.\nO autor principal é o Professor Alfredo Goldman. A revisão do texto e o suporte técnico ficaram a cargo de Lucas de Sousa Rosa, seu orientando de doutorado. Agradecemos, em especial, a Beatriz Viana Costa, que colaborou na redação de alguns capítulos. Agradecemos também os alunos da disciplina MAC0115 (Introdução à Computação para Ciências Exatas e Tecnologia), turma de 2024, por suas contribuições na revisão do conteúdo.",
    "crumbs": [
      "Agradecimentos"
    ]
  },
  {
    "objectID": "chapters/01-evolucao-computacao.html",
    "href": "chapters/01-evolucao-computacao.html",
    "title": "1  Uma Breve Apresentação da História dos Computadores e Linguagens de Programação",
    "section": "",
    "text": "1.1 Motivação\nMas, afinal, o que é um computador? Precisamos mesmo saber a resposta para começar a programar? Na verdade, não. Porém, entender como um computador funciona nos torna bons programadores. Definir o que é um computador pode ser mais complicado do que parece. Veremos que a ideia de “computador” mudou muito ao longo da história, sempre ligada à necessidade de contar. Antes de mergulhar na história, vamos explorar diferentes respostas para essa pergunta.\nLogo no começo das aulas de 2025, na matéria MAC115 - Introdução à Computação para Ciências Exatas e Tecnologia, fizemos uma pergunta simples aos alunos: “O que é um computador?”. Anotamos as respostas (ver Apêndice A) e apesar de algumas respostas engraçadas, como “um robô que vai controlar os humanos um dia”, notamos que a maioria dos alunos pensava em coisas parecidas:\nEssas ideias mostram um pouco do que um computador faz, mas não explicam tudo o que ele é.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uma Breve Apresentação da História dos Computadores e Linguagens de Programação</span>"
    ]
  },
  {
    "objectID": "chapters/01-evolucao-computacao.html#motivação",
    "href": "chapters/01-evolucao-computacao.html#motivação",
    "title": "1  Uma Breve Apresentação da História dos Computadores e Linguagens de Programação",
    "section": "",
    "text": "Um computador é um objeto físico; uma máquina ou dispositivo.\nEle é capaz de processar informações ou dados.\nÉ como uma calculadora, só que mais moderna.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uma Breve Apresentação da História dos Computadores e Linguagens de Programação</span>"
    ]
  },
  {
    "objectID": "chapters/01-evolucao-computacao.html#computadores-precisam-existir",
    "href": "chapters/01-evolucao-computacao.html#computadores-precisam-existir",
    "title": "1  Uma Breve Apresentação da História dos Computadores e Linguagens de Programação",
    "section": "1.2 Computadores Precisam Existir?",
    "text": "1.2 Computadores Precisam Existir?\nO Professor Douglas Hartree (1897–1958), no seu livro “Calculating instruments and machines”, diz que computadores podem ser vistos de dois ângulos: anatômico (do que são feitos) e fisiológico (como funcionam). Tentar definir um computador pelas suas partes não seria suficiente, já que as peças dos computadores mudaram muito ao longo dos anos, então usar a anatomia para defini-los não funcionaria.\nNa mesma época, o Professor Arthur L. Samuel propõe uma definição funcional do que é um computador. Segundo Samuel, um computador é “um dispositivo de processamento de informações ou dados que aceita dados em uma forma e os entrega em uma forma alterada”. Esta concepção técnica concorda com o que os alunos pensam. No entanto, essa definição nos leva a um questionamento mais profundo: será que computadores precisam necessariamente existir como dispositivos ou máquinas físicas, ou podemos conceber computação para além do aspecto material?\nSe perguntássemos para uma pessoa na rua o que ela acha que é um computador, é bem provável que ela diria que é uma “máquina” ou um “dispositivo”. De fato, nas respostas que coletamos, essa ideia aparece com frequência. No entanto, os computadores modernos foram criados a partir de um modelo matemático abstrato, chamado Máquina de Turing.\nQuando criança, aos 11 anos, Alan Mathison Turing escreveu uma carta para seus pais, Julius Mathison Turing e Ethel Sara Stoney Turing, contando sua ideia de como fazer uma máquina de escrever. Alan Turing não inventou a máquina de escrever, mas usou essa ideia para criar a Máquina de Turing: um modelo matemático de computação que manipula símbolos numa fita infinita, seguindo regras bem definidas. Esse modelo deu origem aos computadores modernos que, segundo John A. Robinson, nada mais são do que “manifestações físicas de uma mesma abstração lógica: a máquina universal de Turing.” Então, não. Computadores não precisam existir.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uma Breve Apresentação da História dos Computadores e Linguagens de Programação</span>"
    ]
  },
  {
    "objectID": "chapters/01-evolucao-computacao.html#ábacos-máquinas-de-calcular-e-quase-computadores",
    "href": "chapters/01-evolucao-computacao.html#ábacos-máquinas-de-calcular-e-quase-computadores",
    "title": "1  Uma Breve Apresentação da História dos Computadores e Linguagens de Programação",
    "section": "1.3 Ábacos, Máquinas de Calcular e Quase-Computadores",
    "text": "1.3 Ábacos, Máquinas de Calcular e Quase-Computadores\nÉ aqui que a gente começa a falar da história da computação. Nós, humanos, somos muito criativos. Estamos sempre criando ferramentas para nos ajudar. Existem evidências arqueológicas que sugerem que os humanos praticam a contagem há pelo menos 50.000 anos. A contagem era usada por povos antigos para controlar dados sociais e econômicos, como o número de pessoas no grupo, animais, propriedades ou dívidas. Então, não é surpresa que os humanos tenham inventado ferramentas para ajudar nesse processo. Em 2700–2300 AC, os humanos criaram o ábaco: uma ferramenta para fazer contas mais rápido.\nAo longo dos séculos, outras ferramentas foram criadas para ajudar nisso. Um exemplo é a régua de cálculo, do século XVII, que fazia a mesma coisa que o ábaco, mas usando propriedades da funções logarítmicas. Os primeiros computadores eram como versões mais modernas dessas ferramentas, ou seja, máquinas de calcular. O engenho diferencial (1820) de Charles Babbage, uma máquina idealizada, mas não construída, é um exemplo de máquina de calcular feita para calcular funções polinomiais.\nO inglês Charles Babbage era matemático, filósofo, inventor e engenheiro mecânico, e é considerado por muitos como o “pai do computador”. Esse título é por causa de outra máquina que ele idealizou. O engenho analítico (1840), diferente de todas as máquinas da época, marcou a transição da aritmética mecanizada para a computação de propósito geral. Essa máquina seria programada por meio de cartões perfurados e incorporaria diversos recursos posteriormente adotados em computadores modernos, como controle sequencial, estruturas de ramificação e mecanismos de repetição (laços).\nDurante a criação do engenho analítico, a condessa de Lovelace, Augusta Ada Byron King (filha do poeta Lord Byron), criou um algoritmo para calcular a sequência dos números de Bernoulli, e por isso é considerada a primeira programadora. Hoje em dia, a figura de Ada é usada como inspiração para aumentar a presença de mulheres na computação, que era bem maior algumas décadas atrás.\nAté então todas as máquinas desenvolvidas eram estritamente mecânicas. O Z2 foi um dos primeiros exemplos de um computador digital operado eletricamente, construído com relés eletromecânicos, e foi criado pelo engenheiro civil Konrad Zuse em 1940 na Alemanha. Mas, foi a partir da invenção das válvulas termiônicas (tubos de vácuo) que damos o primeiro salto na era dos computadores digitais. As válvulas eram dispositivos totalmente elétricos que geravam corrente elétrica a partir do fenômeno de emissão termiônica e foram inventadas pelo físico John Ambrose Fleming em 1904.\nO Z3, sucessor do Z2, também foi desenvolvido por Zuse e é considerado o primeiro computador digital programável e totalmente automático do mundo. Konrad Zuse também foi responsável pelo design do Plankalkül, a primeira linguagem de programação de alto nível, ou seja, mais próxima da linguagem humana e mais distante da linguagem de máquina. Embora esta linguagem nunca tenha sido implementada na época, ela introduziu conceitos fundamentais da programação moderna, como tipos de dados e estruturas de controle.\nMáquinas como o Z3, Colossus e o ENIAC foram construídas manualmente, usando circuitos contendo relés ou válvulas e frequentemente usavam cartões perfurados ou fita de papel perfurada para entrada e como principal meio de armazenamento. A maioria das máquinas desse período não possuía a capacidade de armazenar e modificar programas (com exceção do Z3). No ENIAC, um “programa” era definido pela configuração de seus cabos de conexão e interruptores, característica que distingue essas máquinas dos computadores modernos. A programação nessa época era exercida majoritariamente por mulheres, porém essa predominância foi gradualmente diminuindo com o passar dos anos.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uma Breve Apresentação da História dos Computadores e Linguagens de Programação</span>"
    ]
  },
  {
    "objectID": "chapters/01-evolucao-computacao.html#o-nascimento-da-computação-moderna",
    "href": "chapters/01-evolucao-computacao.html#o-nascimento-da-computação-moderna",
    "title": "1  Uma Breve Apresentação da História dos Computadores e Linguagens de Programação",
    "section": "1.4 O Nascimento da Computação Moderna",
    "text": "1.4 O Nascimento da Computação Moderna\nAté o momento, todas as máquinas (Babbage, Zuse, Colossus) seguiam o mesmo design proposto por Babbage: construíam-se máquinas para realizar cálculos e, então, organizavam-se instruções codificadas em alguma outra forma, armazenadas separadamente, para fazê-las funcionar. A grande mudança de paradigma ocorreu em 1945 com as ideias de Alan Turing e John von Neumann. Ambos perceberam que os programas deveriam ser armazenados da mesma forma que os dados. O Manchester Baby foi o primeiro computador eletrônico de programa armazenado do mundo e executou seu primeiro programa em 21 de junho de 1948. A arquitetura de von Neumann marca o início da era dos computadores modernos. Desde então, avanços foram feitos para torná-los mais rápidos, menores e fáceis de usar, porém seu cerne permanece o mesmo: a universalidade inerente ao computador de programa armazenado.\nNa mesma década, Kathleen Booth, trabalhando no mesmo lugar que von Neumann, desenvolveu a primeira linguagem assembly—uma linguagem de programação muito próximo da linguagem de máquina. Porém, programar em assembly demandava um esforço intelectual considerável. As linguagens que surgiram posteriormente representaram tentativas de abstrair a linguagem de máquina para uma linguagem de alto nível, mais próxima da linguagem natural, humana. Embora diversas linguagens tenham sido criadas nos anos seguintes, foi apenas em 1954 que surgiu a primeira linguagem amplamente adotada: FORTRAN, desenvolvida na IBM por uma equipe liderada por John Backus. Atualmente, mais de 70 anos depois, FORTRAN ainda é utilizada para classificar a lista dos TOP500 supercomputadores mais rápidos do mundo.\nA partir de 1955, a tecnologia dos transistores revolucionou a computação ao substituir os tubos de vácuo no design de computadores. Os transistores apresentavam vantagens significativas: eram menores e consumiam menos energia, consequentemente gerando menos calor que seus predecessores. O marco dessa transição foi o TRADIC Phase One, concluído em 1954, considerado o primeiro computador totalmente transistorizado.\nA evolução tecnológica prosseguiu com a invenção dos circuitos integrados em 1958 por Jack Kilby, que posteriormente foi reconhecido com o Prêmio Nobel nos anos 2000 por essa contribuição. Um circuito integrado consiste em um conjunto de circuitos eletrônicos compostos por diversos componentes (transistores, resistores e capacitores) e suas interconexões. Esses componentes são minuciosamente gravados em uma pequena peça plana, conhecida como “chip”, fabricada com material semicondutor—inicialmente germânio e, atualmente, silício.\nO período compreendido entre o final da década de 1960 e o final dos anos 1970 foi marcado pelo surgimento de diversas linguagens de programação, bem como pela consolidação dos principais paradigmas que conhecemos hoje. Simula, criada pelos cientistas da computação noruegueses Ole-Johan Dahl e Kristen Nygaard, destacou-se como a primeira linguagem projetada especificamente para suportar a programação orientada a objetos. Simultaneamente, Dennis Ritchie e Ken Thompson desenvolviam nos Bell Labs, entre 1969 e 1973, a linguagem C, voltada para programação de sistemas. É importante ressaltar que o desenvolvimento da linguagem C esteve intrinsecamente ligado ao sistema operacional UNIX, já que C foi criada justamente para facilitar a portabilidade deste sistema entre diferentes plataformas de hardware. Nesse mesmo contexto de inovação, a linguagem ML, concebida pelo cientista britânico Robin Milner, emergiu como pioneira entre as linguagens de programação funcional com tipagem estática.\nEm termos de hardware, o microprocessador permitiu o último grande salto na história da computação. Sua evolução só foi possível graças aos circuitos integrados MOS (CMOS), que permitiram a progressiva miniaturização dos transistores. Atualmente, já somos capazes de produzir transistores com dimensões da ordem de 50 nanômetros, o que é surpreendente quando consideramos que o raio de um átomo de silício é de aproximadamente 0,13 nanômetros.\nPor outro lado, a evolução das linguagens de programação foi particularmente marcante nos anos 1990, impulsionada pelo rápido crescimento da Internet. Nesse período, a produtividade dos programadores tornou-se algo importante, o que levou ao surgimento de diversas linguagens de desenvolvimento rápido de aplicativos (RAD). Essas linguagens eram acompanhadas por ambientes de desenvolvimento integrados (IDEs) e recursos de coleta de lixo. Como resultado dessa tendência, surgiram linguagens como Python, Lua, R, Ruby, Java, JavaScript e PHP.\nA crescente popularização de novas linguagens de programação foi impulsionada pelos aplicativos mobile. Celulares e dispositivos móveis tornaram-se cada vez mais presentes no cotidiano das pessoas, aumentando significativamente a demanda por aplicativos. Alguns exemplos dessas linguagens incluem Dart, Kotlin, TypeScript e Swift.\nEm 2012, surge a linguagem que será estudada nesta disciplina: Julia. Propondo-se a ser rápida e produtiva, Julia une o desempenho de linguagens antigas, com a produtividade de linguagens recentes. Foi desenvolvida por Jeff Bezanson, Stefan Karpinski, Viral B. Shah e Alan Edelman. O site https://julialang.org/benchmarks/ apresenta um benchmark comparativo de diferentes linguagens na resolução de alguns algoritmos. Pode-se observar que Julia demonstra desempenho equivalente ao da linguagem C.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uma Breve Apresentação da História dos Computadores e Linguagens de Programação</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html",
    "href": "chapters/02-calculadora-repl.html",
    "title": "2  Usando o Interpretador (REPL) como Calculadora",
    "section": "",
    "text": "2.1 Explorando a Sessão Interativa de Julia\nO objetivo deste capítulo é apresentar o interpretador de Julia como uma calculadora poderosa e introduzir os primeiros conceitos de programação: variáveis e funções. Mas primeiro é preciso instalar a linguagem Julia em seu computador. Mais detalhes sobre o processo de instalação podem ser encontrados neste link.\nMuito provavelmente seu sistema é Windows (10 ou 11) e sua arquitetura é de 64-bits. Há algumas formas de instalar Julia no Windows:\nA princípio qualquer uma das opções é adequada. A primeira opção não requer nenhum programa adicional, enquanto que a segunda requer um terminal. Um terminal é um aplicativo que permite a comunicação com o sistema operacional por meio de uma interface de linha de comando (CLI). O terminal padrão do Windows é o Windows Terminal. É fortemente recomendado que você o tenha instalado e isso pode ser feito através da Microsoft Store.\nUma vez que você tenha acesso a um terminal há dois comandos possíveis para instalar Julia: winget install julia -s msstore ou winget install -e --id Julialang.Julia. Mais uma vez, qualquer uma das opções deve funcionar.\nVocê pode abrir uma sessão interativa (também conhecido como um read-eval-print loop ou REPL) de Julia digitando o comando julia na linha de comando do seu terminal. No Windows, após instalação da linguagem, é possível abrir uma sessão interativa clicando duas vezes no executável Julia. A sua janela deve ser parecida com\nDentro da sessão podemos inserir comandos que serão lidos, avaliados e impressos na tela. Um comando só é avaliado quando teclamos Enter. Vamos começar com operações com números inteiros. Para somar dois números podemos digitar:\n1 + 2\n\n3\nPara multiplicar outros dois número:\n40 * 4\n\n160\nComo esperado, podemos utilizar as operações básicas de soma (+), subtração (-) e multiplicação (*), e os resultados ocorrem como previsto. No entanto, observaremos a seguir que o comportamento da divisão apresenta algumas particularidades:\na = 84 \nb = 2\n\n# As variáveis a e b são do tipo Int64\n\nresultado = a / b\nprintln(resultado)\n\n42.0\nNotem que, neste exemplo, ocorreu uma conversão de tipo, pois 84 e 2 são números inteiros, enquanto o resultado é um número em ponto flutuante (float). Os pontos flutuantes são representações binárias de números reais, tema que exploraremos com mais detalhes em breve. Esta conversão fica evidente pela representação do resultado como 42.0, em vez de simplesmente 42. Caso deseje obter o resultado como um número inteiro, é possível utilizar o operador div:\ndiv(84,2)\n\n42\nOu de forma equivalente usando o operador \\div (para conseguir ver o símbolo da divisão é necessário digitar \\div seguido da tecla &lt;tab&gt;).\nAlém das operações básicas, é possível fazer exponenciação:\n2^31\n\n2147483648\nExpressões mais complexas também podem ser calculadas:\n23 + 2 * 2 + 3 * 4\n\n39\nSim, a precedência de operadores usual também é válida em Julia. Entretanto, lembre-se da primeira lição de programação: Escreva para humanos, não para máquinas. Podemos usar parênteses para separar as operações:\n23 + (2 * 2) + (3 * 4)\n\n39\nLembra dos pontos flutuantes? Todas as operações vistas podem ser aplicadas em pontos flutuantes:\n23.5 * 3.14\n\n73.79\nOu:\n12.5 / 2.0\n\n6.25\nO exemplo acima demonstra mais um código escrito de forma clara para pessoas, onde ao utilizarmos 2.0 deixamos explícito que o segundo parâmetro é um número de ponto flutuante (float). É fundamental compreender que números de ponto flutuante possuem precisão limitada, portanto não se surpreenda ao encontrar resultados inesperados como os demonstrados abaixo:\n1.2 - 1.0\n\n0.19999999999999996\nErros como esse são bastante raros, tanto que normalmente depositamos total confiança nas contas realizadas por computadores e calculadoras. No entanto, é importante reconhecer que existem limitações (veja os exemplos abaixo).\n2.6 - 0.7 - 1.9\n\n2.220446049250313e-16\n0.1 + 0.2\n\n0.30000000000000004\n10e15 + 1 - 10e15\n\n0.0\nEsses problemas de precisão estão ligados à limitação de como os números são representados no computador. De maneira simplificada, os valores no computador são codificados em palavras, formadas por bits. Nos computadores modernos, as palavras têm 64 bits, ou 8 bytes. Logo, uma outra limitação está relacionada aos números inteiros muito grandes.\n2^63\n\n-9223372036854775808\nNo entanto, para um curso introdutório, é suficiente estar ciente dessas limitações. O tratamento dessas questões faz parte de disciplinas mais avançadas. Vale ressaltar que o erro mencionado anteriormente é um erro silencioso, ou seja, ao trabalharmos com números inteiros, pode acontecer que o valor a ser representado exceda a capacidade do número de bits disponível, resultando em uma falha que ocorre sem notificação explícita.\nVoltando às contas. Um outro operador interessante é o % que calcula o resto da divisão\n4 % 3\n\n1\nAté agora vimos como trabalhar com um único valor, como se estivéssemos usando o visor de uma calculadora. Mas podemos ir além disso. Em vez de simples teclas de memória, o computador nos oferece variáveis. Essas são como nomes para valores que queremos armazenar e utilizar posteriormente.\nAlém das operações básicas também temos as operações matemáticas (funções), como por exemplo o seno, sine em inglês. Para saber como uma função funciona podemos pedir ajuda ao ambiente, usando uma ? ou o macro @doc, e em seguida digitando o que queremos saber, como por exemplo em:\n@doc sin\nA saída desse comando indica a operação que a função realiza e ainda apresenta alguns exemplos:\nAmbos os comandos ? sin e @doc sin possuem a mesma saída.\nNotem que nem tudo que foi apresentado faz sentido no momento, mas já dá para entender o uso de uma função como sin. Vejamos agora a raiz quadrada:\n@doc sqrt\nNela vemos que é possível calcular a raiz como em:\nsqrt(4)\n\n2.0\nsqrt(4.0)\n\n2.0\nAgora, observe que a documentação da função big() tem a seguinte ajuda:\nA função big() permite criar números de grande magnitude, representados pelos tipos BigInt ou BigFloat. Essa função é particularmente útil quando você precisa trabalhar com números muito grandes que ultrapassam os limites dos tipos padrão, como Int64 ou Int32. Ao utilizar números do tipo BigInt, eliminamos problemas de estouro (overflow), conforme podemos observar abaixo:\nbig(2) ^ 1002\n\n42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#explorando-a-sessão-interativa-de-julia",
    "href": "chapters/02-calculadora-repl.html#explorando-a-sessão-interativa-de-julia",
    "title": "2  Usando o Interpretador (REPL) como Calculadora",
    "section": "",
    "text": "_\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.3 (2025-01-21)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsin(x)\n\nCompute sine of x, where x is in radians.\n\nSee also sind, sinpi, sincos, cis, asin.\n\nExamples\n≡≡≡≡≡≡≡≡\n\njulia&gt; round.(sin.(range(0, 2pi, length=9)'), digits=3)\n1×9 Matrix{Float64}:\n0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0\n\n\n\nsqrt(x)\n\nReturn \\sqrt{x}.\n\nThrows DomainError for negative Real arguments. Use complex negative arguments instead. Note that sqrt has a branch cut\nalong the negative real axis.\n\nThe prefix operator √ is equivalent to sqrt.\n\nSee also: hypot\n...\n\n\n\n\nbig(T::Type)\n\nCompute the type that represents the numeric type T with arbitrary precision. Equivalent to typeof(big(zero(T))).\n\nExamples\n≡≡≡≡≡≡≡≡\n\njulia&gt; big(Rational)\nRational{BigInt}\n\njulia&gt; big(Float64)\nBigFloat\n\njulia&gt; big(Complex{Int})\nComplex{BigInt}\n\nbig(x)\n\nConvert a number to a maximum precision representation (typically BigInt or BigFloat). See BigFloat for information about\nsome pitfalls with floating-point numbers.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#variáveis-e-tipos-de-dados",
    "href": "chapters/02-calculadora-repl.html#variáveis-e-tipos-de-dados",
    "title": "2  Usando o Interpretador (REPL) como Calculadora",
    "section": "2.2 Variáveis e Tipos de Dados",
    "text": "2.2 Variáveis e Tipos de Dados\nComo já introduzido, em Julia, temos o conceito de variáveis. Variáveis servem para armazenar dados diversos, como inteiros e floats. Podemos operar nas variáveis da mesma forma que operamos nos dados que elas guardam (veja o exemplo abaixo).\n\na = 7\n2 + a\n\n9\n\n\nÉ importante destacar que as variáveis em Julia podem receber novos valores, e o tipo da variável é determinado pela última atribuição realizada. A função typeof pode ser usada para identificar o tipo da variável especificada.\n\na = 3\ntypeof(a)\n\nInt64\n\n\n\na = a + 1\ntypeof(a)\n\nInt64\n\n\nNo exemplo a seguir, a variável b começa com um valor de tipo inteiro. No entanto, após a operação de multiplicação, seu valor passa a ser do tipo ponto flutuante.\n\nb = 3\nb = b * 0.5\ntypeof(b)\n\nFloat64\n\n\nA capacidade de alterar o tipo da variável é conhecida como tipagem dinâmica. Esta característica apresenta diversas vantagens, como a flexibilidade de reutilizar variáveis para armazenar diferentes tipos de dados ao longo do tempo e a menor verbosidade, pois não é necessário especificar o tipo de cada variável, o que melhora a legibilidade do código. Neste contexto, podemos observar que Julia possui vários tipos primitivos, sendo os principais:\n\ntypeof(1)\n\nInt64\n\n\n\ntypeof(1.1)\n\nFloat64\n\n\n\ntypeof(\"Bom dia\")\n\nString\n\n\nFalando em strings, elas são definidas por conjuntos de caracteres entre aspas como:\n\ns1 = \"Olha que legal\"\ns2 = \"Outra String\"\n\n\"Outra String\"\n\n\nTambém é possível realizar operações com strings, como concatenação:\n\ns1 = \"Tenha um\"\ns2 = \" Bom dia\"\ns3 = s1 * s2\n\n\"Tenha um Bom dia\"\n\n\nOu repetição usando o operador de potência:\n\ns = \"Não vou mais fazer coisas que possam desagradar os meus colegas \"\ns ^ 10\n\n\"Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fa\" ⋯ 100 bytes ⋯ \" meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas Não vou mais fazer coisas que possam desagradar os meus colegas \"\n\n\nAinda sobre variáveis, há algumas regras referentes aos seus nomes: devem começar com uma letra (ou com _), podem conter dígitos e não podem ser palavras reservadas. Vale ressaltar que Julia, por ser uma linguagem moderna, aceita caracteres unicode e emojis nos nomes, como por exemplo o Δ (\\Delta).\n\nΔ = 2\n\n2\n\n\n\n🐱 = 5 # \\:cat: &lt;tab&gt;\n🐶 = 3 # \\:dog: &lt;tab&gt;\n🏠 = 20 # \\:house: &lt;tab&gt;\n\n20\n\n\nIsso não adiciona nada do lado de algoritmos, mas é possível ter variáveis bem bonitinhas. A lista de figuras pode ser encontrada aqui.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#saída-de-dados",
    "href": "chapters/02-calculadora-repl.html#saída-de-dados",
    "title": "2  Usando o Interpretador (REPL) como Calculadora",
    "section": "2.3 Saída de Dados",
    "text": "2.3 Saída de Dados\nPara fazer saídas usam-se dois comandos, print() e o println(), sendo que o primeiro não pula linha e o segundo pula.\n\nprint(\"Hello \")\nprintln(\"World!\")\nprintln(\"Ola, mundo!\")\n\nHello World!\nOla, mundo!\n\n\nPara evitar que se digitem muitos caracteres, por vezes podemos usar açucares sintáticos.\n\nx = 1\nx = x + 1\nx += 1  # forma equivalente a acima, o mesmo vale para os operadores *, - e /\n\n3\n\n\nO código acima utiliza comentários (tudo depois do #). Esses comentários são ignorados pelo interpretador e podem ser usados para tornar o código mais legível.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#arquivos-externos",
    "href": "chapters/02-calculadora-repl.html#arquivos-externos",
    "title": "2  Usando o Interpretador (REPL) como Calculadora",
    "section": "2.4 Arquivos Externos",
    "text": "2.4 Arquivos Externos\nPodemos carregar funções de outros arquivos na sessão interativa (e em outros arquivos também) usando o comando include(\"caminho/do/arquivo.jl\"). Julia lê o arquivo especificado e executa todo o seu conteúdo no contexto atual. Isso significa que todas as funções, variáveis e definições no arquivo tornam-se disponíveis no ambiente onde include foi chamado.\nPor exemplo, suponha que temos um arquivo chamado funcoes.jl que possui a função ola:\n\nfunction ola(nome)\n    println(\"Olá \", nome)\nend\n\nola (generic function with 1 method)\n\n\nPodemos incluir essa função em um segundo arquivo utilizando o include(\"funcoes.jl\") e então usar a função definida no arquivo funcoes.jl:\n\ninclude(\"funcoes.jl\")\nprintln(ola(\"Alfredo\"))\n\nA saída deverá ser Olá Alfredo.\n\n2.4.1 O que é um arquivo .jl?\nUm arquivo .jl é semelhante a um arquivo de texto .txt, porém com a extensão .jl. Embora seja possível abri-lo com um editor de texto simples como o Bloco de Notas, não é recomendado utilizá-lo para programação. Os arquivos .jl são arquivos de código-fonte da linguagem Julia e são geralmente editados com editores específicos para programação, como Visual Studio Code, Atom ou Sublime Text.\nNão existe um editor de texto definitivamente superior aos demais, o importante é escolher aquele com o qual você se sinta mais confortável. Nossa recomendação é o Visual Studio Code, que oferece recursos muito mais avançados que um editor de texto comum e possui uma extensão dedicada à linguagem Julia, facilitando significativamente a escrita de código. Para começar a usar o Visual Studio Code com Julia, os tutoriais a seguir podem ser úteis:\n\nhttps://code.visualstudio.com/docs/getstarted/getting-started\nhttps://code.visualstudio.com/docs/languages/julia",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#verifique-seu-aprendizado",
    "href": "chapters/02-calculadora-repl.html#verifique-seu-aprendizado",
    "title": "2  Usando o Interpretador (REPL) como Calculadora",
    "section": "2.5 Verifique seu Aprendizado",
    "text": "2.5 Verifique seu Aprendizado\n\nQual a diferença entre os resultados obtidos pelos operadores / e div em Julia? Em quais situações cada um seria mais apropriado?\nPor que a expressão 2.6 - 0.7 - 1.9 não resulta exatamente em zero? O que isso nos ensina sobre cálculos computacionais?\nExplique o que significa ‘tipagem dinâmica’ e como isso afeta o comportamento das variáveis quando atribuímos diferentes tipos de valores a elas.\nUse a função big() para calcular \\(2^{1000}\\). Compare este resultado com o que acontece ao tentar calcular \\(2^{1000}\\) sem usar big().\nArmazene seu nome e sobrenome em variáveis separadas e depois combine-as para formar seu nome completo com um espaço entre elas. Demonstre também a operação de repetição de strings.\nCrie as variáveis a = 10, b = 3 e c = 4.5. Realize os seguintes cálculos: a + b + c, a * b * c, a % b e verifique o tipo do resultado de cada operação usando typeof().",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#explore-por-conta-própria",
    "href": "chapters/02-calculadora-repl.html#explore-por-conta-própria",
    "title": "2  Usando o Interpretador (REPL) como Calculadora",
    "section": "2.6 Explore por Conta Própria",
    "text": "2.6 Explore por Conta Própria\n\nProcure na documentação duas funções matemáticas que não foram mencionadas no capítulo e teste seu uso no REPL.\nO que acontece quando você tenta dividir um número por zero em Julia? E quando calcula 0/0? Teste e observe os resultados.\nExperimente o operador Unicode ≈ (digite \\approx seguido de TAB). Como ele se comporta ao comparar 0.1 + 0.2 ≈ 0.3?\nInvestigue a função round() e utilize-a para corrigir alguns dos problemas de precisão demonstrados no capítulo.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/03-condicionais.html",
    "href": "chapters/03-condicionais.html",
    "title": "3  Estruturas de Controle e Tomada de Decisões",
    "section": "",
    "text": "3.1 Operadores de Comparação e o Tipo Booleano\nO objetivo deste capítulo é entender como um programa pode tomar decisões e alterar seu fluxo de execução. Vamos explorar os operadores de comparação, o tipo booleano, e as estruturas condicionais if, else e elseif em Julia.\nAntes de estudarmos estruturas condicionais, precisamos entender os operadores de comparação e o tipo de dado que eles produzem: o tipo booleano (Bool). Uma variável booleana pode ter apenas dois valores possíveis: true (verdadeiro) ou false (falso). Vamos examinar os principais operadores de comparação em Julia:\n# Igualdade: retorna true se os valores forem iguais\n2 + 2 == 4\n\ntrue\n# Diferença: retorna true se os valores forem diferentes\n3 != 8\n\ntrue\n# Menor que: retorna true se o primeiro valor for menor que o segundo\n23 &lt; 24\n\ntrue\n# Menor ou igual: retorna true se o primeiro valor for menor ou igual ao segundo\n42 &lt;= 44\n\ntrue\n# Maior que: retorna true se o primeiro valor for maior que o segundo\n42 &gt; 2\n\ntrue\n# Maior ou igual: retorna true se o primeiro valor for maior ou igual ao segundo\n42 &gt;= 42\n\ntrue\nÉ importante observar que em linguagens de programação, incluindo Julia, o sinal de igual (=) é usado para atribuição de valores a variáveis, enquanto o operador de igualdade (==) é usado para comparações.\nPodemos verificar o tipo de uma expressão de comparação:\ntypeof(2 == 3)\n\nBool\nComo esperado, o tipo é Bool, indicando um valor booleano.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estruturas de Controle e Tomada de Decisões</span>"
    ]
  },
  {
    "objectID": "chapters/03-condicionais.html#operadores-de-comparação-e-o-tipo-booleano",
    "href": "chapters/03-condicionais.html#operadores-de-comparação-e-o-tipo-booleano",
    "title": "3  Estruturas de Controle e Tomada de Decisões",
    "section": "",
    "text": "3.1.1 Operadores Lógicos\nAlém dos operadores de comparação, Julia também oferece operadores lógicos que permitem combinar ou modificar valores booleanos:\n\n# Operador NOT (negação): inverte o valor booleano\n!true\n\nfalse\n\n\n\n!false\n\ntrue\n\n\n\n# Operador AND: retorna true apenas se ambos os valores forem true\ntrue && true\n\ntrue\n\n\n\ntrue && false\n\nfalse\n\n\n\n# Operador OR: retorna true se pelo menos um dos valores for true\ntrue || false\n\ntrue\n\n\n\nfalse || false\n\nfalse\n\n\nEsses operadores são essenciais para construir condições mais complexas em nossas estruturas condicionais.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estruturas de Controle e Tomada de Decisões</span>"
    ]
  },
  {
    "objectID": "chapters/03-condicionais.html#alterando-o-fluxo-de-execução-com-if-else",
    "href": "chapters/03-condicionais.html#alterando-o-fluxo-de-execução-com-if-else",
    "title": "3  Estruturas de Controle e Tomada de Decisões",
    "section": "3.2 Alterando o Fluxo de Execução com if-else",
    "text": "3.2 Alterando o Fluxo de Execução com if-else\nAté agora, nossos programas seguiam um fluxo de execução linear, com as instruções sendo executadas na ordem em que foram escritas. Veja o exemplo:\n\nprintln(\"Oi\")\nprintln(\"um\")\nprintln(\"dois\")\n\nOi\num\ndois\n\n\nA ordem de impressão será “Oi”, “um” e “dois”, exatamente na sequência em que os comandos foram escritos.\nNo entanto, muitas vezes precisamos que nosso programa tome decisões e execute diferentes blocos de código dependendo de certas condições. É aqui que entra a estrutura condicional if.\n\n3.2.1 A Estrutura if\nA estrutura if permite executar um bloco de código apenas se uma condição for verdadeira:\n\npandemia = true\nprintln(\"Vou sair de casa?\")\nif pandemia == true\n   println(\"Só vou sair de casa se for essencial\")\nend\n\nVou sair de casa?\nSó vou sair de casa se for essencial\n\n\nNeste exemplo, a mensagem “Só vou sair de casa se for essencial” só será impressa se a variável pandemia for igual a true.\nAqui está outro exemplo:\n\ndenominador = 1\nif denominador != 0\n   println(\"Sei fazer a divisão se não for por zero\")\n   println(\"O resultado da divisão de 30 por \", denominador, \" é igual a \", 30/denominador)\nend\n\nSei fazer a divisão se não for por zero\nO resultado da divisão de 30 por 1 é igual a 30.0\n\n\nO código dentro do bloco if só será executado se o denominador for diferente de zero, evitando assim um erro de divisão por zero.\n\n\n3.2.2 Adicionando Alternativas com else\nFrequentemente, queremos executar um bloco de código se uma condição for verdadeira e outro bloco se a condição for falsa. Para isso, usamos a estrutura if-else:\n\npandemia = true\nprintln(\"Vou sair de casa?\")\nif pandemia == true\n   println(\"Só vou sair de casa se for essencial\")\nelse\n   println(\"Balada liberada!!\")\nend\n\nVou sair de casa?\nSó vou sair de casa se for essencial\n\n\nSe a variável pandemia for true, será impressa a mensagem “Só vou sair de casa se for essencial”. Caso contrário, será impressa a mensagem “Balada liberada!!”.\n\n\n3.2.3 Múltiplas Condições com elseif\nE se tivermos mais de duas situações possíveis? Nesse caso, podemos usar a estrutura if-elseif-else:\n\npandemia = true\ntenhoqueestudar = true\nprintln(\"Vou sair de casa?\")\nif pandemia == true\n   println(\"Só vou sair de casa se for essencial\")\nelseif tenhoqueestudar == true\n   println(\"Melhor ficar em casa\")\nelse\n   println(\"Balada liberada\")\nend\n\nVou sair de casa?\nSó vou sair de casa se for essencial\n\n\nNeste exemplo, temos três caminhos possíveis:\n\nSe houver pandemia, sair apenas se for essencial\nSe não houver pandemia mas eu tiver que estudar, ficar em casa\nSe não houver pandemia e eu não tiver que estudar, ir para a balada\n\nA estrutura if-elseif-else avalia as condições na ordem em que aparecem. Assim que uma condição verdadeira é encontrada, o bloco correspondente é executado e as demais condições são ignoradas.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estruturas de Controle e Tomada de Decisões</span>"
    ]
  },
  {
    "objectID": "chapters/03-condicionais.html#verifique-seu-aprendizado",
    "href": "chapters/03-condicionais.html#verifique-seu-aprendizado",
    "title": "3  Estruturas de Controle e Tomada de Decisões",
    "section": "3.3 Verifique seu Aprendizado",
    "text": "3.3 Verifique seu Aprendizado\n\nQual é a diferença entre o operador = e o operador == em Julia? Por que essa distinção é importante?\nExplique a diferença entre if-else e if-elseif-else. Em quais situações você usaria cada um?\nConsidere a seguinte expressão booleana: (a &gt; b) && !(c == d). Explique em palavras o que ela significa.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estruturas de Controle e Tomada de Decisões</span>"
    ]
  },
  {
    "objectID": "chapters/03-condicionais.html#explore-por-conta-própria",
    "href": "chapters/03-condicionais.html#explore-por-conta-própria",
    "title": "3  Estruturas de Controle e Tomada de Decisões",
    "section": "3.4 Explore por Conta Própria",
    "text": "3.4 Explore por Conta Própria\n\nPesquise sobre a avaliação em curto-circuito dos operadores lógicos && e || em Julia. Como esse comportamento pode ser útil em programação?\nEm Julia, além dos valores true e false, quais outros valores são considerados “verdadeiros” ou “falsos” em um contexto booleano?\nInvestigue o operador ternário (?:) em Julia e como ele pode ser usado como uma alternativa mais concisa para certas estruturas if-else.\nExplore como as estruturas condicionais podem ser combinadas com funções para criar código mais modular e reutilizável.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estruturas de Controle e Tomada de Decisões</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html",
    "href": "chapters/04-funcoes-recursao.html",
    "title": "4  Introdução às Funções",
    "section": "",
    "text": "4.1 Funções como Abstrações Naturais\nO objetivo deste capítulo é compreender o conceito de funções em programação e como elas são implementadas em Julia. Vamos explorar como criar nossas próprias funções, como elas podem receber parâmetros e retornar valores, além de introduzir o conceito de recursão.\nNa aula anterior, já utilizamos algumas funções predefinidas em Julia. Funções são blocos de código que realizam tarefas específicas e podem ser reutilizados sempre que necessário. Elas nos permitem abstrair operações complexas em comandos simples, tornando o código mais legível e modular.\nVamos relembrar algumas das funções que já utilizamos:\nAssim como na aula anterior, podemos pedir ajuda ao Julia para entender melhor como essas funções funcionam. Para isso, usamos o ponto de interrogação ? ou o macro @doc antes do nome da função:\n# Exemplos de como acessar a documentação\n@doc typeof\n@doc div\n@doc println\nAo consultar a documentação, descobrimos que algumas funções como div() podem ser utilizadas com uma sintaxe alternativa, como por exemplo \\div. Esse tipo de notação é particularmente útil para operações matemáticas.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introdução às Funções</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#funções-como-abstrações-naturais",
    "href": "chapters/04-funcoes-recursao.html#funções-como-abstrações-naturais",
    "title": "4  Introdução às Funções",
    "section": "",
    "text": "typeof() - Recebe um valor como parâmetro e retorna o seu tipo.\ndiv() - Recebe dois números e retorna a divisão inteira do primeiro pelo segundo.\nprint() e println() - Imprimem valores no console, sendo que o segundo adiciona uma quebra de linha após a impressão.\n\n\n\n\n\n\n\n4.1.1 Funções de Conversão em Julia\nUma categoria importante de funções em Julia são as funções de conversão, que transformam valores de um tipo em outro. Vejamos alguns exemplos:\n\n# Converte uma string para um número em ponto flutuante\nparse(Float64, \"32\")\n\n32.0\n\n\n\n# Converte um número em ponto flutuante para um inteiro (removendo a parte decimal)\ntrunc(Int64, 2.25)\n\n2\n\n\n\n# Converte um inteiro para um número em ponto flutuante\nfloat(2)\n\n2.0\n\n\n\n# Converte um número para uma string\nstring(3)\n\n\"3\"\n\n\n\n# Converte um número em ponto flutuante para uma string\nstring(3.57)\n\n\"3.57\"\n\n\n\n\n4.1.2 Funções Matemáticas Prontas em Julia\nJulia possui uma grande biblioteca de funções matemáticas prontas para uso. Aqui estão algumas das mais comuns:\n\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nsin(x)\nCalcula o seno de ( x ) em radianos\n\n\ncos(x)\nCalcula o cosseno de ( x ) em radianos\n\n\ntan(x)\nCalcula a tangente de ( x ) em radianos\n\n\ndeg2rad(x)\nConverte ( x ) de graus em radianos\n\n\nrad2deg(x)\nConverte ( x ) de radianos em graus\n\n\nlog(x)\nCalcula o logaritmo natural de ( x )\n\n\nlog(b, x)\nCalcula o logaritmo de ( x ) na base ( b )\n\n\nlog2(x)\nCalcula o logaritmo de ( x ) na base 2\n\n\nlog10(x)\nCalcula o logaritmo de ( x ) na base 10\n\n\nexp(x)\nCalcula o expoente da base natural de ( x )\n\n\nabs(x)\nCalcula o valor absoluto de ( x )\n\n\nsqrt(x)\nCalcula a raiz quadrada de ( x )\n\n\ncbrt(x)\nCalcula a raiz cúbica de ( x )\n\n\nfactorial(x)\nCalcula o fatorial de ( x )\n\n\n\nUma boa prática para se familiarizar com essas funções é experimentá-las com diferentes valores e verificar os resultados. Para funções mais complexas, é possível que já existam implementações prontas em Julia. Uma dica útil é pesquisar na internet usando palavras-chave como “julia lang hiperbolic sin” para encontrar a função desejada. Em geral, pesquisar em inglês tende a produzir melhores resultados.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introdução às Funções</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#criando-nossas-próprias-funções",
    "href": "chapters/04-funcoes-recursao.html#criando-nossas-próprias-funções",
    "title": "4  Introdução às Funções",
    "section": "4.2 Criando Nossas Próprias Funções",
    "text": "4.2 Criando Nossas Próprias Funções\nEm Julia, podemos criar nossas próprias funções usando a palavra-chave function, seguida pelo nome da função, parênteses (que podem conter parâmetros) e terminando com end. Vejamos um exemplo simples:\n\nfunction mensagemDeBomDia()\n   println(\"Tenha um bom dia!\")\nend\n\nmensagemDeBomDia (generic function with 1 method)\n\n\nPara usar (ou “chamar”) uma função, basta escrever seu nome seguido de parênteses:\n\nmensagemDeBomDia()\n\nTenha um bom dia!\n\n\n\n4.2.1 Funções com Parâmetros\nAs funções se tornam muito mais úteis quando podem receber informações para processar. Essas informações são chamadas de “parâmetros” ou “argumentos”:\n\nfunction imprime(a)\n   println(\"Vou imprimir \", a)\nend\n\nimprime (generic function with 1 method)\n\n\nVamos chamar esta função com diferentes valores:\n\nimprime(42)\n\nVou imprimir 42\n\n\n\nimprime(\"Olá, mundo!\")\n\nVou imprimir Olá, mundo!\n\n\n\n\n4.2.2 Funções Chamando Outras Funções\nUma função pode chamar outra função, permitindo a composição de operações mais complexas:\n\nfunction imprimeduasvezes(a)\n   imprime(a)\n   imprime(a)\nend\n\nimprimeduasvezes (generic function with 1 method)\n\n\nTestando nossa nova função:\n\nimprimeduasvezes(13)\n\nVou imprimir 13\nVou imprimir 13\n\n\n\n\n4.2.3 Sobrecarga de Funções\nEm Julia, podemos ter funções com o mesmo nome, mas com diferentes números ou tipos de parâmetros. Isso é chamado de “sobrecarga de funções”:\n\nfunction recebe(a)\n  println(\"Recebi um parâmetro: \", a)\nend\n\nfunction recebe(a, b)\n  println(\"Recebi dois parâmetros: \", a, \" e \", b)\nend\n\nrecebe (generic function with 2 methods)\n\n\nO Julia decide qual versão da função chamar com base nos argumentos fornecidos:\n\nrecebe(1)\n\nRecebi um parâmetro: 1\n\n\n\nrecebe(1, 2)\n\nRecebi dois parâmetros: 1 e 2\n\n\nTambém podemos chamar funções usando variáveis e expressões como argumentos:\n\na = 10\nrecebe(a)\nrecebe(a, a + 1)\n\nRecebi um parâmetro: 10\nRecebi dois parâmetros: 10 e 11",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introdução às Funções</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#funções-que-retornam-valores",
    "href": "chapters/04-funcoes-recursao.html#funções-que-retornam-valores",
    "title": "4  Introdução às Funções",
    "section": "4.3 Funções que Retornam Valores",
    "text": "4.3 Funções que Retornam Valores\nAté agora, vimos funções que apenas imprimem mensagens, mas não devolvem nenhum valor. O tipo de retorno dessas funções é Nothing, indicando que elas não produzem um valor que possa ser atribuído a uma variável.\nNo entanto, frequentemente queremos que nossas funções calculem e retornem valores. Para isso, usamos a palavra-chave return:\n\nfunction soma1(a)\n  return a + 1\nend\n\nsoma1 (generic function with 1 method)\n\n\nAgora podemos usar essa função em expressões e atribuições:\n\nresultado = soma1(5)\nprintln(\"O resultado é: \", resultado)\n\nO resultado é: 6\n\n\n\n# Também podemos usar o resultado em outras expressões\nprintln(\"Resultado multiplicado por 2: \", soma1(5) * 2)\n\nResultado multiplicado por 2: 12\n\n\nPodemos criar funções para cálculos mais complexos:\n\nfunction hipotenusa(a, b)\n  hip = sqrt(a^2 + b^2)\n  return hip\nend\n\nhipotenusa (generic function with 1 method)\n\n\nTestando nossa função:\n\n# Calculando a hipotenusa de um triângulo 3-4-5\nhipotenusa(3, 4)\n\n5.0",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introdução às Funções</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#introdução-à-recursão",
    "href": "chapters/04-funcoes-recursao.html#introdução-à-recursão",
    "title": "4  Introdução às Funções",
    "section": "4.4 Introdução à Recursão",
    "text": "4.4 Introdução à Recursão\nAgora vamos explorar um conceito fundamental em programação: a recursão. Uma função recursiva é aquela que chama a si mesma como parte de sua execução. Isso pode parecer estranho à primeira vista, mas é uma técnica poderosa para resolver certos tipos de problemas.\nVamos começar com um exemplo simples: calcular o fatorial de um número. O fatorial de \\(n\\) (representado por \\(n!\\)) é o produto de todos os inteiros positivos menores ou iguais a \\(n\\). Por exemplo, \\(5! = 5 \\times 4 \\times 3 \\times 2 \\times 1 = 120\\).\nO fatorial pode ser definido recursivamente como:\n\nCaso base: \\(0! = 1\\)\nCaso recursivo: \\(n! = n \\times (n-1)!\\)\n\nVamos implementar isso em Julia:\n\nfunction fatorial(n)\n  if n == 0\n    return 1  # Caso base\n  else\n    return n * fatorial(n - 1)  # Chamada recursiva\n  end\nend\n\nfatorial (generic function with 1 method)\n\n\nTestando nossa função:\n\nfatorial(5)\n\n120\n\n\nPara entender como a recursão funciona, vamos acompanhar passo a passo o cálculo de fatorial(3):\n\nChamamos fatorial(3)\n\nComo \\(3\\) não é igual a \\(0\\), executamos return 3 * fatorial(2)\n\nAgora precisamos calcular fatorial(2)\n\nComo \\(2\\) não é igual a \\(0\\), executamos return 2 * fatorial(1)\n\nAgora precisamos calcular fatorial(1)\n\nComo \\(1\\) não é igual a \\(0\\), executamos return 1 * fatorial(0)\n\nAgora precisamos calcular fatorial(0)\n\nComo \\(0\\) é igual a \\(0\\), retornamos \\(1\\)\n\nAgora podemos completar o cálculo de fatorial(1) = \\(1 \\times 1 = 1\\)\nAgora podemos completar o cálculo de fatorial(2) = \\(2 \\times 1 = 2\\)\nFinalmente, completamos o cálculo de fatorial(3) = \\(3 \\times 2 = 6\\)\n\nA recursão tem duas partes fundamentais:\n\nUm caso base que encerra a recursão (no nosso exemplo, quando \\(n = 0\\))\nUm caso recursivo que aproxima o problema do caso base (no nosso exemplo, reduzindo \\(n\\) em \\(1\\))\n\nÉ necessário que a recursão sempre alcance o caso base, caso contrário, a função continuará chamando a si mesma indefinidamente, causando um erro de estouro de pilha (stack overflow).\n\n4.4.1 Mais Exemplos de Recursão\nVamos implementar uma função recursiva para contagem regressiva:\n\nfunction contagem(n)\n    if n &lt; 0\n        println(\"Fim!\")\n    else\n        print(n, \" \")\n        contagem(n - 1)\n    end\nend\n\ncontagem (generic function with 1 method)\n\n\nTestando nossa função:\n\ncontagem(5)\n\n5 4 3 2 1 0 Fim!\n\n\nPodemos também usar recursão para calcular a soma dos primeiros \\(n\\) números inteiros:\n\nfunction soma(n)\n  if n == 0\n    return 0  # Caso base\n  else\n    return n + soma(n - 1)  # Caso recursivo\n  end\nend\n\nsoma (generic function with 1 method)\n\n\nTestando nossa função:\n\nsoma(10)\n\n55\n\n\nOutro exemplo interessante é o cálculo da soma dos termos da série harmônica:\n\nfunction somaharmonica(atual, n)\n  # Caso base: quando chegamos ao último termo\n  if atual &gt; n\n    return 0.0\n  else\n    # Caso recursivo: somamos o termo atual e chamamos a função para o próximo termo\n    return 1.0 / atual + somaharmonica(atual + 1, n)\n  end\nend\n\nsomaharmonica (generic function with 1 method)\n\n\nVamos calcular a soma dos 10 primeiros termos da série harmônica:\n\nsomaharmonica(1, 10)\n\n2.9289682539682538",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introdução às Funções</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#verifique-seu-aprendizado",
    "href": "chapters/04-funcoes-recursao.html#verifique-seu-aprendizado",
    "title": "4  Introdução às Funções",
    "section": "4.5 Verifique seu Aprendizado",
    "text": "4.5 Verifique seu Aprendizado\n\nQual é a diferença entre uma função que imprime um valor e uma função que retorna um valor? Por que esta distinção é importante?\nExplique o conceito de recursão em suas próprias palavras. Quais são os componentes essenciais de uma função recursiva?\nCrie uma função que receba um número inteiro positivo e retorne a soma de seus dígitos. Por exemplo, para o número \\(123\\), a função deve retornar \\(1+2+3 = 6\\).\nImplemente uma função que calcule o \\(n\\)-ésimo número da sequência de Fibonacci usando recursão. Lembre-se que\n\n\\(Fib(0) = 0\\)\n\\(Fib(1) = 1\\)\n\\(Fib(n) = Fib(n-1) + Fib(n-2)\\), se \\(n &gt; 1\\).\n\nCrie uma função que receba dois números como parâmetros e retorne o máximo divisor comum (MDC) entre eles usando o algoritmo de Euclides recursivamente.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introdução às Funções</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#explore-por-conta-própria",
    "href": "chapters/04-funcoes-recursao.html#explore-por-conta-própria",
    "title": "4  Introdução às Funções",
    "section": "4.6 Explore por Conta Própria",
    "text": "4.6 Explore por Conta Própria\n\nPesquise sobre o conceito de “pilha de chamadas” (call stack) e como ele se relaciona com a recursão. Quais são as limitações práticas da recursão devido à pilha de chamadas?\nPense em como seria possível otimizar a função recursiva de Fibonacci para evitar cálculos repetidos.\n\nDica: pesquise sobre “memoização”.\n\nExplore funções com um número variável de argumentos em Julia usando a sintaxe de “splats” (...).\nProcure como você pode definir valores padrão para parâmetros de funções em Julia.",
    "crumbs": [
      "Parte I: Conceitos Básicos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Introdução às Funções</span>"
    ]
  },
  {
    "objectID": "chapters/05-algoritmos-testes.html",
    "href": "chapters/05-algoritmos-testes.html",
    "title": "5  Mais algoritmos e introdução aos testes",
    "section": "",
    "text": "Nessa aula, vamos ver algoritmos um pouco mais elaborados. Mas, sabendo que vamos usar algo com um maior grau de sofisticação, que tal pensar em testes?\nDe uma forma geral, para verificar o funcionamento de um programa, podemos escrever testes que verificam o funcionamento em algumas situações específicas.\nDado que o primeiro problema que queremos resolver é um algoritmo que encontra o n-ésimo número de Fibonacci. Por que não começar com testes?\nUma forma de se fazr testes, e de forma manual, mas isso não é reprodutível. A melhor maneira de se fazer testes, é de forma automatizada, ou seja criar código que teste código. Isso pode parecer complicado, mas vamos ver abaixo que não é.\nEm uma busca rápida, podemos ver que a sequência de Fibonacci é definida da seguinte forma, os dois primeiros elementos \\(F_1\\) e \\(F_2\\) valem 1, em seguida temos a fórmula \\(F_n = F_{n-1} +  F_{n-2}\\). Mas, antes de pensar em resolver o problema vamos pensar em como testar.\nJá sabemos os primeiros valores, além disso, através de uma busca rápida, podemos descobrir alguns valores da sequência como \\(F_5 =  5\\) e \\(F_{12}  =\n144\\). Supondo que a função para o cálculo do n-ésimo número de Fibonacci chamará fibo(). Podemos escrever o seguinte trecho de código:\n\nfunction testafibo_versao1()\n    if fibo(1) == 1\n        println(\"Deu certo para 1\")\n    end\n    if fibo(2) == 1\n        println(\"Deu certo para 2\")\n    end\n    if fibo(5) == 5\n        println(\"Deu certo para 5\")\n    end\n    if fibo(12) == 144\n        println(\"Deu certo para 12\")\n    end\n    println(\"Final dos testes\")\nend\n\ntestafibo_versao1 (generic function with 1 method)\n\n\nA função de testes acima verifica se a função fibo() devolve o resultado correto para três casos. Mas, ela tem um defeito, ela imprime mensagens demais, o que pode ser ruim. Considerando isso, vamos ver o primeiro fundamento importante com relação a testes automatizados.\nSe o teste passou, ele deve indicar apenas que deu certo!\nLevando em conta o que foi escrito acima, podemos mudar o nosso teste para:\n\nfunction testafibo()\n    if fibo(1) != 1\n        println(\"Não deu certo para 1\")\n    end\n    if fibo(2) != 1\n        println(\"Não deu certo para 2\")\n    end\n    if fibo(5) != 5\n        println(\"Não eu certo para 5\")\n    end\n    if fibo(12) != 144\n        println(\"Não deu certo para 12\")\n    end\n    println(\"Final dos testes\")\nend\n\ntestafibo (generic function with 1 method)\n\n\nAgora de posse da nossa função de testes, podemos pensar em escrever a nossa função de Fibonacci. Vamos ao caso fácil de n for menor que 2, a resposta é 1. Como vemos abaixo:\n\nfunction fibo(n)\n    if n &lt;= 2\n        return 1\n    else\n        # ainda não sabemos o que colocar aqui...\n    end\nend\n\nfibo (generic function with 1 method)\n\n\nMas, a resposta está na própria definição da função, ou seja: \\(F_n = F_{n-1} +  F_{n-2}\\). Se o \\(n\\) for maior do que 2, temos que fazer a soma dos valores de Fibonacci de \\(n-1\\) e de \\(n-2\\). Ou seja:\n\nfunction fibo(n)\n    if n &lt;= 2\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nend\n\nfibo(10)\n\n55\n\n\nÉ interessante notar que apesar de ser um dos exemplos clássicos de uso de recursão, o algoritmo acima é extremamente ineficiente. A razão é simples, cada vez que é feita a chamada, toda os valores de Fibonacci são recalculados para os valores de \\(n\\) e \\(n-1\\).\nComo Julia é uma linguagem moderna podemos usar o conceito de Memoização, que evita calcular o que já foi calculado. O Memoize tem que ser instalado no Julia com os comandos import Pkg e Pkg.add(\"Memoize\").\n\nusing Memoize\n@memoize function fibo(n)\n    if n &lt;= 2\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nend\n\nfibo(10)\n\n55\n\n\nAs diferenças de tempo das duas versões podem ser verificada com o comando @time. Da seguinte forma:\n\n@time fibo(10)\n\n  0.000001 seconds\n\n\n55\n\n\nEsse tipo de comando, que começa com @ é conhecido como anotação, e tem o poder de mudar o comportamente de partes do código.\nVamos ao segundo algoritmo da aula, o MDC (Máximo Divisor Comum). A ideia é usar o algoritmo de Euclides.\nBasicamente ele diz que o MDC de dois números a e b, é igual ao MDC de b e r, onde \\(r=a\\% b\\). Quando esse resto for zero, chegamos a solução, que é b.\nVamos começar com os testes para alguns valores bem conhecidos. Por sinal começar pelos testes antes de escrever o código é uma boa prática de programação conhecida por TDD (Test Driven Design).\n\nfunction testaMDC()\n    if MDC(3298, 2031) != 1\n        println(\"deu erro, para 3298 e 2031\")\n    end\n    if MDC(120, 36) != 12\n        println(\"deu erro, para 120 e 36\")\n    end\n    if MDC(36, 120) != 12\n        println(\"deu erro, para 36 e 120\")\n    end\n    println(\"Acabaram os testes\")\nend\n\ntestaMDC (generic function with 1 method)\n\n\nVamos pensar na função agora. Dessa vez, se o resto for 0, temos que devolver o segundo termo. Caso contrário temos que continuar com a regra\n\nfunction MDC(a, b)\n    r = a % b\n    if r == 0\n        return b\n    else\n        return MDC(b, r)\n    end\nend\n\ntestaMDC()\n\nAcabaram os testes\n\n\nAté agora usamos o modo interativo do Julia para fazer os nosso códigos. Mas, existe oura forma bem mais reutilizável, ou seja escrever o texto em arqivos. Isso é relativamente simples, basta usar um editor de texto (puro) da sua preferência, como o notepad, nano, juno, atom, vscode ou outro e salvar um arquivo com a extensão .jl.\nMas, para que algo seja executado é importante colocar uma chamada ao final. Veja abaixo um possível arquivo mdc.jl.\n\nfunction testeMDC()\n    if mdc(70, 5) != 5\n        println(\"Não funcionou para 70 e 5\")\n    end\n    if mdc(13, 7) != 1\n        println(\"Não funcionou para 13 e 7\")\n    end\n    if mdc(127, 15) != 1\n        println(\"Não funcionou para 127 e 15\")\n    end\n    if mdc(20, 15) != 5\n        println(\"Não funcionou para 20 e 15\")\n    end\n    if mdc(42, 3) != 3\n        println(\"Não funcionou para 42 e 3\")\n    end\n    if mdc(42, 8) != 2\n        println(\"Não funcionou para 42 e 8\")\n    end\n    println(\"Final dos testes\")\nend\n\nfunction mdc(a, b)\n    r = a % b\n    if r == 0\n        return b\n    else\n        mdc(b, r)\n    end\nend\n\ntesteMDC()\nprintln(\"O mdc entre 1227 e 321 é \", mdc(1227, 321))\n\nFinal dos testes\nO mdc entre 1227 e 321 é 3",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Mais algoritmos e introdução aos testes</span>"
    ]
  },
  {
    "objectID": "chapters/06-testes-automatizados.html",
    "href": "chapters/06-testes-automatizados.html",
    "title": "6  Testes automatizados e um pouco mais de código",
    "section": "",
    "text": "6.1 Funções caóticas\nVamos começar o capítulo vendo uma forma mais simples de se rodar testes. Nos testes que vimos até agora sempre havia o teste de uma condição booleana associado a uma mensagem de erro quando não funcionasse. Mas, observando que a mensagem de erro geralmente está ligada à condição, por vezes a condição pode ser auto-explicativa.\nLogo, uma forma elegante de expressar as condições pode ser útil na escrita dos testes. Para isso, vamos usar o módulo de testes. Em linguagens modernas, várias das situações repetitivas que enfrentamos podem ser evitadas usando alguma técnica mais moderna.\nNo trecho acima primeiro indicamos que queremos fazer testes. Em seguida usamos o test que espera uma condição ou valor booleano. Finalmente todos os testes são reunidos em um testset.\nClaro que o teste dá infomações relevantes quando falha:\nAgora sim, vamos pensar em problemas algoritmicos novos. Que tal fazer a soma dos dígitos de um número inteiro. Ou seja, pensar em um número dígito à dígito. Vamos aos testes primeiro:\nVamos agora tentar pensar em como “descascar” um número, dado o número 123, uma forma seria pegar o resto por 10 (ou seja 3) e depois dividir por 10 (ou seja 12), e assim por diante. Ou seja.\nVamos agora a um outro problema clássico, a verificação se um número é ou não é primo. Na prática para fazer isso, temos a definição, um número \\(n\\) é primo apenas se for divisível apenas por 1 e por ele mesmo. Ou seja, nenhum número entre 2 e \\(n - 1\\) pode ser divisor de um número primo.\nA forma de se fazer isso é relativamente simples. Vamos pensar em uma função que tenta dividir um número recursivamente, se conseguir devolve falso, se não conseguir devolve verdadeiro.\nVamos aos código:\nQue pode ser chamada por:\nMais um exemplo, o método de Newton para o cálculo de raiz quadrada. Para achar a raiz de \\(x\\), a partir de um chute inicial (por exemplos \\(y= x /2\\)), chegamos a um novo chute que é a média de \\(y\\) e \\(x/y\\).\nMas, sim, vamos começar com os testes. Como estamos usando números do tipo double é bom sempre ter uma tolerância, por isso vamos usar uma comparação aproximada. Também poderiamos ter usado a função isapprox da linguagem Julia.\nNote que como estamos comparando números em ponto flutuante, não usamos a comparação exata.\nA solução final é:\nVamos brincar um pouco agora com funções caóticas :), isso é, funções, que conforme o comportamento de uma constante \\(k\\), apresentam resultados que podem convergir ou não. Isso é, a cada passo, quero saber o valor do próximo ponto aplicando a função novamente, isso é: \\[x_1 = f(x_0), x_2 = f(x_1), \\ldots, x_n  = f(x_{n - 1})\\]\nAs funções caóticas desempenham um papel significativo em diversas áreas da matemática e da física, com aplicações que vão desde a modelagem de crescimento populacional até a previsão de padrões climáticos. Elas também são fundamentais na análise de circuitos elétricos não lineares, onde pequenas variações nas condições iniciais podem levar a resultados drasticamente diferentes.\nPara o nosso teste, a função \\(f\\) é extremamente simples: \\(x_{i + 1}=x_i * (1 -  x_i) * k\\).\nImplemente a função e imprima os 30 primeiros resultados. Comece com um valor de \\(x\\) entre 0 e 1, como 0.2. Use constantes \\(k = 2.1, 2.5, 2.8\\) e \\(3.1\\) o que ocorre com \\(k = 3.7\\)?\nEntregue o código e um pequeno relatório sobre o que acontece.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Testes automatizados e um pouco mais de código</span>"
    ]
  },
  {
    "objectID": "chapters/07-while.html",
    "href": "chapters/07-while.html",
    "title": "7  Uma outra forma de se fazer laços",
    "section": "",
    "text": "Até o momento vimos que o computador é muito bom para fazer contas e repetições. Fizemos isso até agora com funções recursivas. Mas, existe um outro comando para isso, o while. A motivação é que enquanto alguma condição for válida, o computador continua repetindo os comandos.\nO formato básico é o seguinte:\nwhile condição\n  # execute obloco\nend  \nEnquanto a condição continuar verdadeira, o computador vai seguir repetindo o bloco que pode ser formado por várias intruções. Logo, para que a repetição, ou laço, não seja repetido indefinidamente, é essencial que algo ligado a condição seja atualizado no corpo do while.\nVejamos o exemplo simples da contagem regressiva:\n\nn = 5\nwhile n &gt; 0\n  println(n)\n  n = n - 1\nend\nprintln(\"Acabou\")\n\n5\n4\n3\n2\n1\nAcabou\n\n\nMas, vamos ver abaixo um caso onde o uso de while deixa o código mais Claro que com a recursão (onde é ruim fazer uma com vários parãmetros). Veja a resolução da série de Taylor abaixo:\n\n function sinTaylor2(x)\n   i = 1\n   termo = x\n   soma = 0.0\n   while i &lt;= 15\n     soma = soma + termo\n     termo = -1 * termo * x * x / ((2 * i) * (2 * i + 1))\n     i = i + 1\n   end\n   return soma\nend\n\nsinTaylor2 (generic function with 1 method)\n\n\nNela são calculados os 15 primeiros termos.\nObservem a versão recursiva:\n\nfunction sinTaylor(x)\n    return sinTaylorRec(1, 15, x, 1, x)\nend\n\nfunction sinTaylorRec(i, n, x, sinal, termo)\n    if n == i\n      return 0.0\n    else\n      return sinal * termo +\n         sinTaylorRec(i + 1, n, x, -1 * sinal, termo * x * x/ (2*i * (2*i+1)))\n    end\nend\n\nsinTaylorRec (generic function with 1 method)\n\n\nPodemos também fazer operações com os dígitos de um número inteiro, para isso operações como o resto da divisão por 10 e a divisão inteira por 10 são bastante úteis. Abaixo temos as duas versões que fazem a soma dos dígitos de um número inteiro.\n\nusing Test\nfunction testaSD()\n  @test sd(123) == 6\n  @test sd(321) == 6\n  @test sd(0) == 0\n  @test sd(1001) == 2\n  @test sd(3279) == 21\n  println(\"Fim dos testes\")\nend\n\nfunction sd(x)\n  if x == 0\n     return 0\n  else\n     d = x % 10\n     return d + sd(div(x, 10))\n  end\nend\n\nfunction sd1(x)\n  soma = 0\n  while x != 0\n   d = x % 10\n   soma = soma + d\n   x = div(x, 10)\n  end\n  return soma\nend\ntestaSD()\n\nFim dos testes",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Uma outra forma de se fazer laços</span>"
    ]
  },
  {
    "objectID": "chapters/08-exercicios.html",
    "href": "chapters/08-exercicios.html",
    "title": "8  Aula de exercícios",
    "section": "",
    "text": "8.1 Revisitando o cálculo do fatorial, recursivo e interativo\nAgora que aprendemos a fazer também repetições com o comando while, sempre é bom pensar em qual o comando mais adequado. Vejamos o exemplo abaixo com duas versões da função para o cálculo do Fatorial.\nfunction fatorial_recursivo(n::Int64) # Com o ::Int64 estamos definindo que o parâmetro da função deve ser um número inteiro\n    # Caso base do fatorial: 0! e 1! são iguais a 1\n    if n == 0 || n == 1\n        return 1\n    # Chamada recursiva: n! = n * (n-1)!\n    else\n        return n * fatorial_recursivo(n - 1)\n    end\nend\n\nfunction fatorial_iterativo(n::Int64)\n    # Inicializa o resultado como 1 (já que o fatorial de 0 é 1)\n    resultado = 1\n\n    # No loop estamos fazendo a multiplicação: n * (n-1) * ... * 2\n    while n &gt; 1\n        # Multiplica o resultado pelo valor atual de n\n        resultado *= n\n\n        # Decrementa n em 1 para continuar o cálculo do fatorial\n        n -= 1\n    end\n    return resultado\nend\n\nprintln(fatorial_recursivo(3))\n\n6\nNo código acima temos uma novidade, nos parâmetros da função, o tipo está sendo declarado expicitamente. No caso, estamos dizendo que o valor n que a função vai receber é de um tipo específico. Ou seja um Inteiro de 64 bits.\nO estilo de código está um pouco diferente do que antes, pois foi escrito por outra pessoa. A monitora. Vemos que ela tem o hábito de usar nomes de variáveis maiores além do que usar contrações como += e *=.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Aula de exercícios</span>"
    ]
  },
  {
    "objectID": "chapters/08-exercicios.html#aproximação-da-raiz-quadrada",
    "href": "chapters/08-exercicios.html#aproximação-da-raiz-quadrada",
    "title": "8  Aula de exercícios",
    "section": "8.2 Aproximação da raiz quadrada",
    "text": "8.2 Aproximação da raiz quadrada\nPara o próximo exemplo, vamos ver o método de Newthon-Raphson para o cálculo da raiz quadrada. É um método recursivo no qual o próximo valor é baseado no valor anterior. Quanto mais chamadas forem feitas, mais próximo do valor final vai se chegar.\nMais informações sobre o método podem ser encontradas em aqui. Mas para o momento temos que pensar na seguinte implementação. Para se calcular a raiz, podemos usar a seguinte fórmula, a partir de um palpite inicial r, para o valor da raiz de x.\n\\[ r_{n+1} = 0.5 * (r + x / r)\\]\nComo o código abaixo é mais complicado, foram usados comentários.\n\nfunction aproxima_raiz(x::Float64, epsilon::Float64)::Float64\n    if x &lt; 0\n        return nothing\n    end\n\n    # Chute inicial \n    aproximacao = x/2\n    melhor_aproximicao = aproximacao\n\n    while true\n        # Fórmula para aproximação de raiz quadrada utilizando o método de Newthon-Raphson\n        melhor_aproximicao = 0.5 * (aproximacao + x/aproximacao)\n\n        # Se a distância absoluta entre os dois pontos é menor do que epsilon, então podemos parar o método\n        if abs(aproximacao - melhor_aproximicao) &lt;= epsilon\n            break\n        end\n\n        # Se a aproximação ainda não for boa o sufuciente, então atualizamos a aproximação para a próxima iteração\n        aproximacao = melhor_aproximicao\n    end\n\n    return melhor_aproximicao\n\nend\n\naproxima_raiz (generic function with 1 method)\n\n\nNotem que foi introduzido um comando novo, o break, esse comando apenas interrompe a execução do while. Ou seja, força a saída do laço.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Aula de exercícios</span>"
    ]
  },
  {
    "objectID": "chapters/08-exercicios.html#verificar-se-um-número-é-primo",
    "href": "chapters/08-exercicios.html#verificar-se-um-número-é-primo",
    "title": "8  Aula de exercícios",
    "section": "8.3 Verificar se um número é primo",
    "text": "8.3 Verificar se um número é primo\nNo próximo exemplo, vamos verificar se um número é primo, ou seja, se os seus únicos divisores são 1 e o próprio. A forma mais simples de se fazer isso é procurando dividir o número por outros. Se algum dividir, o número não é primo.\n\nfunction verifica_primo(num :: Int64)\n    if num &lt;= 1\n        return false\n    end\n    i=2\n    # pode ser melhorado com i&lt;=num/2\n    # ou também com i&lt;= sqrt(num): baseado no fato que um número composto deve ter um fator menor ou igual a raiz desse número\n    while i&lt;num\n        if num % i == 0\n            return false\n        end\n        i+=1\n    end\n    return true\nend\n\nverifica_primo (generic function with 1 method)\n\n\nAssim, como o comando break é usado para interromper a execução de um laço, o comando return, pode ser usado para terminar a execução de uma função, a qualquer momento.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Aula de exercícios</span>"
    ]
  },
  {
    "objectID": "chapters/08-exercicios.html#verificar-se-um-número-é-palíndromo",
    "href": "chapters/08-exercicios.html#verificar-se-um-número-é-palíndromo",
    "title": "8  Aula de exercícios",
    "section": "8.4 Verificar se um número é palíndromo",
    "text": "8.4 Verificar se um número é palíndromo\nUm número palíndromo é um número que é simétrico. Ou seja, a leitura dos dígitos da esquerda para a direita é igual a leitura dos dígitos na ordem inversa. Por exemplo, o número 121 é palíndromo, assim como o 11 e o 25677652. Os números de um dígito também são.\n\nfunction e_palindromo(n::Int64)\n    #=\n        Guarda os dígitos de n que ainda devem ser invertidos\n        A variável auxiliar é necessária para que o valor de n não seja, perdido, e possamos usar ele posteriormente.\n    =#\n    aux = n\n    # Guarda a inversão do número n \n    n_inv = 0\n\n    #=\n        Continuamos o while enquanto ainda há números a serem invertidos,\n        ou seja, enquanto aux for maior que 0.\n    =#\n    while aux &gt; 0 \n        # Coloca o último dígito de aux na variável que guarda a inversão\n        resto = aux % 10\n        n_inv= n_inv * 10 + resto\n\n        # Retira o último dígito de aux\n        aux = div(aux,10)\n    end\n\n    if n == n_inv\n        println(\"O número $n é palíndromo\")\n    else\n        println(\"O número $n não é palíndromo\")\n    end \nend\n\ne_palindromo(2002)\ne_palindromo(1234)\n\nO número 2002 é palíndromo\nO número 1234 não é palíndromo",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Aula de exercícios</span>"
    ]
  },
  {
    "objectID": "chapters/09-exercicios-cont.html",
    "href": "chapters/09-exercicios-cont.html",
    "title": "9  Revisitando a aula passada",
    "section": "",
    "text": "9.1 Aleatoreidade\nAlém de discutirmos o que vimos na aula passada. Nessa aula, vimos uma nova solução para o problema de verificar de um número é palíndromo.\nPara isso usamos uma técnica um pouco diferente, ou seja, ao invés de inverter o número e compará-lo com o original. Verificamos se os seus extremos são iguais.\nObserve o número 234432, o primeiro passo seria verificar que nos extremos, mais significativo e menos significativo, temos os números 2. Em seguida, podemos continuar com a verificação para o número 3443. Se em algum momento a verificação falhar o número não é palíndromo.\nSeguem os testes e o código abaixo.\nEm julia temos a função rand() que devolve um número em ponto flutuante entre 0 e 1. Conforme os parâmetros, podemos ter outros tipos de número como:\nrand(Int)  # devolve um inteiro\nrand(1:10) # devolve um número entre 1 e 10\nrand(Bool) # devolve verdadeiro ou falso\n\ntrue\nMas, antes de ver um código com rand(). Vamos pensar em um problema da vida real. Imagine que temos que fazer um sorteio justo, e o único instrumento que possuímos para o sorteio é uma moeda viciada. Que tem como resultado muito mais faces do que coroas. Dá para usar essa moeda em um sorteio justo?\nA ideia para resolver o problema é olhar para pares de sorteios. Ou seja, vamos ignorar sorteios onde tenhamos duas faces ou duas coroas. Nos outros, teremos uma coroa e uma face ou vice versa. As chances das duas serão de 50%. Logo podemos assim, corrigir a moeda viciada.\nPara simplificar o exercício, a moeda pode devolver 0, ou 1, correspondentes a cara ou a coroa. Observe a seguinte função que simula uma moeda viciada.\nfunction sorteio()\n  if rand() &gt; 0.90\n    return 1\n  else \n    return 0\n  end\nend\n\nsorteio (generic function with 1 method)\nPode se observar que a função devolve 0 na maior parte das vezes. Podemos inclusive ver isso, fazendo mil sorteios:\nfunction verificaSorteio()\n   cara = 0\n   coroa = 0\n   i = 0\n   while i &lt; 1000\n     if sorteio() == 0\n        cara = cara + 1\n     else\n        coroa = coroa + 1\n     end\n     i = i + 1\n   end\n   println(\"O número de caras foi: \", cara,\" e de coroas foi :\", coroa)\nend\n\nverificaSorteio (generic function with 1 method)\nMas, podemos corrigir o sorteio da seguinte forma:\nfunction sorteioBom()\n   sorteio1 = sorteio()\n   sorteio2 = sorteio()\n   while sorteio1 == sorteio2 # se forem iguais, tente novamente\n     sorteio1 = sorteio()\n     sorteio2 = sorteio()\n   end\n   return sorteio1   # ao termos um diferente, podemos devolver o primeiro sorteio\nend\n\nsorteioBom (generic function with 1 method)\nPodemos usar o verificaSorteio para ver a diferença.\nfunction verificaSorteio()\n   cara = 0\n   coroa = 0\n   i = 0\n   while i &lt; 1000\n     if sorteioBom() == 0\n        cara = cara + 1\n     else\n        coroa = coroa + 1\n     end\n     i = i + 1\n   end\n   println(\"O número de caras foi: \", cara,\" e de coroas foi :\", coroa)\nend\n\nverificaSorteio (generic function with 1 method)\nPodemos ainda aproximar o número de Euler (𝑒), constante matemática que é a base dos logaritmos naturais, usando uma simulação probabilística. A ideia por trás desse código é que o número médio de tentativas necessárias para que a soma de números aleatórios entre 0 e 1 ultrapasse 1 se aproxima do valor de 𝑒. Isso é baseado em uma relação matemática que conecta essa situação ao número 𝑒.\nfunction calculaEuler(total)\n    soma_tentativas = 0\n    for i in 1:total\n        soma = 0.0\n        tentativas = 0      \n        while soma &lt;= 1   # Continue gerando números até a soma ultrapassar 1\n            soma += rand()     # Gera número aleatório entre 0 e 1\n            tentativas += 1\n        end        \n        soma_tentativas += tentativas     # Somar o número de tentativas necessárias\n    end \n    return soma_tentativas / total     # A média do número de tentativas será uma estimativa de e\nend\n\nprintln(\"Estimativa de e (1000 iterações): \", calculaEuler(1000))\nprintln(\"Estimativa de e (100000 iterações): \", calculaEuler(100000))\nprintln(\"Estimativa de e (100000000 iterações): \", calculaEuler(100000000))\n\nEstimativa de e (1000 iterações): 2.657\nEstimativa de e (100000 iterações): 2.72055\nEstimativa de e (100000000 iterações): 2.71821212\nPara terminar a aula vamos aplicar o método de Monte Carlo para o cálculo de Pi. Imaginem o primeiro quadrante, onde temos um semi-círculo de raio 1, dentro de um quadrado de lado 1. Podemos sortear valores, os que sairem dentro do círculo podem contar para a área desse. Mais informações podem ser vistas aqui (https://pt.wikipedia.org/wiki/M%C3%A9todo_de_Monte_Carlo)\nfunction calculaPi(total)\n   noAlvo = 0\n   i = 0\n   while i &lt; total\n     x = rand() / 2.0 # gera um número entre 0 e 0.5\n     y = rand() / 2.0\n     if sqrt(x * x + y * y) &lt;= 0.5\n       noAlvo = noAlvo + 1\n     end\n     i = i + 1\n   end\n   return 4 * (noAlvo / total)  # precisamos multiplicar para ter a área de 4 quadrantes\nend \n\nprintln(calculaPi(100))\nprintln(calculaPi(1000000))\nprintln(calculaPi(1000000000))\n\n2.96\n3.141104\n3.141609584",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Revisitando a aula passada</span>"
    ]
  },
  {
    "objectID": "chapters/10-entrada-dados.html",
    "href": "chapters/10-entrada-dados.html",
    "title": "10  Entrada de dados e o começo de listas",
    "section": "",
    "text": "10.1 O comando input\nNessa aula, temos dois tópicos principais, como fazer a entrada de dados, através de comandos de entrada e com argumentos na linha de comando. Além disso também veremos como tratar de um tipo especial de variável, onde é possível, guardar mais de um valor.\nQuando queremos inserir dados, em Julia, basta colocar dados. Mas, como podemos fazer para entrar dados em um programa comum?\nPara isso temos o comando readline(), que interrompe a execução do programa e espera pela entrada de uma String, o que ocorre quando a tecla “enter” é pressionada.\nprintln(\"Digite o seu nome\")\nresposta = readline()\nprintln(\"O seu nome é: \", resposta)\nCaso, ao rodar o programa, você digitar Maria, e pressionar a tecla enter, a resposta final do seu programa será O seu nome é: Maria.\nComo o readline() lê Strings, se quisermos ler números, é necessário usar o comando parse. O comando parse de forma simples possui dois parâmetros, o primeiro corresponde ao tipo que se quer transformar, e o segundo o valor original.\nprintln(\"Digite um inteiro\")\nvalor = parse(Int64, readline())\nprintln(\"O numero digitado foi \", valor)\nSabendo ler números do teclado, vamos a um exercício simples, ler uma sequência de números inteiros terminada por zero e devolver a sua soma.\nfunction somaVarios()\n    soma = 0.0\n    println(\"Digite um número\")\n    n = parse(Float64, readline())\n    while  n!=0\n        soma = soma + n\n        println(\"Digite um número\")\n        n = parse(Float64, readline())\n    end\n    println(\"A soma é: \", soma)\nend\nObserve o seguinte exemplo que calcula os quadrados dos números de uma lista terminada por zero.\nfunction leQ()\n  x = readline()\n  n = parse(Float64, x)\n  while n != 0\n    println(\"$n ao quadrado é \", n * n)\n    x = readline()\n    n = parse(Float64, x)\n  end\nend\nNotem que o readline também pode receber uma variável de arquivo para que dados sejam lidos diretamente. Mas, nesse caso temos que tomar Ocuidado para abrir (open()) e fechar (close()) o arquivo. Como abaixo:\nfunction leQ()\n    println(\"Digite um número\")\n    f = open(\"numeros.txt\", \"r+\")\n    x = readline(f)\n    n = parse(Float64, x)\n    while n != 0\n        println(\"$n ao quadrado é \", n * n)\n        println(\"Digite outro número\")\n        x = readline(f)\n        n = parse(Float64, x)\n    end\n    close(f)\nend",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Entrada de dados e o começo de listas</span>"
    ]
  },
  {
    "objectID": "chapters/10-entrada-dados.html#lendo-através-da-linha-de-comando",
    "href": "chapters/10-entrada-dados.html#lendo-através-da-linha-de-comando",
    "title": "10  Entrada de dados e o começo de listas",
    "section": "10.2 Lendo através da linha de comando",
    "text": "10.2 Lendo através da linha de comando\nA outra forma de ler comandos é através da constante ARGS que é preparada na chamada de um programa. Para entender melhor isso, vamos ver o seguinte programa.\n\nprintln(ARGS)\n\nSe a linha acima está no arquivo args.jl, ao chamar julia args.jl com diversos parâmetros, teremos diversos resultados diferentes.\nPor exemplo ao chamar:\njulia args.jl 1 2 3 abc\nTeremos como resposta\n\n[\"1\", \"2\", \"3\", \"abc\"]\n\nVamos analisar um pouco melhor essa resposta observando que cada parâmetro está em uma posição.\n\ntam = length(ARGS)\nprintln(\"O tamanho dos argumentos é: \", tam)\nfor i in 1:tam\n    println(ARGS[i])\nend\n\nOlhando o código acima, podemos ver que a função length() devolve o número de argumentos, ou seja, o tamanho da lista ARGS. Além disso com os colchetes é possível acessar a cada posição da lista de forma individual.\nO exemplo abaixo soma os parâmetros inteiros dados como argumentos. Ele também ilustra uma boa prática que é, sempre colocar o código em módulos, no caso abaixo em funções:\n\nfunction SomaEntrada()\n    tam = length(ARGS)\n    s = 0\n    i = 1\n    while i &lt;= tam\n        valor = parse(Int, ARGS[i])\n        println(valor)\n        s = s + valor\n        i = i + 1\n    end\n    println(\"A soma foi: \", s)\nend\nSomaEntrada()\n\nA flexibilidade que temos ao usar listas é enorme! Por isso, listas ou vetores, merecem um tópico próprio.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Entrada de dados e o começo de listas</span>"
    ]
  },
  {
    "objectID": "chapters/10-entrada-dados.html#listas",
    "href": "chapters/10-entrada-dados.html#listas",
    "title": "10  Entrada de dados e o começo de listas",
    "section": "10.3 Listas",
    "text": "10.3 Listas\nVamos primeiro brincar um pouco no console.\n\nvetor = [1, 2, 3]\nprintln(vetor[1])\nprintln(length(vetor))\nvetor[2] = vetor[2] + 1\nvetor[1] = 2 * vetor[3]\nprintln(vetor)\n\n1\n3\n[6, 3, 3]\n\n\nComo disse antes, o for foi feito para manipular vetores, vamos ver umas funções, a primeira que imprime os elementos de um vetor um por linha.\n\nfunction imprimeVetor(v)\n    for el in v\n        println(el)\n    end\nend\n\nIsso também pode ser feito por meio dos índices do vetor:\n\nfunction imprimeVetor(v)\n    for i in 1:lenght(v)\n        println(v[i])\n    end\nend\n\nComo cada posição é independente, podemos calcular a soma dos elementos ímpares de um vetor\n\nfunction somaImpVetor(v)\n    soma = 0\n    for i in 1:length(v)\n        if v[i] % 2 == 1\n            soma = soma + v[i]\n        end\n    end\n    return soma\nend\n\nTambém vimos em aula alguns outros exemplos, como calcular a média dos elementos em um vetor.\n\nfunction mediaV(v)\n   soma = 0.0\n   for i in v\n      soma = soma + i\n   end\n   return soma / length(v)\nend\n\nDevolver a soma dos elementos ímpares de um vetor\n\nfunction somaImpar(v)\n    soma = 0\n    for i in v\n        if i % 2 == 1\n            soma = soma + i\n        end\n    end\n    return soma\nend\n\nImprimir os números divisíveis por 5 de um vetor.\n\nfunction imprimeDivisivelPor5(v)\n    for i in v\n        if i % 5 == 0\n            println(i)\n        end\n    end\nend\n\nCom uma pequena variação e usando o comando push!() podemos ver como devolver um vetor com os números divisíveis por 5.\n\nfunction devolveDivisivelPor5(v)\n    x = []  # começa com um vetor vazio\n    for i in v\n        if i % 5 == 0\n            push!(x, i)  # adiciona um elemento ao vetor x\n        end\n    end\n    return x\nend\n\n\n10.3.1 Álgebra linear e Listas\nA manipulação de listas é uma parte fundamental da álgebra linear, que estuda vetores e matrizes. Funções como o produto escalar de dois vetores são exemplos clássicos. Abaixo temos dois exemplos de produto escalar de dois vetores. lembrado esse é definido como a soma dos produtos de elementos em posições iguais.\n\nfunction dotProduct(a, b)\n    soma = 0\n    if length(a) != length(b)\n       return soma   # o produto não está definido se os tamanhos são diferentes\n    end\n    for i in 1:length(a)\n        soma = soma + a[i] * b[i]\n    end\n    return soma\nend\n\nAcima vimos que um caso especial do uso do for, consiste em fazer Ofor varias entre 1 e um tamanho (1:lenght(a))\nObservem a diferença na versão abaixo:\n\nfunction dotProduct(a, b)\n    soma = 0\n    if length(a) != length(b)\n       return soma   # o produto não está definido se os tamanhos são diferentes\n    end   \n    i = 1\n    for x in a\n        soma = soma + x * b[i]\n        i = i + 1\n    end \n    return soma\nend\n\n\n\n10.3.2 Exercício de permutação\nPara terminar, vamos fazer uma função onde dado um vetor de inteiros de tamanho \\(n\\), verifica se esse vetor é uma permutação dos números de 1 a \\(n\\). Para isso, veremos se cada número de 1 a \\(n\\) está no vetor.\nMas, sem esquecer dos testes:\n\n@testset \"Verifica Permutação\" begin\n    @test permuta([1,2,3])\n    @test permuta([3, 2, 1])\n    @test permuta([1])\n    @test permuta([2, 1])\n    @test permuta([4, 2, 3, 1])\n    @test !permuta([1, 1])\n    @test !permuta([1, 3])\n    @test permuta([])\nend\n\ne o código:\n\nfunction permuta(v)\n   tam = length(v)\n   for i in 1:tam\n      if  !(i in v)\n         return false\n      end\n   end\n   return true\nend\n\nFoi usado o comando in de Julia que verifica se um elemento está no vetor.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Entrada de dados e o começo de listas</span>"
    ]
  },
  {
    "objectID": "chapters/11-exercicios-2.html",
    "href": "chapters/11-exercicios-2.html",
    "title": "11  Exercícios com vetores",
    "section": "",
    "text": "11.1 Permutação\nOs vetores permitem que sejam realizados algoritmos bem mais complexos, nesse capítulo veremos algums exercícios.\nDado um vetor com inteiros, queremos verificar se esse vetor contém uma permutação. Para isso, temos que verificar em um vetor de tamanho n, se ele contém os números de 1 a n exatamente uma vez cada 1. O vetor [3, 1, 2] é uma permutação, pois tem tamanho 3 e os elementos de 1 a 3 aparecem uma vez.\nUma forma de se resolver esse problema é por meio de um indicador de passagem. Inicialmente vamos supor que o vetor é uma permutação, em seguida verificamos se todos os números entre 1 e n estão no vetor. Isso pode ser feito com comando in, que verifica se um elemento pertence ao vetor.\nfunction permutação(l)\n    perm = true\n    tamanho = length(l)\n    i = 1\n    while i &lt;= tamanho\n        if !(i in l)\n            perm = false\n        end    \n        i += 1\n    end\n    return perm\nend\n\npermutação (generic function with 1 method)\nUma outra alternativa é verificar se para cada elemento do vetor, se ele está entre 1 e n, e é unico. Ou seja, verificamos se o primeiro elemento está entre 1 e n, e depois percorremos o vetor para ver se ele é único. Em seguida fazemos isso para os elementos seguintes. O código fica:\nfunction permutação(l)\n    perm = true\n    tamanho = length(l)\n    i = 1\n    while i &lt;= tamanho\n        if (l[i] &gt; tamanho || l[i] &lt;= 0)\n            perm = false\n        end\n        j = i +1\n        while j &lt;= tamanho\n            if l[j] == l[i]\n                perm = false\n            end\n            j += 1\n        end\n        i += 1\n    end\n    return perm\nend\n\npermutação (generic function with 1 method)\nUma outra alternativa é ter um vetor auxiliar onde contamos as ocorrências de cada número entre 1 e n. Ao final, todos os elementos desse vetor auxiliar tem que valer 1. Dessa vez, aproveitamos e já colocamos os testes automatizados.\nusing Test\nfunction permutação(l)\n    perm = true\n    tamanho = length(l)\n    aux = zeros(Int8, tamanho)\n    for i in l\n      if i &lt; 1 || i &gt; tamanho\n        perm = false\n      else\n        aux[i] += 1\n      end\n    end\n    for i in aux\n      if i != 1\n        perm = false\n      end\n    end  \n    return perm\nend\n\n@testset \"Verifica Permutação\" begin\n    @test permutação([1,2,3])\n    @test permutação([3, 2, 1])\n    @test permutação([1])\n    @test permutação([2, 1])\n    @test permutação([4, 2, 3, 1])\n    @test !permutação([1, 1])\n    @test !permutação([1, 3])\n    @test !permutação([4, 2, 3, -1])\n    @test !permutação([5, 2, 3, 1])\n    @test permutação([])\n    @test !permutação([0, 3, 3])\n    @test !permutação([2, 2, 2])\nend\n\nTest Summary:       | Pass  Total  Time\nVerifica Permutação |   12     12  0.1s\n\n\nTest.DefaultTestSet(\"Verifica Permutação\", Any[], 12, false, false, true, 1.741131086041957e9, 1.74113108614224e9, false, \"/Users/lucas/Desktop/livro-intro-comp-julia/chapters/11-exercicios-2.qmd\")",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Exercícios com vetores</span>"
    ]
  },
  {
    "objectID": "chapters/11-exercicios-2.html#histograma",
    "href": "chapters/11-exercicios-2.html#histograma",
    "title": "11  Exercícios com vetores",
    "section": "11.2 Histograma",
    "text": "11.2 Histograma\nJá que vimos o exemplo anterior onde “contamos” o número, podemos ir um pouco além e calcular o histograma de um vetor com números entre 1 e 10.\n\nusing Test\n\nfunction histograma(l)\n    result = [0,0,0,0,0,0,0,0,0,0]\n    i = 1\n    while i &lt;= length(l)\n        valor_atual = l[i]\n        if valor_atual &gt;= 1 && valor_atual &lt;= 10\n           result[valor_atual] += 1\n        end\n        i += 1\n    end\n    return result\nend\n\n@testset \"Verifica Histograma\" begin\n    @test [1,0,0,0,0,0,0,0,0,0] == histograma([1])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([-1])\n    @test [0,0,1,0,0,0,0,0,0,0] == histograma([3])\n    @test [0,0,0,0,0,0,0,0,0,1] == histograma([10])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([11])\n    @test [1,4,0,2,5,1,0,1,0,0] == histograma([5,6,5,4,5,5,4,2,8,2,1,2,5,2])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([])\n    end\n\nTest Summary:       | Pass  Total  Time\nVerifica Histograma |    7      7  0.0s\n\n\nTest.DefaultTestSet(\"Verifica Histograma\", Any[], 7, false, false, true, 1.741131086366627e9, 1.741131086409608e9, false, \"/Users/lucas/Desktop/livro-intro-comp-julia/chapters/11-exercicios-2.qmd\")",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Exercícios com vetores</span>"
    ]
  },
  {
    "objectID": "chapters/11-exercicios-2.html#modelando-problemas-com-o-computador",
    "href": "chapters/11-exercicios-2.html#modelando-problemas-com-o-computador",
    "title": "11  Exercícios com vetores",
    "section": "11.3 Modelando problemas com o computador",
    "text": "11.3 Modelando problemas com o computador\nO computador pode ser uma ferramenta bem poderosa para a modelagem de problemas reais. Para isso vamos pegar o caso do problema dos aniversários. Esse problema também é conhecido pelo paradoxo do aniversário: Calcular a probabilidade de que em uma sala com n pessoas, pelo menos duas possuam a mesma data de aniversário. Esse problema pode ser resolvido usando probabilidade, por meio da qual se descobre que se a sala tem 23 pessoas a chance de duas terem a mesma data é de pouco mais de 50%.\nMas, também podemos modelar esse problema computacionalmente. Para isso, o primeiro passo é simplificar as datas, ao invés de mês e ano, podemos codificar os dias em um número entre 1 e 365, sendo que 1 corresponderia a primeiro de janeiro. Para resolver o problema, podemos sortear n datas, e ver se há alguma repetição, se houver encontramos duas pessoas com a mesma data.\nIsso está representado na função experimento_niver abaixo. Mas, para saber a chance real, temos que repetr o experimento várias vezes. Na função main() abaixo, pedimos a quantidade de experimentos e o número de pessoas para executar a simulação.\n\nfunction experimento_niver(n)\n    repetiu = false\n    i = 1\n    nivers = []\n    while i &lt;= n && (repetiu == false)\n        niver = rand(1:365)\n        if niver in nivers\n            repetiu = true\n        end\n        push!(nivers, niver)\n        i += 1\n    end\n    return repetiu\nend\n\nfunction main()\n    print(\"Quantos experimentos? \")\n    quantas = readline()\n    print(\"Quantas pessoas? \")\n    npessoas = readline()\n    quantas = parse(Int64, quantas)\n    npessoas = parse(Int64, npessoas)\n    sucessos = 0\n    i = 1\n    while i &lt;= quantas\n        if experimento_niver(npessoas)\n            sucessos += 1\n        end\n        i += 1\n    end\n    println(\"A probabilidade estimada é \", 100*sucessos/quantas, \"%\")\nend\nmain()\n\nA parte interessante é que podemos com pequenas variações ter outros experimentos, como verificar se mais do que duas pessoas fazem aniversário na mesma data. Para isso, abaixo, contamos o número de repetições.\n\nfunction experimento_niver(n)\n    repetiu = 0\n    i = 1\n    nivers = []\n    while i &lt;= n\n        niver = rand(1:365)\n        if niver in nivers\n            repetiu += 1\n        end\n        push!(nivers, niver)\n        i += 1\n    end\n    return repetiu &gt;= 2\nend\n\nexperimento_niver (generic function with 1 method)",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Exercícios com vetores</span>"
    ]
  },
  {
    "objectID": "chapters/12-blackjack.html",
    "href": "chapters/12-blackjack.html",
    "title": "12  Modelando um problema maior",
    "section": "",
    "text": "Nessa aula vamos modelar um jogo bem conhecido, o 21, ou BlackJack. Nele os jogadores devem tentar chegar mais perto da soma de cartas 21, sem estourar. Quem chegar mais perto ganha.\nCada jogador começa com duas cartas, sendo que as cartas tem o seu valor nominal, as figuras (J, Q, K), que valem 10. Além disso, o Ás, pode valer 1 ou 11. O que for mais vantajoso para o jogador.\nPara começar vamos fazer uma simulação com um baralho, ou seja 52 cartas. Já que] para o jogo, não importa o naipe da carta, vamos supor que existem quatro cartas de cada. Para isso, vamos criar duas funções, uma que cria um baralho e o guarda em um vetor, e uma segunda que pega uma carta do baralho. Nessa segunda função temos que “retirar” a carta do vetor. Caso já não exista a carta do tipo desejado, temos que sortear uma nova carta.\n\nfunction criaBaralho()\n  cards = zeros(Int8, 13)\n  i = 1\n  while i &lt; 14\n    cards[i] = 4\n    i += 1\n  end\n  return cards\nend\n\nfunction pegarCarta(cards)\n  sorteio = rand(1:13)\n  while cards[sorteio] == 0\n    sorteio = rand(1:13)\n  end\n  cards[sorteio] -= 1\n  if sorteio &gt; 10  # se a carta for figura, ela vale 10\n    sorteio = 10\n  end  \n  return sorteio\nend\n\npegarCarta (generic function with 1 method)\n\n\nDe posse dessas duas funções, podemos criar outras que simulam o comportamento dos jogadores. Vamos usar algumas estratégias simples, como o jogador que fica com as duas cartas que recebeu.\n\nfunction jogador1(cards)\n  carta1 = pegarCarta(cards)\n  carta2 = pegarCarta(cards)\n  if carta1 == 1 || carta2 == 1\n    return carta1 + carta2 + 10\n  else\n    return carta1 + carta2\n  end  \nend\n\njogador1 (generic function with 1 method)\n\n\nNotem que acima, usamos a estratégia de usar o Ás da forma mais vantajosa.\nPara os outros jogadores, vamos usar estratégias mais elaboradas, ou seja o jogador fica pegando cartas enquanto não chegar a um valor pré-determinado, como por exemplo 21, 19, 17, 15 e 13.\nComo cada jogador pode ter um número grande de cartas e no caso dele ter um Ás, a conta tem que ser feita da maneira mais vantajosa, vamos usar uma função que recebe um vetor de cartas e calcula a soma.\n\nfunction somaCartas(c)\n  soma = 0\n  temAz = false\n  for i in c\n    soma += i\n    if c == 1 \n      temAz = true\n    end\n  end\n  if soma &lt;= 11 && temAz\n      return soma + 10\n  else \n      return soma\n  end\nend\n\nsomaCartas (generic function with 1 method)\n\n\nDe posse do soma cartas, podemos modelar os jogadores.\n\nfunction jogador2(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 21\n    push!(cartas, pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\nfunction jogador3(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 19\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\nfunction jogador4(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 17\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\n  function jogador5(cards)\n    cartas = []\n    push!(cartas, pegarCarta(cards))\n    push!(cartas, pegarCarta(cards))\n    while somaCartas(cartas) &lt; 15\n      push!(cartas,pegarCarta(cards))\n    end\n    return somaCartas(cartas)\n  end\n\nfunction jogador6(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 13\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\njogador6 (generic function with 1 method)\n\n\nAgora que temos todos os jogadores, podemos modelar uma partida. Para isso criamos um baralho e fazemos com que cada jogador siga a sua estratégia\n\nfunction partida()\n  cards = criaBaralho()\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = jogador1(cards)\n  jogadores[2] = jogador2(cards)\n  jogadores[3] = jogador3(cards)\n  jogadores[4] = jogador4(cards)\n  jogadores[5] = jogador5(cards)\n  jogadores[6] = jogador6(cards)\nend\n\npartida (generic function with 1 method)\n\n\nNão deu tempo de continuar, ficou para a próxima aula.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Modelando um problema maior</span>"
    ]
  },
  {
    "objectID": "chapters/13-blackjack-cont.html",
    "href": "chapters/13-blackjack-cont.html",
    "title": "13  Continuando a modelagem",
    "section": "",
    "text": "No capítulo anterior ficamos com uma partida, mas sem a verificação do vencedor, ou seja o jogador com o maior valor, menor ou igual a 21. Uma decisão de projeto é dizer que no caso de empate, os jogadores, com os maiores valores ganham e dividem o prêmio.\n\nfunction partida()\n  cards = criaBaralho()\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = jogador1(cards)\n  jogadores[2] = jogador2(cards)\n  jogadores[3] = jogador3(cards)\n  jogadores[4] = jogador4(cards)\n  jogadores[5] = jogador5(cards)\n  jogadores[6] = jogador6(cards)\n  return jogadores\nend\n\npartida (generic function with 1 method)\n\n\nLogo, a partida devolve a pontuação de cada jogador, para podermos verificar na rotina ganhador quem ganhou.\n\nfunction ganhador(v)\n    i = 1\n    maximo = 0\n    while i &lt;= length(v)\n        if v[i] &gt; 21  # se estourou é como se tivesse o menor valor\n            v[i] = 0\n        end\n        if v[i] &gt; maximo\n            maximo = v[i]  # encontra o vencedor\n        end\n        i = i + 1\n    end\n    result = zeros(Int64, length(v))\n    i = 1\n        while i &lt;= length(v)\n            if v[i] == maximo\n                result[i] = 1\n            end\n            i = i + 1\n        end\n    return result\nend\n\nganhador (generic function with 1 method)\n\n\nA rotinha ganhador devolve um vetor com os vencedores, com 1 na posição de quem ganhou e zero na posição dos perdedores.\nUma das vantagens de se usar um computador é que podemos ter milhares de partidas de 21 para encontrar qual seria a melhor estratégia.\n\nfunction porcentagem()\n    i = 1\n    porc = zeros(Int64, 6)\n    while i &lt; 100000\n        porc = porc + ganhador(partida())\n        i = i + 1\n    end\n    println(porc)\nend\n\nporcentagem (generic function with 1 method)\n\n\nAo simularmos o jogo 10000 vezes, podemos encontrar qual é a melhor estratégia dentre as que foram apresentadas.\nO código acima ficou relativamente grande, e uma das coisas que podemos notar é que há muita duplicação nos códigos dos Jogadores a partir do segundo. Um dos maiores problemas de código é a duplicação. No caso acima, podemos evitá-la adicionando um parâmetro à função Jogador, de forma que esse seja o limite a ser considerado no laço. A função jogador2 fica assim:\n\nfunction jogador2(cards, valor)\n    cartas = []\n    push!(cartas, pegarCarta(cards))\n    push!(cartas, pegarCarta(cards))\n    while somaCartas(cartas) &lt; valor\n       push!(cartas, pegarCarta(cards))\n    end\n    return somaCartas(cartas)\nend\n\njogador2 (generic function with 1 method)\n\n\nComo a função tem um parâmetro novo, temos que acertar a partida. Mas, agora podemos usar todos os valores.\n\nfunction partida()\n   cards = criaBaralho()\n   jogadores = zeros(Int8, 6)\n   jogadores[1] = jogador1(cards)\n   jogadores[2] = jogador2(cards, 21)\n   jogadores[3] = jogador2(cards, 20)\n   jogadores[4] = jogador2(cards, 19)\n   jogadores[5] = jogador2(cards, 18)\n   jogadores[6] = jogador2(cards, 17)\n   return jogadores\nend\n\npartida (generic function with 1 method)\n\n\nNotem que não há mudança na função ganhador, que continua funcionando.\nPara terminar, podemos ter agora uma versão interativa que permite que um jogador humano jogue com o computador.\n\nfunction partidaComHumano()\n    cards = criaBaralho()\n    humano = []\n    computador = jogador2(cards, 19)\n    push!(humano, pegarCarta(cards))\n    push!(humano, pegarCarta(cards))\n    println(\"O humano tem \", humano, \" e soma \", somaCartas(humano))\n    println(\"O humano quer mais cartas (S/N)?\")\n    resp = readline()\n    while resp == \"S\" || resp == \"s\"\n         push!(humano, pegarCarta(cards))\n         println(\"O computador tem \", computador, \" e soma \", somaCartas(computador))\n         println(\"O humano tem \", humano, \" e soma \", somaCartas(humano))\n         println(\"O humano quer mais cartas (S/N)?\")\n         resp = readline()\n    end\n    println(\"O computador tem \", computador, \" e soma \", somaCartas(computador))\n    if somaCartas(computador) &lt;= 21 && somaCartas(humano) &lt;= 21\n         if somaCartas(computador) &gt; somaCartas(humano)\n             println(\"Humano Perdeu\")\n         elseif somaCartas(computador) == somaCartas(humano)\n             println(\"Empate\")\n         else\n             println(\"Humano ganhou\")\n         end\n    elseif somaCartas(computador) &gt; 21 && somaCartas(humano) &gt; 21\n         println(\"os dois perderam\")\n    elseif somaCartas(computador) &gt; 21\n         println(\"Humano ganhou\")\n    else\n         println(\"Computador ganhou\")\n    end\nend\n\npartidaComHumano (generic function with 1 method)",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Continuando a modelagem</span>"
    ]
  },
  {
    "objectID": "chapters/14-boas-praticas.html",
    "href": "chapters/14-boas-praticas.html",
    "title": "14  Boas práticas",
    "section": "",
    "text": "14.1 Uso de contratos\nVamos começar apresentando 3 boas práticas de programação. Na verdade há uma área que cuida de desenvolvimento de software, a Engenharia de Software. Vamos a elas:\nSempre que possível o código deve ser modular, ou seja estar repartido em arquivos e ou funções. Cada tipo de função deve deixar claro quais são os seus parâmetros e o que ela devolve. Isso pode ser feito usando tipos.\nfunction fatorial(n::Int64)::Int64\n    if n &lt; 2 \n        return 1\n    else  \n        return n * fatorial(n - 1)\n    end\nend\n\nfatorial (generic function with 1 method)\nCom isso, fica claro o que a função recebe e devolve, e se for enviado um tipo diferente do esperado, temos em erro imediato.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Boas práticas</span>"
    ]
  },
  {
    "objectID": "chapters/14-boas-praticas.html#uso-de-contratos",
    "href": "chapters/14-boas-praticas.html#uso-de-contratos",
    "title": "14  Boas práticas",
    "section": "",
    "text": "14.1.1 Boa prática 1: Use tipos",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Boas práticas</span>"
    ]
  },
  {
    "objectID": "chapters/14-boas-praticas.html#testes-automatizados",
    "href": "chapters/14-boas-praticas.html#testes-automatizados",
    "title": "14  Boas práticas",
    "section": "14.2 Testes automatizados",
    "text": "14.2 Testes automatizados\nPara evitar que apareçam erros, ou os populates bugs, uma forma eficaz é escrever código que verifica o funcionamento do código. Se isso for feito de forma automática, temos os testes automatizados.\n\nusing Test\nfunction testaFat()\n  @test fatorial(3) == 6\n  @test fatorial(5) == 120\n  @test fatorial(1) == 1\n  @test fatorial(0) == 1\n  @test fatorial(4) == 24\nend\n\ntestaFat (generic function with 1 method)\n\n\n\n14.2.1 Boa prática 2: Sempre que possível faça testes",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Boas práticas</span>"
    ]
  },
  {
    "objectID": "chapters/14-boas-praticas.html#escreva-código-para-humanos-não-para-computadores",
    "href": "chapters/14-boas-praticas.html#escreva-código-para-humanos-não-para-computadores",
    "title": "14  Boas práticas",
    "section": "14.3 Escreva código para humanos, não para computadores",
    "text": "14.3 Escreva código para humanos, não para computadores\nApesar dos computadores serem capazes de ler código nem sempre bem formatado, é bem difícil para humanos lerem código de forma não padrão. Por isso algumas dicas importantes são:\n\nUse identação. Com isso, os blocos ficam bem claros e é fácil identificar os laços, blocos de if e corpos de função;\nEscolha bem o nome das variáveis e funções, isso ajuda muito quem for ler o código\nSempre que você identificar uma possibilidade de melhoria no código, implemente. Ainda melhor se você tiver testes automatizados, para verificar que a melhoria não quebrou o código.\n\n\n14.3.1 Boa prática 3: Escreva código para que outros leiam",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Boas práticas</span>"
    ]
  },
  {
    "objectID": "chapters/14-boas-praticas.html#aplicando-as-boas-práticas",
    "href": "chapters/14-boas-praticas.html#aplicando-as-boas-práticas",
    "title": "14  Boas práticas",
    "section": "14.4 Aplicando as boas práticas",
    "text": "14.4 Aplicando as boas práticas\nVamos agora resolver o seguinte problema, aplicando as práticas acima. Dada um vetor com números reais, determinar os números que estão no vetor e o número de vezes que cada um deles ocorre na mesma.\nAo analizar o problema, vemos que temos como entrada um vetor de número reais, que pode conter repetições. Para determinar os números que estão no vetor, podemos usar um outro vetor de saída. Sendo que o de entrada e o de saída devem ser do tipo Float64. Além disso, para o vetor que fornece a quantidade de números temos um vetor de inteiros. De posse disso, já temos a assinatura da função.\n\nfunction contHist(v::Vector{Float64}, el::Vector{Float64}, qtd::Vector{Int64})\nend\n\ncontHist (generic function with 1 method)\n\n\nDe posse dessa assinatura, já podemos escrever os testes.\n\nfunction verifica(v::Vector{Float64}, elementos::Vector{Float64}, \n     quant::Vector{Int64})\n     el = Float64[]\n     quan = Int64[]\n     contHist(v, el, quan)\n     if el == elementos && quan == quant\n        return true\n     else\n        return false\n     end\nend\n\nfunction testaLista()\n  @test verifica([1.3, 1.2, 0.0, 1.3], [1.3, 1.2, 0.0], [2, 1, 1])\n  @test verifica([1.0, 1.0, 1.0, 1.0], [1.0], [4])\n  @test verifica([8.3], [8.3], [1])\n  @test verifica([3.14, 2.78, 2.78], [3.14, 2.78], [1, 2])\nend\n\ntestaLista (generic function with 1 method)\n\n\nFinalmente, podemos escrever o código. A idea para escrever a solução é simples, vamos percorrer o vetor de entrada. Para cada elemento, temos duas possibilidades, se ele não tiver aparecido antes, temos que adicionar o número ao vetor saída e marcar 1 ocorrência. Se já apareceu, basta incrementar o número de ocorrências.\n\nfunction contHist(v::Vector{Float64}, el::Vector{Float64}, qtd::Vector{Int64})\n    for a in v\n        if a in el\n            i = 1\n            while el[i] != a\n               i += 1\n            end\n            qtd[i] += 1\n        else\n            push!(el, a)\n            push!(qtd, 1)\n        end\n    end\nend\n\ncontHist (generic function with 1 method)",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Práticas",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Boas práticas</span>"
    ]
  },
  {
    "objectID": "chapters/15-matrizes.html",
    "href": "chapters/15-matrizes.html",
    "title": "15  Indo além de uma dimensão (Matrizes)",
    "section": "",
    "text": "Até o momento trabalhamos com estruturas com mais de uma dimensão, mas sem olharmos muito bem o seu tipo. Nessa aula vamos procurar entender as diferenças entre elas e como isso pode ser usado ao nosso favor.\nVamos começar com as listas:\n\nv = [1, 2, 3]\ntypeof(v)\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\nO tipo devolvido é: Vector{Int64} (alias for Array{Int64, 1}). No caso isso significa que v é um vetor de inteiros, ou um array de uma dimensão. Da mesma forma\n\nv = zeros(Int64, 3)\ntypeof(v)\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\nMas, vetores podem ser mais flexíveis, como por exemplo abaixo:\n\nv = [1, 2.0, \"três\"]\ntypeof(v)\n\nVector{Any} (alias for Array{Any, 1})\n\n\nNesse caso o tipo de vetor, deixa de ser de inteiros e passa a ser “Any”, ou seja Vector{Any} (alias for Array{Any, 1}).\nMais ainda, imaginem a seguinte situação:\n\na = [1, 2, 3]\npush!(v, a)\ntypeof(v)\n\nVector{Any} (alias for Array{Any, 1})\n\n\nNesse caso, o vetor continua sendo do tipo Any, mas na quarta posição temos um vetor com três inteiros. Com isso podemos ver que as estruturas de vetores podem ser bem flexíveis. Mas, apesar disso, quando temos estruturas de tipos diferentes, com muita flexibilidade, geralmente há alguma penalidade de uso, geralmente no desempenho.\nPor outro lado, podemos ter estruturas com mais de uma dimensão, no caso elas são denominadas matrizes. Elas podem ser criadas com a função zeros que já usamos acima.\n\nm = zeros(Int64, 3, 2)\ntypeof(m)\n\nMatrix{Int64} (alias for Array{Int64, 2})\n\n\nAcima foi criada uma matriz de duas dimensões com 3 linhas e duas colunas. Seus elementos podem se acessados como em um vetor, mas agora com dois indíces.\n\nm[1, 2]  = 10\n\n10\n\n\n\nfunction imprime(m::Array{Int64,2})\n    println(m)\nend\n\nimprime (generic function with 1 method)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    println(m[1])\n    println(m[2])\nend\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    for i in m\n        println(i)\n    end\n end\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    for i in m\n        for j in m[i]\n            println(j,\"  \")\n        end   \n    end\nend\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    for i in m\n        print(\"|\")\n        for j in i\n            print(j,\"  \")\n        end\n        println(\"|\")   \n    end\nend\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprimeMatriz(m::Matrix{Int64})\n    println(m)\nend\n\nimprimeMatriz (generic function with 1 method)\n\n\n\nfunction imprimeMatriz(m::Matrix{Int64})\n    i = 1\n    while i &lt; size(m)[1]\n        println(m[1])\n        i += 1\n    end\nend\n\nimprimeMatriz (generic function with 1 method)\n\n\n\nfunction imprimeMatriz(m::Matrix{Int64})\n    i = 1\n    while i &lt; size(m)[1]\n        j = 1\n        while j &lt; size(m)[2]\n            print(m[i, j], \" \")\n            j += 1\n        end\n        println()   \n        i += 1\n    end\nend\n\nimprimeMatriz (generic function with 1 method)\n\n\n\nfunction preencheMatriz(m::Matrix{Int64})\n    i = 1\n    while i &lt;= length(m)\n        m[i] = rand(Int) % 10\n        i += 1\n    end\nend\n\npreencheMatriz (generic function with 1 method)\n\n\n\nfunction criaIdentidate(tam::Int64)\n    m = zeros(Int64, tam, tam)\n    i = 1\n    while i &lt;= tam\n        m[i, i] = 1\n    end\n    return m  \nend\n\ncriaIdentidate (generic function with 1 method)\n\n\nOperações diretas com matrizes tipo +, - e *",
    "crumbs": [
      "Parte III: Conceitos Avançados",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Indo além de uma dimensão (Matrizes)</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html",
    "href": "chapters/16-exercicios-3.html",
    "title": "16  Aula de exercícios sobre Strings",
    "section": "",
    "text": "16.1 Concatenação de letras\nNesta aula, vamos explorar funções que manipulam strings e criar testes para verificar sua correção. Em algumas funções, vamos notar que há diversas formas de se obter o mesmo resultado\nA primeira função concatena concatena as primeiras duas e as últimas duas letras de uma string.\nfunction concatena(s::String)::String\n    if length(s) &lt; 2\n        return \"Erro: tamanho da string menor do que 2\"\n    end\n    resposta = s[1:2]*s[end-1:end]\n    return resposta\nend\n\nconcatena (generic function with 1 method)\nAwui utulizamos s[1:2] para obter as duas primeiras letras de s, que é uma forma mais concisa de acessar mais de um índice de um objeto. Alternativamente, poderíamos acessar esses dois índices separadamente com o comando s[1]*s[2].\nPara verificar se a função está funcionando corretamente, podemos utilizar o seguinte teste:\nusing Test\n\nfunction testeConcatena()\n  @test concatena(\"Ola Bom Dia\") == \"Olia\"\n  @test concatena(\"oi\") == \"oioi\"\n  @test concatena(\"tre\") == \"trre\"\n  @test concatena(\"a\") == \"Erro: tamanho da string menor do que 2\"\n  @test concatena(\"a123\") == \"a123\"\nend\n\ntesteConcatena (generic function with 1 method)",
    "crumbs": [
      "Parte III: Conceitos Avançados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aula de exercícios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html#inversão-de-string",
    "href": "chapters/16-exercicios-3.html#inversão-de-string",
    "title": "16  Aula de exercícios sobre Strings",
    "section": "16.2 Inversão de String",
    "text": "16.2 Inversão de String\nDevemos criar uma função que interte uma string, retornando os caracteres na ordem reversa.\n\nfunction inverte(s::String)::String\n    # Inicializamos uma string vazia\n    inversa=\"\"\n\n    # Intervalo de lenght(s) até 1, a passos de -1\n    for i in length(s):-1:1\n        # Concatena cada caractere na ordem inversa\n        inversa*=s[i]\n    end\n\n    return inversa\nend\n\ninverte (generic function with 1 method)\n\n\nPara obter o resultado que desejamos, fazemos um laço for que itera do último índice da string, representado por length(s), até o primeiro, concatenando os caracteres nessa ordem na string de retorno. O laço é configurado para decrementar o índice a cada iteração, especificando -1 como passo. Isso nos permite acessar cada caractere da string de trás para frente. E em cada iteração, concatenamos o caractere atual, s[i], à string inversa. Dessa forma, os caracteres são adicionados na ordem inversa.\nAgora podemos criar uma função de teste para verificar o funcionamento da nossa função inverte.\n\nusing Test\n\nfunction testeInverte()\n  @test inverte(\"123\") == \"321\"\n  @test inverte(\"x\") == \"x\"\n  @test inverte(\"SOS\") == \"SOS\"\n  @test inverte(\"tres\") == \"sert\"\nend\n\ntesteInverte (generic function with 1 method)\n\n\n\n16.2.1 Função reverse\nÉ interessante notar que Julia já fornece uma função chamada reverse, que pode ser utilizada para inverter tanto vetores quanto strings. Por exemplo:\n\nreversa = reverse(\"exemplo\")\n\n\"olpmexe\"\n\n\nNeste exemplo, a função reverse recebe como parâmetro apenas o objeto a ser invertido, mas no caso de vetores, podemos ainda informar exatamente o intervalo que desejamos que seja invertido.\n\nvetor = [1, 2, 3, 4, 5]\nreversa = reverse(vetor, 2, 4)\n\n5-element Vector{Int64}:\n 1\n 4\n 3\n 2\n 5",
    "crumbs": [
      "Parte III: Conceitos Avançados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aula de exercícios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html#modificação-de-string",
    "href": "chapters/16-exercicios-3.html#modificação-de-string",
    "title": "16  Aula de exercícios sobre Strings",
    "section": "16.3 Modificação de String",
    "text": "16.3 Modificação de String\nA terceira função modifica altera uma string que termina com “ing” para adicionar “ly” ou, caso contrário, adiciona “ing”.\n\nfunction modifica(s::String)::String\n    if length(s) &lt; 3\n        return \"Erro: tamanho da string menor do que 3\"\n    end\n    \n    if s[end-2:end] == \"ing\"\n        s = s*\"ly\"\n    else    \n        s = s*\"ing\"                \n    end\n\n\n    return s\nend\n\nmodifica (generic function with 1 method)\n\n\nNeste exemplo, verificamos manualmente os últimos três caracteres da string s. No entanto, Julia oferece uma função mais prática e legível chamada endswith, que podemos usar para simplificar essa verificação.\n\nfunction modifica(s::String)::String\n    if length(s) &lt; 3\n        return \"Erro: tamanho da string menor do que 3\"\n    end\n    \n    if endswith(s, \"ing\")\n        s = s*\"ly\"\n    else    \n        s = s*\"ing\"                \n    end\n\n    return s\nend\n\nmodifica (generic function with 1 method)\n\n\nVamos então escrever o teste que verifica o correto funcionamento das funções anteriores\n\nusing Test\nfunction testaModifica()\n  @test modifica(\"doing\") == \"doingly\"\n  @test modifica(\"sing\") == \"singly\"\n  @test modifica(\"run\") == \"runing\"\n  @test modifica(\"talk\") == \"talking\"\nend\n\ntestaModifica (generic function with 1 method)",
    "crumbs": [
      "Parte III: Conceitos Avançados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aula de exercícios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html#rearranjo-de-letras",
    "href": "chapters/16-exercicios-3.html#rearranjo-de-letras",
    "title": "16  Aula de exercícios sobre Strings",
    "section": "16.4 Rearranjo de letras",
    "text": "16.4 Rearranjo de letras\nA segunda função rearranja recebe uma string e devolve uma string que contém as letras minúsculas primeiro, seguidas pelas letras maiúsculas.\nPodemos verificar se uma letra é maiúscula ou minúscula usando a tabela ASCII, que codifica caracteres em números inteiros. Na tabela, as letras maiúsculas estão no intervalo de 65 a 90, e as letras minúsculas no intervalo de 97 a 122.\nPara saber mais sobre a tabela ASCII você pode acessar essa página.\n\nfunction rearranja(s::String)::String\n    maiusculos=\"\"\n    minusculos=\"\"\n\n    for i in 1:length(s)\n        if Int(s[i]) &gt;= 65 && Int(s[i]) &lt;= 90 \n            maiusculos = maiusculos*s[i]\n        elseif Int(s[i]) &gt;= 97 && Int(s[i]) &lt;= 122\n            minusculos = minusculos*s[i]\n        end \n    end\n\n    return minusculos*maiusculos\n     \nend\n\nrearranja (generic function with 1 method)\n\n\nUma abordagem mais legível é utilizar as funções islowercase e isuppercase, que verificam se uma letra é minúscula ou maiúscula, respectivamente.\n\nfunction rearranja(s::String)::String\n    maiusculos=\"\"\n    minusculos=\"\"\n\n    for i in 1:length(s)\n        if isuppercase(s[i]) \n            maiusculos = maiusculos*s[i]\n        elseif islowercase(s[i])\n            minusculos = minusculos*s[i]\n        end \n    end\n\n    return minusculos*maiusculos\n     \nend\n\nrearranja (generic function with 1 method)\n\n\nPodemos então escrever o teste para nossas funções.\n\nusing Test\n\nfunction testaRearranja()\n  @test rearranja1(\"PaRaLelO\") == \"aaelPRLO\"\n  @test rearranja1(\"ELEfantE\") == \"fantELEE\"\n  @test rearranja1(\"Olá\") == \"lO\"\n  @test rearranja1(\"13La2\") == \"aL\"\n  @test rearranja2(\"PaRaLelO\") == \"aaelPRLO\"\n  @test rearranja2(\"ELEfantE\") == \"fantELEE\"\n  @test rearranja2(\"Olá\") == \"láO\"\n  @test rearranja2(\"13La2\") == \"aL\"\nend\n\ntestaRearranja (generic function with 1 method)",
    "crumbs": [
      "Parte III: Conceitos Avançados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aula de exercícios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html#encontrar-a-maior-palavra",
    "href": "chapters/16-exercicios-3.html#encontrar-a-maior-palavra",
    "title": "16  Aula de exercícios sobre Strings",
    "section": "16.5 Encontrar a maior palavra",
    "text": "16.5 Encontrar a maior palavra\nNossa última função deve receber uma lista de palavras e retornar a maior delas, junto de seu tamanho.\n\nfunction maior_palavra(vetor::Vector{String})\n    # Inicialmente, a maoior palavra que encontramos é uma string vazia\n    maior_palavra = \"\"\n    maior_tamanho = 0\n\n    for palavra in vetor\n        #  Verifica se a palavra atual é maior que a maior encontrada até agora\n        if length(palavra) &gt; maior_tamanho \n            maior_palavra = palavra\n            maior_tamanho = length(palavra)\n        end\n    end\n\n    return maior_palavra, maior_tamanho\n\nend\n\nmaior_palavra (generic function with 1 method)\n\n\nApesar de parecer correto, esse código não lida com o caso de haver mais de uma palavra com o maior tamanho. Como por exemplo:\n\nvetor = [\"boa\", \"bem\", \"oi\"]\nmaior_palavra(vetor)\n\n(\"boa\", 3)\n\n\nNesse caso, apenas a palavra “boa” será retornada, mesmo que “bem” tenha o mesmo tamanho. Para consertar a função devemos alterar a variável em que guardamos a maior palavra, para que possamos armazenar mais de uma palavra, para isso vamos usar um vetor de strings.\n\nfunction maiores_palavras(vetor::Vector{String})\n    maiores_palavras = String[]\n    maior_tamanho = 0\n\n    for palavra in vetor\n        # Se a palavra é maior do que o maior tamanho salvo, \n        # então todas as palavras que estão no vetor maior_palavra são menores do que a palavra atual\n        if length(palavra) &gt; maior_tamanho \n            # Limpa o vetor e salva a palavra atual\n            maiores_palavras = String[]\n            push!(maiores_palavras, palavra)\n            maior_tamanho = length(palavra)\n\n        # Se é igual ao tamanho salvo, então é do mesmo tamanho que as palavras já salvas no vetor maiores_palavras,\n        # apenas damos push na palavra atual\n        elseif length(palavra) == maior_tamanho\n            push!(maiores_palavras, palavra) \n        end\n    end\n\n    return maiores_palavras, maior_tamanho\n\nend\n\nmaiores_palavras (generic function with 1 method)\n\n\nAssim podemos escrever testes para esta última função .\n\nusing Test\n\nfunction testeMaioresPalavras()\n    vetor1 = [\"gato\", \"elefante\", \"cachorro\"]\n    @test maiores_palavras(vetor1) == ([\"elefante\", \"cachorro\"], 8)  \n    \n    vetor2 = [\"a\", \"ab\", \"abc\"]\n    @test maiores_palavras(vetor2) == ([\"abc\"], 3)        \n    \n    vetor3 = [\"bem\", \"boa\", \"bom\", \"oi\"]\n    @test maiores_palavras(vetor3) == ([\"bem\", \"boa\", \"bom\"], 3)       \n\n    vetor4 = [\"\", \" \", \"teste\"]\n    @test maiores_palavras(vetor4) == ([\"teste\"], 5)      \n\n    vetor5 = String[]\n    @test maiores_palavras(vetor5) == ([], 0)              \n\n    vetor6 = [\"a\", \"ab\", \"abc\", \"xyz\", \"xy\"]\n    @test maiores_palavras(vetor6) == ([\"abc\", \"xyz\"], 3)  \nend\n\ntesteMaioresPalavras (generic function with 1 method)",
    "crumbs": [
      "Parte III: Conceitos Avançados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aula de exercícios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html#retorno-de-múltiplos-valores",
    "href": "chapters/16-exercicios-3.html#retorno-de-múltiplos-valores",
    "title": "16  Aula de exercícios sobre Strings",
    "section": "16.6 Retorno de múltiplos valores",
    "text": "16.6 Retorno de múltiplos valores\nComo visto no exercício anterior, Julia permite que uma função retorne múltiplos valores. Isso permite que você envie mais de um resultado ao chamar uma função, tornando o código mais conciso e fácil de entender. Essa funcionalidade é especialmente útil em situações onde você precisa de mais de um resultado, como em operações matemáticas, decomposições, ou processamento de dados.\nPara retornar múltiplos valores em Julia, você pode simplesmente separá-los por vírgulas. Aqui está um exemplo simples:\n\nfunction troca(a,b)\n    aux = a\n    a = b\n    b = aux\n\n    return a, b\nend\n\ntroca (generic function with 1 method)\n\n\nAo chamar essa função, você pode capturar os múltiplos valores retornados em variáveis separadas:\n\na, b = troca(1, 10)\n\n(10, 1)",
    "crumbs": [
      "Parte III: Conceitos Avançados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aula de exercícios sobre Strings</span>"
    ]
  },
  {
    "objectID": "appendices/01-questionario.html",
    "href": "appendices/01-questionario.html",
    "title": "Apêndice A — Respostas para a pergunta “O que é um computador?”",
    "section": "",
    "text": "As respostas foram coletadas através do site https://www.bli.do/MAC115. Eis as respostas:\n\n“É uma máquina que utiliza certos padrões para processar informações. É uma evolução da teórica máquina de Turing e pode ser considerada uma extensão de nossa inteligência.”\n“Computador: configura uma máquina capaz de realizar processos binários de criação e análise, sendo esses modelados pelo próprio dispositivo (IA) ou por um programador. Um produto de passos.”\n“Um computador é uma máquina capaz de identificar códigos baseados em binariedade utilizando linguagem lógica.”\n“É um instrumento tecnológico que junta milhões de dados que diversas pessoas ao redor do mundo distribuem, possibilitando trabalhar de forma técnica criando novos dados e meios de alcançar respostas.”\n“Um dispositivo que vive na tomada.”\n“É um equipamento que”roda” um programa instalado que recebe dados, os processa e tem com saída o resultado, se tudo correr bem…”\n“Decodificador.”\n“Tem por finalidade ser uma ferramenta baseada em algoritmos e lógica de decisão que vez programada e orientada possa possibilitar a resolução de problemas por coleta de dados, informações e então geração de sistemas.”\n“Um computador é um dispositivo eletrônico caracterizado pela sua capacidade de processamento lógico. São construídos com semicondutores e pode apresentar várias peças diferentes, como fonte (ou bateria), placa mãe, processador, placa de vídeo, memórias e etc.”\n“um robô que vai controlar os humanos um dia.”\n“Dispositivo que faz contas.”\nUm computador é um dispositivo que computa, que faz contas, utilizando uma CPU (Central Processing Unit) para fazer cálculos utilizando o sistema binário. 0 e 1, que são utilizados em portas lógicas que são feitas de silício, um semicondutor que permite que cálculos utilizando esses dois dígitos sejam realizados.”\n“Uma máquina.”\n“É um negócio que tem ferramentas que ajudam a realizar diferentes tarefas.”\n“É um celular 2.0.”\n“O computador é uma máquina que obedece comandos.”\n“Uma calculadora.”\n“Máquina de Turing.”\n“Computador é, de uma forma bem simplificada, uma inteligência eletrônica composta de uma carcaça (hardware) que completa a parte do software, feita para responder comandos.”\n“A evolução da calculadora.”",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Respostas para a pergunta \"O que é um computador?\"</span>"
    ]
  }
]