[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Uma Introdu√ß√£o √† Computa√ß√£o com Julia",
    "section": "",
    "text": "P√°gina Inicial\nSeja bem-vindo(a) ao livro ‚ÄúUma Introdu√ß√£o √† Computa√ß√£o com Julia‚Äù. Este livro re√∫ne as notas de aula da disciplina MAC0115 - Introdu√ß√£o √† Computa√ß√£o para Ci√™ncias Exatas e Tecnologia. Com linguagem simples e objetiva, o livro apresenta os principais conceitos de programa√ß√£o, complementados por exemplos pr√°ticos de c√≥digo.\nEsta disciplina visa introduzir os fundamentos da computa√ß√£o atrav√©s de um percurso hist√≥rico at√© conceitos pr√°ticos de programa√ß√£o utilizando a linguagem Julia. Cobre algoritmos, arquitetura de computadores, linguagens algor√≠tmicas (com express√µes, comandos, estruturas de dados e fun√ß√µes), metodologias de desenvolvimento e boas pr√°ticas de programa√ß√£o, al√©m de proporcionar uma extensa pr√°tica de programa√ß√£o e depura√ß√£o, formando uma base t√©cnica completa para iniciantes.\nO livro est√° sendo atualizado juntamente com a disciplina. Podem ocorrer mudan√ßas na ordem e nos exemplos, mas nada que afete o conte√∫do ministrado. N√£o se preocupe se algo n√£o estiver exatamente onde voc√™ esperava encontrar.",
    "crumbs": [
      "P√°gina Inicial"
    ]
  },
  {
    "objectID": "agradecimentos.html",
    "href": "agradecimentos.html",
    "title": "Agradecimentos",
    "section": "",
    "text": "Diversas pessoas contribu√≠ram, direta ou indiretamente, para a realiza√ß√£o deste livro.\nO autor principal √© o Professor Alfredo Goldman. A revis√£o do texto e o suporte t√©cnico ficaram a cargo de Lucas de Sousa Rosa, seu orientando de doutorado. Agradecemos, em especial, a Beatriz Viana Costa, que colaborou na reda√ß√£o de alguns cap√≠tulos. Agradecemos tamb√©m os alunos da disciplina MAC0115 (Introdu√ß√£o √† Computa√ß√£o para Ci√™ncias Exatas e Tecnologia), turma de 2024, por suas contribui√ß√µes na revis√£o do conte√∫do.",
    "crumbs": [
      "Agradecimentos"
    ]
  },
  {
    "objectID": "chapters/01-evolucao-computacao.html",
    "href": "chapters/01-evolucao-computacao.html",
    "title": "1¬† Uma Breve Apresenta√ß√£o da Hist√≥ria dos Computadores e Linguagens de Programa√ß√£o",
    "section": "",
    "text": "1.1 Motiva√ß√£o\nMas, afinal, o que √© um computador? Precisamos mesmo saber a resposta para come√ßar a programar? Na verdade, n√£o. Por√©m, entender como um computador funciona nos torna bons programadores. Definir o que √© um computador pode ser mais complicado do que parece. Veremos que a ideia de ‚Äúcomputador‚Äù mudou muito ao longo da hist√≥ria, sempre ligada √† necessidade de contar. Antes de mergulhar na hist√≥ria, vamos explorar diferentes respostas para essa pergunta.\nLogo no come√ßo das aulas de 2025, na mat√©ria MAC115 - Introdu√ß√£o √† Computa√ß√£o para Ci√™ncias Exatas e Tecnologia, fizemos uma pergunta simples aos alunos: ‚ÄúO que √© um computador?‚Äù. Anotamos as respostas (ver Ap√™ndice A) e apesar de algumas respostas engra√ßadas, como ‚Äúum rob√¥ que vai controlar os humanos um dia‚Äù, notamos que a maioria dos alunos pensava em coisas parecidas:\nEssas ideias mostram um pouco do que um computador faz, mas n√£o explicam tudo o que ele √©.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Uma Breve Apresenta√ß√£o da Hist√≥ria dos Computadores e Linguagens de Programa√ß√£o</span>"
    ]
  },
  {
    "objectID": "chapters/01-evolucao-computacao.html#motiva√ß√£o",
    "href": "chapters/01-evolucao-computacao.html#motiva√ß√£o",
    "title": "1¬† Uma Breve Apresenta√ß√£o da Hist√≥ria dos Computadores e Linguagens de Programa√ß√£o",
    "section": "",
    "text": "Um computador √© um objeto f√≠sico; uma m√°quina ou dispositivo.\nEle √© capaz de processar informa√ß√µes ou dados.\n√â como uma calculadora, s√≥ que mais moderna.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Uma Breve Apresenta√ß√£o da Hist√≥ria dos Computadores e Linguagens de Programa√ß√£o</span>"
    ]
  },
  {
    "objectID": "chapters/01-evolucao-computacao.html#computadores-precisam-existir",
    "href": "chapters/01-evolucao-computacao.html#computadores-precisam-existir",
    "title": "1¬† Uma Breve Apresenta√ß√£o da Hist√≥ria dos Computadores e Linguagens de Programa√ß√£o",
    "section": "1.2 Computadores Precisam Existir?",
    "text": "1.2 Computadores Precisam Existir?\nO Professor Douglas Hartree (1897‚Äì1958), no seu livro ‚ÄúCalculating instruments and machines‚Äù, diz que computadores podem ser vistos de dois √¢ngulos: anat√¥mico (do que s√£o feitos) e fisiol√≥gico (como funcionam). Tentar definir um computador pelas suas partes n√£o seria suficiente, j√° que as pe√ßas dos computadores mudaram muito ao longo dos anos, ent√£o usar a anatomia para defini-los n√£o funcionaria.\nNa mesma √©poca, o Professor Arthur L. Samuel prop√µe uma defini√ß√£o funcional do que √© um computador. Segundo Samuel, um computador √© ‚Äúum dispositivo de processamento de informa√ß√µes ou dados que aceita dados em uma forma e os entrega em uma forma alterada‚Äù. Esta concep√ß√£o t√©cnica concorda com o que os alunos pensam. No entanto, essa defini√ß√£o nos leva a um questionamento mais profundo: ser√° que computadores precisam necessariamente existir como dispositivos ou m√°quinas f√≠sicas, ou podemos conceber computa√ß√£o para al√©m do aspecto material?\nSe pergunt√°ssemos para uma pessoa na rua o que ela acha que √© um computador, √© bem prov√°vel que ela diria que √© uma ‚Äúm√°quina‚Äù ou um ‚Äúdispositivo‚Äù. De fato, nas respostas que coletamos, essa ideia aparece com frequ√™ncia. No entanto, os computadores modernos foram criados a partir de um modelo matem√°tico abstrato, chamado M√°quina de Turing.\nQuando crian√ßa, aos 11 anos, Alan Mathison Turing escreveu uma carta para seus pais, Julius Mathison Turing e Ethel Sara Stoney Turing, contando sua ideia de como fazer uma m√°quina de escrever. Alan Turing n√£o inventou a m√°quina de escrever, mas usou essa ideia para criar a M√°quina de Turing: um modelo matem√°tico de computa√ß√£o que manipula s√≠mbolos numa fita infinita, seguindo regras bem definidas. Esse modelo deu origem aos computadores modernos que, segundo John A. Robinson, nada mais s√£o do que ‚Äúmanifesta√ß√µes f√≠sicas de uma mesma abstra√ß√£o l√≥gica: a m√°quina universal de Turing.‚Äù Ent√£o, n√£o. Computadores n√£o precisam existir.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Uma Breve Apresenta√ß√£o da Hist√≥ria dos Computadores e Linguagens de Programa√ß√£o</span>"
    ]
  },
  {
    "objectID": "chapters/01-evolucao-computacao.html#√°bacos-m√°quinas-de-calcular-e-quase-computadores",
    "href": "chapters/01-evolucao-computacao.html#√°bacos-m√°quinas-de-calcular-e-quase-computadores",
    "title": "1¬† Uma Breve Apresenta√ß√£o da Hist√≥ria dos Computadores e Linguagens de Programa√ß√£o",
    "section": "1.3 √Åbacos, M√°quinas de Calcular e Quase-Computadores",
    "text": "1.3 √Åbacos, M√°quinas de Calcular e Quase-Computadores\n√â aqui que a gente come√ßa a falar da hist√≥ria da computa√ß√£o. N√≥s, humanos, somos muito criativos. Estamos sempre criando ferramentas para nos ajudar. Existem evid√™ncias arqueol√≥gicas que sugerem que os humanos praticam a contagem h√° pelo menos 50.000 anos. A contagem era usada por povos antigos para controlar dados sociais e econ√¥micos, como o n√∫mero de pessoas no grupo, animais, propriedades ou d√≠vidas. Ent√£o, n√£o √© surpresa que os humanos tenham inventado ferramentas para ajudar nesse processo. Em 2700‚Äì2300 AC, os humanos criaram o √°baco: uma ferramenta para fazer contas mais r√°pido.\nAo longo dos s√©culos, outras ferramentas foram criadas para ajudar nisso. Um exemplo √© a r√©gua de c√°lculo, do s√©culo XVII, que fazia a mesma coisa que o √°baco, mas usando propriedades da fun√ß√µes logar√≠tmicas. Os primeiros computadores eram como vers√µes mais modernas dessas ferramentas, ou seja, m√°quinas de calcular. O engenho diferencial (1820) de Charles Babbage, uma m√°quina idealizada, mas n√£o constru√≠da, √© um exemplo de m√°quina de calcular feita para calcular fun√ß√µes polinomiais.\nO ingl√™s Charles Babbage era matem√°tico, fil√≥sofo, inventor e engenheiro mec√¢nico, e √© considerado por muitos como o ‚Äúpai do computador‚Äù. Esse t√≠tulo √© por causa de outra m√°quina que ele idealizou. O engenho anal√≠tico (1840), diferente de todas as m√°quinas da √©poca, marcou a transi√ß√£o da aritm√©tica mecanizada para a computa√ß√£o de prop√≥sito geral. Essa m√°quina seria programada por meio de cart√µes perfurados e incorporaria diversos recursos posteriormente adotados em computadores modernos, como controle sequencial, estruturas de ramifica√ß√£o e mecanismos de repeti√ß√£o (la√ßos).\nDurante a cria√ß√£o do engenho anal√≠tico, a condessa de Lovelace, Augusta Ada Byron King (filha do poeta Lord Byron), criou um algoritmo para calcular a sequ√™ncia dos n√∫meros de Bernoulli, e por isso √© considerada a primeira programadora. Hoje em dia, a figura de Ada √© usada como inspira√ß√£o para aumentar a presen√ßa de mulheres na computa√ß√£o, que era bem maior algumas d√©cadas atr√°s.\nAt√© ent√£o todas as m√°quinas desenvolvidas eram estritamente mec√¢nicas. O Z2 foi um dos primeiros exemplos de um computador digital operado eletricamente, constru√≠do com rel√©s eletromec√¢nicos, e foi criado pelo engenheiro civil Konrad Zuse em 1940 na Alemanha. Mas, foi a partir da inven√ß√£o das v√°lvulas termi√¥nicas (tubos de v√°cuo) que damos o primeiro salto na era dos computadores digitais. As v√°lvulas eram dispositivos totalmente el√©tricos que geravam corrente el√©trica a partir do fen√¥meno de emiss√£o termi√¥nica e foram inventadas pelo f√≠sico John Ambrose Fleming em 1904.\nO Z3, sucessor do Z2, tamb√©m foi desenvolvido por Zuse e √© considerado o primeiro computador digital program√°vel e totalmente autom√°tico do mundo. Konrad Zuse tamb√©m foi respons√°vel pelo design do Plankalk√ºl, a primeira linguagem de programa√ß√£o de alto n√≠vel, ou seja, mais pr√≥xima da linguagem humana e mais distante da linguagem de m√°quina. Embora esta linguagem nunca tenha sido implementada na √©poca, ela introduziu conceitos fundamentais da programa√ß√£o moderna, como tipos de dados e estruturas de controle.\nM√°quinas como o Z3, Colossus e o ENIAC foram constru√≠das manualmente, usando circuitos contendo rel√©s ou v√°lvulas e frequentemente usavam cart√µes perfurados ou fita de papel perfurada para entrada e como principal meio de armazenamento. A maioria das m√°quinas desse per√≠odo n√£o possu√≠a a capacidade de armazenar e modificar programas (com exce√ß√£o do Z3). No ENIAC, um ‚Äúprograma‚Äù era definido pela configura√ß√£o de seus cabos de conex√£o e interruptores, caracter√≠stica que distingue essas m√°quinas dos computadores modernos. A programa√ß√£o nessa √©poca era exercida majoritariamente por mulheres, por√©m essa predomin√¢ncia foi gradualmente diminuindo com o passar dos anos.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Uma Breve Apresenta√ß√£o da Hist√≥ria dos Computadores e Linguagens de Programa√ß√£o</span>"
    ]
  },
  {
    "objectID": "chapters/01-evolucao-computacao.html#o-nascimento-da-computa√ß√£o-moderna",
    "href": "chapters/01-evolucao-computacao.html#o-nascimento-da-computa√ß√£o-moderna",
    "title": "1¬† Uma Breve Apresenta√ß√£o da Hist√≥ria dos Computadores e Linguagens de Programa√ß√£o",
    "section": "1.4 O Nascimento da Computa√ß√£o Moderna",
    "text": "1.4 O Nascimento da Computa√ß√£o Moderna\nAt√© o momento, todas as m√°quinas (Babbage, Zuse, Colossus) seguiam o mesmo design proposto por Babbage: constru√≠am-se m√°quinas para realizar c√°lculos e, ent√£o, organizavam-se instru√ß√µes codificadas em alguma outra forma, armazenadas separadamente, para faz√™-las funcionar. A grande mudan√ßa de paradigma ocorreu em 1945 com as ideias de Alan Turing e John von Neumann. Ambos perceberam que os programas deveriam ser armazenados da mesma forma que os dados. O Manchester Baby foi o primeiro computador eletr√¥nico de programa armazenado do mundo e executou seu primeiro programa em 21 de junho de 1948. A arquitetura de von Neumann marca o in√≠cio da era dos computadores modernos. Desde ent√£o, avan√ßos foram feitos para torn√°-los mais r√°pidos, menores e f√°ceis de usar, por√©m seu cerne permanece o mesmo: a universalidade inerente ao computador de programa armazenado.\nNa mesma d√©cada, Kathleen Booth, trabalhando no mesmo lugar que von Neumann, desenvolveu a primeira linguagem assembly‚Äîuma linguagem de programa√ß√£o muito pr√≥ximo da linguagem de m√°quina. Por√©m, programar em assembly demandava um esfor√ßo intelectual consider√°vel. As linguagens que surgiram posteriormente representaram tentativas de abstrair a linguagem de m√°quina para uma linguagem de alto n√≠vel, mais pr√≥xima da linguagem natural, humana. Embora diversas linguagens tenham sido criadas nos anos seguintes, foi apenas em 1954 que surgiu a primeira linguagem amplamente adotada: FORTRAN, desenvolvida na IBM por uma equipe liderada por John Backus. Atualmente, mais de 70 anos depois, FORTRAN ainda √© utilizada para classificar a lista dos TOP500 supercomputadores mais r√°pidos do mundo.\nA partir de 1955, a tecnologia dos transistores revolucionou a computa√ß√£o ao substituir os tubos de v√°cuo no design de computadores. Os transistores apresentavam vantagens significativas: eram menores e consumiam menos energia, consequentemente gerando menos calor que seus predecessores. O marco dessa transi√ß√£o foi o TRADIC Phase One, conclu√≠do em 1954, considerado o primeiro computador totalmente transistorizado.\nA evolu√ß√£o tecnol√≥gica prosseguiu com a inven√ß√£o dos circuitos integrados em 1958 por Jack Kilby, que posteriormente foi reconhecido com o Pr√™mio Nobel nos anos 2000 por essa contribui√ß√£o. Um circuito integrado consiste em um conjunto de circuitos eletr√¥nicos compostos por diversos componentes (transistores, resistores e capacitores) e suas interconex√µes. Esses componentes s√£o minuciosamente gravados em uma pequena pe√ßa plana, conhecida como ‚Äúchip‚Äù, fabricada com material semicondutor‚Äîinicialmente germ√¢nio e, atualmente, sil√≠cio.\nO per√≠odo compreendido entre o final da d√©cada de 1960 e o final dos anos 1970 foi marcado pelo surgimento de diversas linguagens de programa√ß√£o, bem como pela consolida√ß√£o dos principais paradigmas que conhecemos hoje. Simula, criada pelos cientistas da computa√ß√£o noruegueses Ole-Johan Dahl e Kristen Nygaard, destacou-se como a primeira linguagem projetada especificamente para suportar a programa√ß√£o orientada a objetos. Simultaneamente, Dennis Ritchie e Ken Thompson desenvolviam nos Bell Labs, entre 1969 e 1973, a linguagem C, voltada para programa√ß√£o de sistemas. √â importante ressaltar que o desenvolvimento da linguagem C esteve intrinsecamente ligado ao sistema operacional UNIX, j√° que C foi criada justamente para facilitar a portabilidade deste sistema entre diferentes plataformas de hardware. Nesse mesmo contexto de inova√ß√£o, a linguagem ML, concebida pelo cientista brit√¢nico Robin Milner, emergiu como pioneira entre as linguagens de programa√ß√£o funcional com tipagem est√°tica.\nEm termos de hardware, o microprocessador permitiu o √∫ltimo grande salto na hist√≥ria da computa√ß√£o. Sua evolu√ß√£o s√≥ foi poss√≠vel gra√ßas aos circuitos integrados MOS (CMOS), que permitiram a progressiva miniaturiza√ß√£o dos transistores. Atualmente, j√° somos capazes de produzir transistores com dimens√µes da ordem de 50 nan√¥metros, o que √© surpreendente quando consideramos que o raio de um √°tomo de sil√≠cio √© de aproximadamente 0,13 nan√¥metros.\nPor outro lado, a evolu√ß√£o das linguagens de programa√ß√£o foi particularmente marcante nos anos 1990, impulsionada pelo r√°pido crescimento da Internet. Nesse per√≠odo, a produtividade dos programadores tornou-se algo importante, o que levou ao surgimento de diversas linguagens de desenvolvimento r√°pido de aplicativos (RAD). Essas linguagens eram acompanhadas por ambientes de desenvolvimento integrados (IDEs) e recursos de coleta de lixo. Como resultado dessa tend√™ncia, surgiram linguagens como Python, Lua, R, Ruby, Java, JavaScript e PHP.\nA crescente populariza√ß√£o de novas linguagens de programa√ß√£o foi impulsionada pelos aplicativos mobile. Celulares e dispositivos m√≥veis tornaram-se cada vez mais presentes no cotidiano das pessoas, aumentando significativamente a demanda por aplicativos. Alguns exemplos dessas linguagens incluem Dart, Kotlin, TypeScript e Swift.\nEm 2012, surge a linguagem que ser√° estudada nesta disciplina: Julia. Propondo-se a ser r√°pida e produtiva, Julia une o desempenho de linguagens antigas, com a produtividade de linguagens recentes. Foi desenvolvida por Jeff Bezanson, Stefan Karpinski, Viral B. Shah e Alan Edelman. O site https://julialang.org/benchmarks/ apresenta um benchmark comparativo de diferentes linguagens na resolu√ß√£o de alguns algoritmos. Pode-se observar que Julia demonstra desempenho equivalente ao da linguagem C.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Uma Breve Apresenta√ß√£o da Hist√≥ria dos Computadores e Linguagens de Programa√ß√£o</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html",
    "href": "chapters/02-calculadora-repl.html",
    "title": "2¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "",
    "text": "2.1 Explorando a Sess√£o Interativa de Julia\nO objetivo deste cap√≠tulo √© apresentar o interpretador de Julia como uma calculadora poderosa e introduzir os primeiros conceitos de programa√ß√£o: vari√°veis e fun√ß√µes. Mas primeiro √© preciso instalar a linguagem Julia em seu computador. Mais detalhes sobre o processo de instala√ß√£o podem ser encontrados neste link.\nMuito provavelmente seu sistema √© Windows (10 ou 11) e sua arquitetura √© de 64-bits. H√° algumas formas de instalar Julia no Windows:\nA princ√≠pio qualquer uma das op√ß√µes √© adequada. A primeira op√ß√£o n√£o requer nenhum programa adicional, enquanto que a segunda requer um terminal. Um terminal √© um aplicativo que permite a comunica√ß√£o com o sistema operacional por meio de uma interface de linha de comando (CLI). O terminal padr√£o do Windows √© o Windows Terminal. √â fortemente recomendado que voc√™ o tenha instalado e isso pode ser feito atrav√©s da Microsoft Store.\nUma vez que voc√™ tenha acesso a um terminal h√° dois comandos poss√≠veis para instalar Julia: winget install julia -s msstore ou winget install -e --id Julialang.Julia. Mais uma vez, qualquer uma das op√ß√µes deve funcionar.\nVoc√™ pode abrir uma sess√£o interativa (tamb√©m conhecido como um read-eval-print loop ou REPL) de Julia digitando o comando julia na linha de comando do seu terminal. No Windows, ap√≥s instala√ß√£o da linguagem, √© poss√≠vel abrir uma sess√£o interativa clicando duas vezes no execut√°vel Julia. A sua janela deve ser parecida com\nDentro da sess√£o podemos inserir comandos que ser√£o lidos, avaliados e impressos na tela. Um comando s√≥ √© avaliado quando teclamos Enter. Vamos come√ßar com opera√ß√µes com n√∫meros inteiros. Para somar dois n√∫meros podemos digitar:\n1 + 2\n\n3\nPara multiplicar outros dois n√∫mero:\n40 * 4\n\n160\nComo esperado, podemos utilizar as opera√ß√µes b√°sicas de soma (+), subtra√ß√£o (-) e multiplica√ß√£o (*), e os resultados ocorrem como previsto. No entanto, observaremos a seguir que o comportamento da divis√£o apresenta algumas particularidades:\na = 84 \nb = 2\n\n# As vari√°veis a e b s√£o do tipo Int64\n\nresultado = a / b\nprintln(resultado)\n\n42.0\nNotem que, neste exemplo, ocorreu uma convers√£o de tipo, pois 84 e 2 s√£o n√∫meros inteiros, enquanto o resultado √© um n√∫mero em ponto flutuante (float). Os pontos flutuantes s√£o representa√ß√µes bin√°rias de n√∫meros reais, tema que exploraremos com mais detalhes em breve. Esta convers√£o fica evidente pela representa√ß√£o do resultado como 42.0, em vez de simplesmente 42. Caso deseje obter o resultado como um n√∫mero inteiro, √© poss√≠vel utilizar o operador div:\ndiv(84,2)\n\n42\nOu de forma equivalente usando o operador \\div (para conseguir ver o s√≠mbolo da divis√£o √© necess√°rio digitar \\div seguido da tecla &lt;tab&gt;).\nAl√©m das opera√ß√µes b√°sicas, √© poss√≠vel fazer exponencia√ß√£o:\n2^31\n\n2147483648\nExpress√µes mais complexas tamb√©m podem ser calculadas:\n23 + 2 * 2 + 3 * 4\n\n39\nSim, a preced√™ncia de operadores usual tamb√©m √© v√°lida em Julia. Entretanto, lembre-se da primeira li√ß√£o de programa√ß√£o: Escreva para humanos, n√£o para m√°quinas. Podemos usar par√™nteses para separar as opera√ß√µes:\n23 + (2 * 2) + (3 * 4)\n\n39\nLembra dos pontos flutuantes? Todas as opera√ß√µes vistas podem ser aplicadas em pontos flutuantes:\n23.5 * 3.14\n\n73.79\nOu:\n12.5 / 2.0\n\n6.25\nO exemplo acima demonstra mais um c√≥digo escrito de forma clara para pessoas, onde ao utilizarmos 2.0 deixamos expl√≠cito que o segundo par√¢metro √© um n√∫mero de ponto flutuante (float). √â fundamental compreender que n√∫meros de ponto flutuante possuem precis√£o limitada, portanto n√£o se surpreenda ao encontrar resultados inesperados como os demonstrados abaixo:\n1.2 - 1.0\n\n0.19999999999999996\nErros como esse s√£o bastante raros, tanto que normalmente depositamos total confian√ßa nas contas realizadas por computadores e calculadoras. No entanto, √© importante reconhecer que existem limita√ß√µes (veja os exemplos abaixo).\n2.6 - 0.7 - 1.9\n\n2.220446049250313e-16\n0.1 + 0.2\n\n0.30000000000000004\n10e15 + 1 - 10e15\n\n0.0\nEsses problemas de precis√£o est√£o ligados √† limita√ß√£o de como os n√∫meros s√£o representados no computador. De maneira simplificada, os valores no computador s√£o codificados em palavras, formadas por bits. Nos computadores modernos, as palavras t√™m 64 bits, ou 8 bytes. Logo, uma outra limita√ß√£o est√° relacionada aos n√∫meros inteiros muito grandes.\n2^63\n\n-9223372036854775808\nNo entanto, para um curso introdut√≥rio, √© suficiente estar ciente dessas limita√ß√µes. O tratamento dessas quest√µes faz parte de disciplinas mais avan√ßadas. Vale ressaltar que o erro mencionado anteriormente √© um erro silencioso, ou seja, ao trabalharmos com n√∫meros inteiros, pode acontecer que o valor a ser representado exceda a capacidade do n√∫mero de bits dispon√≠vel, resultando em uma falha que ocorre sem notifica√ß√£o expl√≠cita.\nVoltando √†s contas. Um outro operador interessante √© o % que calcula o resto da divis√£o\n4 % 3\n\n1\nAt√© agora vimos como trabalhar com um √∫nico valor, como se estiv√©ssemos usando o visor de uma calculadora. Mas podemos ir al√©m disso. Em vez de simples teclas de mem√≥ria, o computador nos oferece vari√°veis. Essas s√£o como nomes para valores que queremos armazenar e utilizar posteriormente.\nAl√©m das opera√ß√µes b√°sicas tamb√©m temos as opera√ß√µes matem√°ticas (fun√ß√µes), como por exemplo o seno, sine em ingl√™s. Para saber como uma fun√ß√£o funciona podemos pedir ajuda ao ambiente, usando uma ? ou o macro @doc, e em seguida digitando o que queremos saber, como por exemplo em:\n@doc sin\nA sa√≠da desse comando indica a opera√ß√£o que a fun√ß√£o realiza e ainda apresenta alguns exemplos:\nAmbos os comandos ? sin e @doc sin possuem a mesma sa√≠da.\nNotem que nem tudo que foi apresentado faz sentido no momento, mas j√° d√° para entender o uso de uma fun√ß√£o como sin. Vejamos agora a raiz quadrada:\n@doc sqrt\nNela vemos que √© poss√≠vel calcular a raiz como em:\nsqrt(4)\n\n2.0\nsqrt(4.0)\n\n2.0\nAgora, observe que a documenta√ß√£o da fun√ß√£o big() tem a seguinte ajuda:\nA fun√ß√£o big() permite criar n√∫meros de grande magnitude, representados pelos tipos BigInt ou BigFloat. Essa fun√ß√£o √© particularmente √∫til quando voc√™ precisa trabalhar com n√∫meros muito grandes que ultrapassam os limites dos tipos padr√£o, como Int64 ou Int32. Ao utilizar n√∫meros do tipo BigInt, eliminamos problemas de estouro (overflow), conforme podemos observar abaixo:\nbig(2) ^ 1002\n\n42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#explorando-a-sess√£o-interativa-de-julia",
    "href": "chapters/02-calculadora-repl.html#explorando-a-sess√£o-interativa-de-julia",
    "title": "2¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "",
    "text": "_\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.3 (2025-01-21)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n\njulia&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsin(x)\n\nCompute sine of x, where x is in radians.\n\nSee also sind, sinpi, sincos, cis, asin.\n\nExamples\n‚â°‚â°‚â°‚â°‚â°‚â°‚â°‚â°\n\njulia&gt; round.(sin.(range(0, 2pi, length=9)'), digits=3)\n1√ó9 Matrix{Float64}:\n0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0\n\n\n\nsqrt(x)\n\nReturn \\sqrt{x}.\n\nThrows DomainError for negative Real arguments. Use complex negative arguments instead. Note that sqrt has a branch cut\nalong the negative real axis.\n\nThe prefix operator ‚àö is equivalent to sqrt.\n\nSee also: hypot\n...\n\n\n\n\nbig(T::Type)\n\nCompute the type that represents the numeric type T with arbitrary precision. Equivalent to typeof(big(zero(T))).\n\nExamples\n‚â°‚â°‚â°‚â°‚â°‚â°‚â°‚â°\n\njulia&gt; big(Rational)\nRational{BigInt}\n\njulia&gt; big(Float64)\nBigFloat\n\njulia&gt; big(Complex{Int})\nComplex{BigInt}\n\nbig(x)\n\nConvert a number to a maximum precision representation (typically BigInt or BigFloat). See BigFloat for information about\nsome pitfalls with floating-point numbers.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#vari√°veis-e-tipos-de-dados",
    "href": "chapters/02-calculadora-repl.html#vari√°veis-e-tipos-de-dados",
    "title": "2¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "2.2 Vari√°veis e Tipos de Dados",
    "text": "2.2 Vari√°veis e Tipos de Dados\nComo j√° introduzido, em Julia, temos o conceito de vari√°veis. Vari√°veis servem para armazenar dados diversos, como inteiros e floats. Podemos operar nas vari√°veis da mesma forma que operamos nos dados que elas guardam (veja o exemplo abaixo).\n\na = 7\n2 + a\n\n9\n\n\n√â importante destacar que as vari√°veis em Julia podem receber novos valores, e o tipo da vari√°vel √© determinado pela √∫ltima atribui√ß√£o realizada. A fun√ß√£o typeof pode ser usada para identificar o tipo da vari√°vel especificada.\n\na = 3\ntypeof(a)\n\nInt64\n\n\n\na = a + 1\ntypeof(a)\n\nInt64\n\n\nNo exemplo a seguir, a vari√°vel b come√ßa com um valor de tipo inteiro. No entanto, ap√≥s a opera√ß√£o de multiplica√ß√£o, seu valor passa a ser do tipo ponto flutuante.\n\nb = 3\nb = b * 0.5\ntypeof(b)\n\nFloat64\n\n\nA capacidade de alterar o tipo da vari√°vel √© conhecida como tipagem din√¢mica. Esta caracter√≠stica apresenta diversas vantagens, como a flexibilidade de reutilizar vari√°veis para armazenar diferentes tipos de dados ao longo do tempo e a menor verbosidade, pois n√£o √© necess√°rio especificar o tipo de cada vari√°vel, o que melhora a legibilidade do c√≥digo. Neste contexto, podemos observar que Julia possui v√°rios tipos primitivos, sendo os principais:\n\ntypeof(1)\n\nInt64\n\n\n\ntypeof(1.1)\n\nFloat64\n\n\n\ntypeof(\"Bom dia\")\n\nString\n\n\nFalando em strings, elas s√£o definidas por conjuntos de caracteres entre aspas como:\n\ns1 = \"Olha que legal\"\ns2 = \"Outra String\"\n\n\"Outra String\"\n\n\nTamb√©m √© poss√≠vel realizar opera√ß√µes com strings, como concatena√ß√£o:\n\ns1 = \"Tenha um\"\ns2 = \" Bom dia\"\ns3 = s1 * s2\n\n\"Tenha um Bom dia\"\n\n\nOu repeti√ß√£o usando o operador de pot√™ncia:\n\ns = \"N√£o vou mais fazer coisas que possam desagradar os meus colegas \"\ns ^ 10\n\n\"N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fa\" ‚ãØ 100 bytes ‚ãØ \" meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas N√£o vou mais fazer coisas que possam desagradar os meus colegas \"\n\n\nAinda sobre vari√°veis, h√° algumas regras referentes aos seus nomes: devem come√ßar com uma letra (ou com _), podem conter d√≠gitos e n√£o podem ser palavras reservadas. Vale ressaltar que Julia, por ser uma linguagem moderna, aceita caracteres unicode e emojis nos nomes, como por exemplo o Œî (\\Delta).\n\nŒî = 2\n\n2\n\n\n\nüê± = 5 # \\:cat: &lt;tab&gt;\nüê∂ = 3 # \\:dog: &lt;tab&gt;\nüè† = 20 # \\:house: &lt;tab&gt;\n\n20\n\n\nIsso n√£o adiciona nada do lado de algoritmos, mas √© poss√≠vel ter vari√°veis bem bonitinhas. A lista de figuras pode ser encontrada aqui.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#sa√≠da-de-dados",
    "href": "chapters/02-calculadora-repl.html#sa√≠da-de-dados",
    "title": "2¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "2.3 Sa√≠da de Dados",
    "text": "2.3 Sa√≠da de Dados\nPara fazer sa√≠das usam-se dois comandos, print() e o println(), sendo que o primeiro n√£o pula linha e o segundo pula.\n\nprint(\"Hello \")\nprintln(\"World!\")\nprintln(\"Ola, mundo!\")\n\nHello World!\nOla, mundo!\n\n\nPara evitar que se digitem muitos caracteres, por vezes podemos usar a√ßucares sint√°ticos.\n\nx = 1\nx = x + 1\nx += 1  # forma equivalente a acima, o mesmo vale para os operadores *, - e /\n\n3\n\n\nO c√≥digo acima utiliza coment√°rios (tudo depois do #). Esses coment√°rios s√£o ignorados pelo interpretador e podem ser usados para tornar o c√≥digo mais leg√≠vel.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#arquivos-externos",
    "href": "chapters/02-calculadora-repl.html#arquivos-externos",
    "title": "2¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "2.4 Arquivos Externos",
    "text": "2.4 Arquivos Externos\nPodemos carregar fun√ß√µes de outros arquivos na sess√£o interativa (e em outros arquivos tamb√©m) usando o comando include(\"caminho/do/arquivo.jl\"). Julia l√™ o arquivo especificado e executa todo o seu conte√∫do no contexto atual. Isso significa que todas as fun√ß√µes, vari√°veis e defini√ß√µes no arquivo tornam-se dispon√≠veis no ambiente onde include foi chamado.\nPor exemplo, suponha que temos um arquivo chamado funcoes.jl que possui a fun√ß√£o ola:\n\nfunction ola(nome)\n    println(\"Ol√° \", nome)\nend\n\nola (generic function with 1 method)\n\n\nPodemos incluir essa fun√ß√£o em um segundo arquivo utilizando o include(\"funcoes.jl\") e ent√£o usar a fun√ß√£o definida no arquivo funcoes.jl:\n\ninclude(\"funcoes.jl\")\nprintln(ola(\"Alfredo\"))\n\nA sa√≠da dever√° ser Ol√° Alfredo.\n\n2.4.1 O que √© um arquivo .jl?\nUm arquivo .jl √© semelhante a um arquivo de texto .txt, por√©m com a extens√£o .jl. Embora seja poss√≠vel abri-lo com um editor de texto simples como o Bloco de Notas, n√£o √© recomendado utiliz√°-lo para programa√ß√£o. Os arquivos .jl s√£o arquivos de c√≥digo-fonte da linguagem Julia e s√£o geralmente editados com editores espec√≠ficos para programa√ß√£o, como Visual Studio Code, Atom ou Sublime Text.\nN√£o existe um editor de texto definitivamente superior aos demais, o importante √© escolher aquele com o qual voc√™ se sinta mais confort√°vel. Nossa recomenda√ß√£o √© o Visual Studio Code, que oferece recursos muito mais avan√ßados que um editor de texto comum e possui uma extens√£o dedicada √† linguagem Julia, facilitando significativamente a escrita de c√≥digo. Para come√ßar a usar o Visual Studio Code com Julia, os tutoriais a seguir podem ser √∫teis:\n\nhttps://code.visualstudio.com/docs/getstarted/getting-started\nhttps://code.visualstudio.com/docs/languages/julia",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#verifique-seu-aprendizado",
    "href": "chapters/02-calculadora-repl.html#verifique-seu-aprendizado",
    "title": "2¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "2.5 Verifique seu Aprendizado",
    "text": "2.5 Verifique seu Aprendizado\n\nQual a diferen√ßa entre os resultados obtidos pelos operadores / e div em Julia? Em quais situa√ß√µes cada um seria mais apropriado?\nPor que a express√£o 2.6 - 0.7 - 1.9 n√£o resulta exatamente em zero? O que isso nos ensina sobre c√°lculos computacionais?\nExplique o que significa ‚Äòtipagem din√¢mica‚Äô e como isso afeta o comportamento das vari√°veis quando atribu√≠mos diferentes tipos de valores a elas.\nUse a fun√ß√£o big() para calcular \\(2^{1000}\\). Compare este resultado com o que acontece ao tentar calcular \\(2^{1000}\\) sem usar big().\nArmazene seu nome e sobrenome em vari√°veis separadas e depois combine-as para formar seu nome completo com um espa√ßo entre elas. Demonstre tamb√©m a opera√ß√£o de repeti√ß√£o de strings.\nCrie as vari√°veis a = 10, b = 3 e c = 4.5. Realize os seguintes c√°lculos: a + b + c, a * b * c, a % b e verifique o tipo do resultado de cada opera√ß√£o usando typeof().",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/02-calculadora-repl.html#explore-por-conta-pr√≥pria",
    "href": "chapters/02-calculadora-repl.html#explore-por-conta-pr√≥pria",
    "title": "2¬† Usando o Interpretador (REPL) como Calculadora",
    "section": "2.6 Explore por Conta Pr√≥pria",
    "text": "2.6 Explore por Conta Pr√≥pria\n\nProcure na documenta√ß√£o duas fun√ß√µes matem√°ticas que n√£o foram mencionadas no cap√≠tulo e teste seu uso no REPL.\nO que acontece quando voc√™ tenta dividir um n√∫mero por zero em Julia? E quando calcula 0/0? Teste e observe os resultados.\nExperimente o operador Unicode ‚âà (digite \\approx seguido de TAB). Como ele se comporta ao comparar 0.1 + 0.2 ‚âà 0.3?\nInvestigue a fun√ß√£o round() e utilize-a para corrigir alguns dos problemas de precis√£o demonstrados no cap√≠tulo.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Usando o Interpretador (REPL) como Calculadora</span>"
    ]
  },
  {
    "objectID": "chapters/03-condicionais.html",
    "href": "chapters/03-condicionais.html",
    "title": "3¬† Estruturas de Controle e Tomada de Decis√µes",
    "section": "",
    "text": "3.1 Operadores de Compara√ß√£o e o Tipo Booleano\nO objetivo deste cap√≠tulo √© entender como um programa pode tomar decis√µes e alterar seu fluxo de execu√ß√£o. Vamos explorar os operadores de compara√ß√£o, o tipo booleano, e as estruturas condicionais if, else e elseif em Julia.\nAntes de estudarmos estruturas condicionais, precisamos entender os operadores de compara√ß√£o e o tipo de dado que eles produzem: o tipo booleano (Bool). Uma vari√°vel booleana pode ter apenas dois valores poss√≠veis: true (verdadeiro) ou false (falso). Vamos examinar os principais operadores de compara√ß√£o em Julia:\n# Igualdade: retorna true se os valores forem iguais\n2 + 2 == 4\n\ntrue\n# Diferen√ßa: retorna true se os valores forem diferentes\n3 != 8\n\ntrue\n# Menor que: retorna true se o primeiro valor for menor que o segundo\n23 &lt; 24\n\ntrue\n# Menor ou igual: retorna true se o primeiro valor for menor ou igual ao segundo\n42 &lt;= 44\n\ntrue\n# Maior que: retorna true se o primeiro valor for maior que o segundo\n42 &gt; 2\n\ntrue\n# Maior ou igual: retorna true se o primeiro valor for maior ou igual ao segundo\n42 &gt;= 42\n\ntrue\n√â importante observar que em linguagens de programa√ß√£o, incluindo Julia, o sinal de igual (=) √© usado para atribui√ß√£o de valores a vari√°veis, enquanto o operador de igualdade (==) √© usado para compara√ß√µes.\nPodemos verificar o tipo de uma express√£o de compara√ß√£o:\ntypeof(2 == 3)\n\nBool\nComo esperado, o tipo √© Bool, indicando um valor booleano.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Estruturas de Controle e Tomada de Decis√µes</span>"
    ]
  },
  {
    "objectID": "chapters/03-condicionais.html#operadores-de-compara√ß√£o-e-o-tipo-booleano",
    "href": "chapters/03-condicionais.html#operadores-de-compara√ß√£o-e-o-tipo-booleano",
    "title": "3¬† Estruturas de Controle e Tomada de Decis√µes",
    "section": "",
    "text": "3.1.1 Operadores L√≥gicos\nAl√©m dos operadores de compara√ß√£o, Julia tamb√©m oferece operadores l√≥gicos que permitem combinar ou modificar valores booleanos:\n\n# Operador NOT (nega√ß√£o): inverte o valor booleano\n!true\n\nfalse\n\n\n\n!false\n\ntrue\n\n\n\n# Operador AND: retorna true apenas se ambos os valores forem true\ntrue && true\n\ntrue\n\n\n\ntrue && false\n\nfalse\n\n\n\n# Operador OR: retorna true se pelo menos um dos valores for true\ntrue || false\n\ntrue\n\n\n\nfalse || false\n\nfalse\n\n\nEsses operadores s√£o essenciais para construir condi√ß√µes mais complexas em nossas estruturas condicionais.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Estruturas de Controle e Tomada de Decis√µes</span>"
    ]
  },
  {
    "objectID": "chapters/03-condicionais.html#alterando-o-fluxo-de-execu√ß√£o-com-if-else",
    "href": "chapters/03-condicionais.html#alterando-o-fluxo-de-execu√ß√£o-com-if-else",
    "title": "3¬† Estruturas de Controle e Tomada de Decis√µes",
    "section": "3.2 Alterando o Fluxo de Execu√ß√£o com if-else",
    "text": "3.2 Alterando o Fluxo de Execu√ß√£o com if-else\nAt√© agora, nossos programas seguiam um fluxo de execu√ß√£o linear, com as instru√ß√µes sendo executadas na ordem em que foram escritas. Veja o exemplo:\n\nprintln(\"Oi\")\nprintln(\"um\")\nprintln(\"dois\")\n\nOi\num\ndois\n\n\nA ordem de impress√£o ser√° ‚ÄúOi‚Äù, ‚Äúum‚Äù e ‚Äúdois‚Äù, exatamente na sequ√™ncia em que os comandos foram escritos.\nNo entanto, muitas vezes precisamos que nosso programa tome decis√µes e execute diferentes blocos de c√≥digo dependendo de certas condi√ß√µes. √â aqui que entra a estrutura condicional if.\n\n3.2.1 A Estrutura if\nA estrutura if permite executar um bloco de c√≥digo apenas se uma condi√ß√£o for verdadeira:\n\npandemia = true\nprintln(\"Vou sair de casa?\")\nif pandemia == true\n   println(\"S√≥ vou sair de casa se for essencial\")\nend\n\nVou sair de casa?\nS√≥ vou sair de casa se for essencial\n\n\nNeste exemplo, a mensagem ‚ÄúS√≥ vou sair de casa se for essencial‚Äù s√≥ ser√° impressa se a vari√°vel pandemia for igual a true.\nAqui est√° outro exemplo:\n\ndenominador = 1\nif denominador != 0\n   println(\"Sei fazer a divis√£o se n√£o for por zero\")\n   println(\"O resultado da divis√£o de 30 por \", denominador, \" √© igual a \", 30/denominador)\nend\n\nSei fazer a divis√£o se n√£o for por zero\nO resultado da divis√£o de 30 por 1 √© igual a 30.0\n\n\nO c√≥digo dentro do bloco if s√≥ ser√° executado se o denominador for diferente de zero, evitando assim um erro de divis√£o por zero.\n\n\n3.2.2 Adicionando Alternativas com else\nFrequentemente, queremos executar um bloco de c√≥digo se uma condi√ß√£o for verdadeira e outro bloco se a condi√ß√£o for falsa. Para isso, usamos a estrutura if-else:\n\npandemia = true\nprintln(\"Vou sair de casa?\")\nif pandemia == true\n   println(\"S√≥ vou sair de casa se for essencial\")\nelse\n   println(\"Balada liberada!!\")\nend\n\nVou sair de casa?\nS√≥ vou sair de casa se for essencial\n\n\nSe a vari√°vel pandemia for true, ser√° impressa a mensagem ‚ÄúS√≥ vou sair de casa se for essencial‚Äù. Caso contr√°rio, ser√° impressa a mensagem ‚ÄúBalada liberada!!‚Äù.\n\n\n3.2.3 M√∫ltiplas Condi√ß√µes com elseif\nE se tivermos mais de duas situa√ß√µes poss√≠veis? Nesse caso, podemos usar a estrutura if-elseif-else:\n\npandemia = true\ntenhoqueestudar = true\nprintln(\"Vou sair de casa?\")\nif pandemia == true\n   println(\"S√≥ vou sair de casa se for essencial\")\nelseif tenhoqueestudar == true\n   println(\"Melhor ficar em casa\")\nelse\n   println(\"Balada liberada\")\nend\n\nVou sair de casa?\nS√≥ vou sair de casa se for essencial\n\n\nNeste exemplo, temos tr√™s caminhos poss√≠veis:\n\nSe houver pandemia, sair apenas se for essencial\nSe n√£o houver pandemia mas eu tiver que estudar, ficar em casa\nSe n√£o houver pandemia e eu n√£o tiver que estudar, ir para a balada\n\nA estrutura if-elseif-else avalia as condi√ß√µes na ordem em que aparecem. Assim que uma condi√ß√£o verdadeira √© encontrada, o bloco correspondente √© executado e as demais condi√ß√µes s√£o ignoradas.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Estruturas de Controle e Tomada de Decis√µes</span>"
    ]
  },
  {
    "objectID": "chapters/03-condicionais.html#verifique-seu-aprendizado",
    "href": "chapters/03-condicionais.html#verifique-seu-aprendizado",
    "title": "3¬† Estruturas de Controle e Tomada de Decis√µes",
    "section": "3.3 Verifique seu Aprendizado",
    "text": "3.3 Verifique seu Aprendizado\n\nQual √© a diferen√ßa entre o operador = e o operador == em Julia? Por que essa distin√ß√£o √© importante?\nExplique a diferen√ßa entre if-else e if-elseif-else. Em quais situa√ß√µes voc√™ usaria cada um?\nConsidere a seguinte express√£o booleana: (a &gt; b) && !(c == d). Explique em palavras o que ela significa.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Estruturas de Controle e Tomada de Decis√µes</span>"
    ]
  },
  {
    "objectID": "chapters/03-condicionais.html#explore-por-conta-pr√≥pria",
    "href": "chapters/03-condicionais.html#explore-por-conta-pr√≥pria",
    "title": "3¬† Estruturas de Controle e Tomada de Decis√µes",
    "section": "3.4 Explore por Conta Pr√≥pria",
    "text": "3.4 Explore por Conta Pr√≥pria\n\nPesquise sobre a avalia√ß√£o em curto-circuito dos operadores l√≥gicos && e || em Julia. Como esse comportamento pode ser √∫til em programa√ß√£o?\nEm Julia, al√©m dos valores true e false, quais outros valores s√£o considerados ‚Äúverdadeiros‚Äù ou ‚Äúfalsos‚Äù em um contexto booleano?\nInvestigue o operador tern√°rio (?:) em Julia e como ele pode ser usado como uma alternativa mais concisa para certas estruturas if-else.\nExplore como as estruturas condicionais podem ser combinadas com fun√ß√µes para criar c√≥digo mais modular e reutiliz√°vel.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Estruturas de Controle e Tomada de Decis√µes</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html",
    "href": "chapters/04-funcoes-recursao.html",
    "title": "4¬† Introdu√ß√£o √†s Fun√ß√µes",
    "section": "",
    "text": "4.1 Fun√ß√µes como Abstra√ß√µes Naturais\nO objetivo deste cap√≠tulo √© compreender o conceito de fun√ß√µes em programa√ß√£o e como elas s√£o implementadas em Julia. Vamos explorar como criar nossas pr√≥prias fun√ß√µes, como elas podem receber par√¢metros e retornar valores, al√©m de introduzir o conceito de recurs√£o.\nNa aula anterior, j√° utilizamos algumas fun√ß√µes predefinidas em Julia. Fun√ß√µes s√£o blocos de c√≥digo que realizam tarefas espec√≠ficas e podem ser reutilizados sempre que necess√°rio. Elas nos permitem abstrair opera√ß√µes complexas em comandos simples, tornando o c√≥digo mais leg√≠vel e modular.\nVamos relembrar algumas das fun√ß√µes que j√° utilizamos:\nAssim como na aula anterior, podemos pedir ajuda ao Julia para entender melhor como essas fun√ß√µes funcionam. Para isso, usamos o ponto de interroga√ß√£o ? ou o macro @doc antes do nome da fun√ß√£o:\n# Exemplos de como acessar a documenta√ß√£o\n@doc typeof\n@doc div\n@doc println\nAo consultar a documenta√ß√£o, descobrimos que algumas fun√ß√µes como div() podem ser utilizadas com uma sintaxe alternativa, como por exemplo \\div. Esse tipo de nota√ß√£o √© particularmente √∫til para opera√ß√µes matem√°ticas.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Introdu√ß√£o √†s Fun√ß√µes</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#fun√ß√µes-como-abstra√ß√µes-naturais",
    "href": "chapters/04-funcoes-recursao.html#fun√ß√µes-como-abstra√ß√µes-naturais",
    "title": "4¬† Introdu√ß√£o √†s Fun√ß√µes",
    "section": "",
    "text": "typeof() - Recebe um valor como par√¢metro e retorna o seu tipo.\ndiv() - Recebe dois n√∫meros e retorna a divis√£o inteira do primeiro pelo segundo.\nprint() e println() - Imprimem valores no console, sendo que o segundo adiciona uma quebra de linha ap√≥s a impress√£o.\n\n\n\n\n\n\n\n4.1.1 Fun√ß√µes de Convers√£o em Julia\nUma categoria importante de fun√ß√µes em Julia s√£o as fun√ß√µes de convers√£o, que transformam valores de um tipo em outro. Vejamos alguns exemplos:\n\n# Converte uma string para um n√∫mero em ponto flutuante\nparse(Float64, \"32\")\n\n32.0\n\n\n\n# Converte um n√∫mero em ponto flutuante para um inteiro (removendo a parte decimal)\ntrunc(Int64, 2.25)\n\n2\n\n\n\n# Converte um inteiro para um n√∫mero em ponto flutuante\nfloat(2)\n\n2.0\n\n\n\n# Converte um n√∫mero para uma string\nstring(3)\n\n\"3\"\n\n\n\n# Converte um n√∫mero em ponto flutuante para uma string\nstring(3.57)\n\n\"3.57\"\n\n\n\n\n4.1.2 Fun√ß√µes Matem√°ticas Prontas em Julia\nJulia possui uma grande biblioteca de fun√ß√µes matem√°ticas prontas para uso. Aqui est√£o algumas das mais comuns:\n\n\n\n\n\n\n\nFun√ß√£o\nDescri√ß√£o\n\n\n\n\nsin(x)\nCalcula o seno de ( x ) em radianos\n\n\ncos(x)\nCalcula o cosseno de ( x ) em radianos\n\n\ntan(x)\nCalcula a tangente de ( x ) em radianos\n\n\ndeg2rad(x)\nConverte ( x ) de graus em radianos\n\n\nrad2deg(x)\nConverte ( x ) de radianos em graus\n\n\nlog(x)\nCalcula o logaritmo natural de ( x )\n\n\nlog(b, x)\nCalcula o logaritmo de ( x ) na base ( b )\n\n\nlog2(x)\nCalcula o logaritmo de ( x ) na base 2\n\n\nlog10(x)\nCalcula o logaritmo de ( x ) na base 10\n\n\nexp(x)\nCalcula o expoente da base natural de ( x )\n\n\nabs(x)\nCalcula o valor absoluto de ( x )\n\n\nsqrt(x)\nCalcula a raiz quadrada de ( x )\n\n\ncbrt(x)\nCalcula a raiz c√∫bica de ( x )\n\n\nfactorial(x)\nCalcula o fatorial de ( x )\n\n\n\nUma boa pr√°tica para se familiarizar com essas fun√ß√µes √© experiment√°-las com diferentes valores e verificar os resultados. Para fun√ß√µes mais complexas, √© poss√≠vel que j√° existam implementa√ß√µes prontas em Julia. Uma dica √∫til √© pesquisar na internet usando palavras-chave como ‚Äújulia lang hiperbolic sin‚Äù para encontrar a fun√ß√£o desejada. Em geral, pesquisar em ingl√™s tende a produzir melhores resultados.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Introdu√ß√£o √†s Fun√ß√µes</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#criando-nossas-pr√≥prias-fun√ß√µes",
    "href": "chapters/04-funcoes-recursao.html#criando-nossas-pr√≥prias-fun√ß√µes",
    "title": "4¬† Introdu√ß√£o √†s Fun√ß√µes",
    "section": "4.2 Criando Nossas Pr√≥prias Fun√ß√µes",
    "text": "4.2 Criando Nossas Pr√≥prias Fun√ß√µes\nEm Julia, podemos criar nossas pr√≥prias fun√ß√µes usando a palavra-chave function, seguida pelo nome da fun√ß√£o, par√™nteses (que podem conter par√¢metros) e terminando com end. Vejamos um exemplo simples:\n\nfunction mensagemDeBomDia()\n   println(\"Tenha um bom dia!\")\nend\n\nmensagemDeBomDia (generic function with 1 method)\n\n\nPara usar (ou ‚Äúchamar‚Äù) uma fun√ß√£o, basta escrever seu nome seguido de par√™nteses:\n\nmensagemDeBomDia()\n\nTenha um bom dia!\n\n\n\n4.2.1 Fun√ß√µes com Par√¢metros\nAs fun√ß√µes se tornam muito mais √∫teis quando podem receber informa√ß√µes para processar. Essas informa√ß√µes s√£o chamadas de ‚Äúpar√¢metros‚Äù ou ‚Äúargumentos‚Äù:\n\nfunction imprime(a)\n   println(\"Vou imprimir \", a)\nend\n\nimprime (generic function with 1 method)\n\n\nVamos chamar esta fun√ß√£o com diferentes valores:\n\nimprime(42)\n\nVou imprimir 42\n\n\n\nimprime(\"Ol√°, mundo!\")\n\nVou imprimir Ol√°, mundo!\n\n\n\n\n4.2.2 Fun√ß√µes Chamando Outras Fun√ß√µes\nUma fun√ß√£o pode chamar outra fun√ß√£o, permitindo a composi√ß√£o de opera√ß√µes mais complexas:\n\nfunction imprimeduasvezes(a)\n   imprime(a)\n   imprime(a)\nend\n\nimprimeduasvezes (generic function with 1 method)\n\n\nTestando nossa nova fun√ß√£o:\n\nimprimeduasvezes(13)\n\nVou imprimir 13\nVou imprimir 13\n\n\n\n\n4.2.3 Sobrecarga de Fun√ß√µes\nEm Julia, podemos ter fun√ß√µes com o mesmo nome, mas com diferentes n√∫meros ou tipos de par√¢metros. Isso √© chamado de ‚Äúsobrecarga de fun√ß√µes‚Äù:\n\nfunction recebe(a)\n  println(\"Recebi um par√¢metro: \", a)\nend\n\nfunction recebe(a, b)\n  println(\"Recebi dois par√¢metros: \", a, \" e \", b)\nend\n\nrecebe (generic function with 2 methods)\n\n\nO Julia decide qual vers√£o da fun√ß√£o chamar com base nos argumentos fornecidos:\n\nrecebe(1)\n\nRecebi um par√¢metro: 1\n\n\n\nrecebe(1, 2)\n\nRecebi dois par√¢metros: 1 e 2\n\n\nTamb√©m podemos chamar fun√ß√µes usando vari√°veis e express√µes como argumentos:\n\na = 10\nrecebe(a)\nrecebe(a, a + 1)\n\nRecebi um par√¢metro: 10\nRecebi dois par√¢metros: 10 e 11",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Introdu√ß√£o √†s Fun√ß√µes</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#fun√ß√µes-que-retornam-valores",
    "href": "chapters/04-funcoes-recursao.html#fun√ß√µes-que-retornam-valores",
    "title": "4¬† Introdu√ß√£o √†s Fun√ß√µes",
    "section": "4.3 Fun√ß√µes que Retornam Valores",
    "text": "4.3 Fun√ß√µes que Retornam Valores\nAt√© agora, vimos fun√ß√µes que apenas imprimem mensagens, mas n√£o devolvem nenhum valor. O tipo de retorno dessas fun√ß√µes √© Nothing, indicando que elas n√£o produzem um valor que possa ser atribu√≠do a uma vari√°vel.\nNo entanto, frequentemente queremos que nossas fun√ß√µes calculem e retornem valores. Para isso, usamos a palavra-chave return:\n\nfunction soma1(a)\n  return a + 1\nend\n\nsoma1 (generic function with 1 method)\n\n\nAgora podemos usar essa fun√ß√£o em express√µes e atribui√ß√µes:\n\nresultado = soma1(5)\nprintln(\"O resultado √©: \", resultado)\n\nO resultado √©: 6\n\n\n\n# Tamb√©m podemos usar o resultado em outras express√µes\nprintln(\"Resultado multiplicado por 2: \", soma1(5) * 2)\n\nResultado multiplicado por 2: 12\n\n\nPodemos criar fun√ß√µes para c√°lculos mais complexos:\n\nfunction hipotenusa(a, b)\n  hip = sqrt(a^2 + b^2)\n  return hip\nend\n\nhipotenusa (generic function with 1 method)\n\n\nTestando nossa fun√ß√£o:\n\n# Calculando a hipotenusa de um tri√¢ngulo 3-4-5\nhipotenusa(3, 4)\n\n5.0",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Introdu√ß√£o √†s Fun√ß√µes</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#introdu√ß√£o-√†-recurs√£o",
    "href": "chapters/04-funcoes-recursao.html#introdu√ß√£o-√†-recurs√£o",
    "title": "4¬† Introdu√ß√£o √†s Fun√ß√µes",
    "section": "4.4 Introdu√ß√£o √† Recurs√£o",
    "text": "4.4 Introdu√ß√£o √† Recurs√£o\nAgora vamos explorar um conceito fundamental em programa√ß√£o: a recurs√£o. Uma fun√ß√£o recursiva √© aquela que chama a si mesma como parte de sua execu√ß√£o. Isso pode parecer estranho √† primeira vista, mas √© uma t√©cnica poderosa para resolver certos tipos de problemas.\nVamos come√ßar com um exemplo simples: calcular o fatorial de um n√∫mero. O fatorial de \\(n\\) (representado por \\(n!\\)) √© o produto de todos os inteiros positivos menores ou iguais a \\(n\\). Por exemplo, \\(5! = 5 \\times 4 \\times 3 \\times 2 \\times 1 = 120\\).\nO fatorial pode ser definido recursivamente como:\n\nCaso base: \\(0! = 1\\)\nCaso recursivo: \\(n! = n \\times (n-1)!\\)\n\nVamos implementar isso em Julia:\n\nfunction fatorial(n)\n  if n == 0\n    return 1  # Caso base\n  else\n    return n * fatorial(n - 1)  # Chamada recursiva\n  end\nend\n\nfatorial (generic function with 1 method)\n\n\nTestando nossa fun√ß√£o:\n\nfatorial(5)\n\n120\n\n\nPara entender como a recurs√£o funciona, vamos acompanhar passo a passo o c√°lculo de fatorial(3):\n\nChamamos fatorial(3)\n\nComo \\(3\\) n√£o √© igual a \\(0\\), executamos return 3 * fatorial(2)\n\nAgora precisamos calcular fatorial(2)\n\nComo \\(2\\) n√£o √© igual a \\(0\\), executamos return 2 * fatorial(1)\n\nAgora precisamos calcular fatorial(1)\n\nComo \\(1\\) n√£o √© igual a \\(0\\), executamos return 1 * fatorial(0)\n\nAgora precisamos calcular fatorial(0)\n\nComo \\(0\\) √© igual a \\(0\\), retornamos \\(1\\)\n\nAgora podemos completar o c√°lculo de fatorial(1) = \\(1 \\times 1 = 1\\)\nAgora podemos completar o c√°lculo de fatorial(2) = \\(2 \\times 1 = 2\\)\nFinalmente, completamos o c√°lculo de fatorial(3) = \\(3 \\times 2 = 6\\)\n\nA recurs√£o tem duas partes fundamentais:\n\nUm caso base que encerra a recurs√£o (no nosso exemplo, quando \\(n = 0\\))\nUm caso recursivo que aproxima o problema do caso base (no nosso exemplo, reduzindo \\(n\\) em \\(1\\))\n\n√â necess√°rio que a recurs√£o sempre alcance o caso base, caso contr√°rio, a fun√ß√£o continuar√° chamando a si mesma indefinidamente, causando um erro de estouro de pilha (stack overflow).\n\n4.4.1 Mais Exemplos de Recurs√£o\nVamos implementar uma fun√ß√£o recursiva para contagem regressiva:\n\nfunction contagem(n)\n    if n &lt; 0\n        println(\"Fim!\")\n    else\n        print(n, \" \")\n        contagem(n - 1)\n    end\nend\n\ncontagem (generic function with 1 method)\n\n\nTestando nossa fun√ß√£o:\n\ncontagem(5)\n\n5 4 3 2 1 0 Fim!\n\n\nPodemos tamb√©m usar recurs√£o para calcular a soma dos primeiros \\(n\\) n√∫meros inteiros:\n\nfunction soma(n)\n  if n == 0\n    return 0  # Caso base\n  else\n    return n + soma(n - 1)  # Caso recursivo\n  end\nend\n\nsoma (generic function with 1 method)\n\n\nTestando nossa fun√ß√£o:\n\nsoma(10)\n\n55\n\n\nOutro exemplo interessante √© o c√°lculo da soma dos termos da s√©rie harm√¥nica:\n\nfunction somaharmonica(atual, n)\n  # Caso base: quando chegamos ao √∫ltimo termo\n  if atual &gt; n\n    return 0.0\n  else\n    # Caso recursivo: somamos o termo atual e chamamos a fun√ß√£o para o pr√≥ximo termo\n    return 1.0 / atual + somaharmonica(atual + 1, n)\n  end\nend\n\nsomaharmonica (generic function with 1 method)\n\n\nVamos calcular a soma dos 10 primeiros termos da s√©rie harm√¥nica:\n\nsomaharmonica(1, 10)\n\n2.9289682539682538",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Introdu√ß√£o √†s Fun√ß√µes</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#verifique-seu-aprendizado",
    "href": "chapters/04-funcoes-recursao.html#verifique-seu-aprendizado",
    "title": "4¬† Introdu√ß√£o √†s Fun√ß√µes",
    "section": "4.5 Verifique seu Aprendizado",
    "text": "4.5 Verifique seu Aprendizado\n\nQual √© a diferen√ßa entre uma fun√ß√£o que imprime um valor e uma fun√ß√£o que retorna um valor? Por que esta distin√ß√£o √© importante?\nExplique o conceito de recurs√£o em suas pr√≥prias palavras. Quais s√£o os componentes essenciais de uma fun√ß√£o recursiva?\nCrie uma fun√ß√£o que receba um n√∫mero inteiro positivo e retorne a soma de seus d√≠gitos. Por exemplo, para o n√∫mero \\(123\\), a fun√ß√£o deve retornar \\(1+2+3 = 6\\).\nImplemente uma fun√ß√£o que calcule o \\(n\\)-√©simo n√∫mero da sequ√™ncia de Fibonacci usando recurs√£o. Lembre-se que\n\n\\(Fib(0) = 0\\)\n\\(Fib(1) = 1\\)\n\\(Fib(n) = Fib(n-1) + Fib(n-2)\\), se \\(n &gt; 1\\).\n\nCrie uma fun√ß√£o que receba dois n√∫meros como par√¢metros e retorne o m√°ximo divisor comum (MDC) entre eles usando o algoritmo de Euclides recursivamente.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Introdu√ß√£o √†s Fun√ß√µes</span>"
    ]
  },
  {
    "objectID": "chapters/04-funcoes-recursao.html#explore-por-conta-pr√≥pria",
    "href": "chapters/04-funcoes-recursao.html#explore-por-conta-pr√≥pria",
    "title": "4¬† Introdu√ß√£o √†s Fun√ß√µes",
    "section": "4.6 Explore por Conta Pr√≥pria",
    "text": "4.6 Explore por Conta Pr√≥pria\n\nPesquise sobre o conceito de ‚Äúpilha de chamadas‚Äù (call stack) e como ele se relaciona com a recurs√£o. Quais s√£o as limita√ß√µes pr√°ticas da recurs√£o devido √† pilha de chamadas?\nPense em como seria poss√≠vel otimizar a fun√ß√£o recursiva de Fibonacci para evitar c√°lculos repetidos.\n\nDica: pesquise sobre ‚Äúmemoiza√ß√£o‚Äù.\n\nExplore fun√ß√µes com um n√∫mero vari√°vel de argumentos em Julia usando a sintaxe de ‚Äúsplats‚Äù (...).\nProcure como voc√™ pode definir valores padr√£o para par√¢metros de fun√ß√µes em Julia.",
    "crumbs": [
      "Parte I: Conceitos B√°sicos",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Introdu√ß√£o √†s Fun√ß√µes</span>"
    ]
  },
  {
    "objectID": "chapters/05-algoritmos-testes.html",
    "href": "chapters/05-algoritmos-testes.html",
    "title": "5¬† Mais algoritmos e introdu√ß√£o aos testes",
    "section": "",
    "text": "Nessa aula, vamos ver algoritmos um pouco mais elaborados. Mas, sabendo que vamos usar algo com um maior grau de sofistica√ß√£o, que tal pensar em testes?\nDe uma forma geral, para verificar o funcionamento de um programa, podemos escrever testes que verificam o funcionamento em algumas situa√ß√µes espec√≠ficas.\nDado que o primeiro problema que queremos resolver √© um algoritmo que encontra o n-√©simo n√∫mero de Fibonacci. Por que n√£o come√ßar com testes?\nUma forma de se fazr testes, e de forma manual, mas isso n√£o √© reprodut√≠vel. A melhor maneira de se fazer testes, √© de forma automatizada, ou seja criar c√≥digo que teste c√≥digo. Isso pode parecer complicado, mas vamos ver abaixo que n√£o √©.\nEm uma busca r√°pida, podemos ver que a sequ√™ncia de Fibonacci √© definida da seguinte forma, os dois primeiros elementos \\(F_1\\) e \\(F_2\\) valem 1, em seguida temos a f√≥rmula \\(F_n = F_{n-1} +  F_{n-2}\\). Mas, antes de pensar em resolver o problema vamos pensar em como testar.\nJ√° sabemos os primeiros valores, al√©m disso, atrav√©s de uma busca r√°pida, podemos descobrir alguns valores da sequ√™ncia como \\(F_5 =  5\\) e \\(F_{12}  =\n144\\). Supondo que a fun√ß√£o para o c√°lculo do n-√©simo n√∫mero de Fibonacci chamar√° fibo(). Podemos escrever o seguinte trecho de c√≥digo:\n\nfunction testafibo_versao1()\n    if fibo(1) == 1\n        println(\"Deu certo para 1\")\n    end\n    if fibo(2) == 1\n        println(\"Deu certo para 2\")\n    end\n    if fibo(5) == 5\n        println(\"Deu certo para 5\")\n    end\n    if fibo(12) == 144\n        println(\"Deu certo para 12\")\n    end\n    println(\"Final dos testes\")\nend\n\ntestafibo_versao1 (generic function with 1 method)\n\n\nA fun√ß√£o de testes acima verifica se a fun√ß√£o fibo() devolve o resultado correto para tr√™s casos. Mas, ela tem um defeito, ela imprime mensagens demais, o que pode ser ruim. Considerando isso, vamos ver o primeiro fundamento importante com rela√ß√£o a testes automatizados.\nSe o teste passou, ele deve indicar apenas que deu certo!\nLevando em conta o que foi escrito acima, podemos mudar o nosso teste para:\n\nfunction testafibo()\n    if fibo(1) != 1\n        println(\"N√£o deu certo para 1\")\n    end\n    if fibo(2) != 1\n        println(\"N√£o deu certo para 2\")\n    end\n    if fibo(5) != 5\n        println(\"N√£o eu certo para 5\")\n    end\n    if fibo(12) != 144\n        println(\"N√£o deu certo para 12\")\n    end\n    println(\"Final dos testes\")\nend\n\ntestafibo (generic function with 1 method)\n\n\nAgora de posse da nossa fun√ß√£o de testes, podemos pensar em escrever a nossa fun√ß√£o de Fibonacci. Vamos ao caso f√°cil de n for menor que 2, a resposta √© 1. Como vemos abaixo:\n\nfunction fibo(n)\n    if n &lt;= 2\n        return 1\n    else\n        # ainda n√£o sabemos o que colocar aqui...\n    end\nend\n\nfibo (generic function with 1 method)\n\n\nMas, a resposta est√° na pr√≥pria defini√ß√£o da fun√ß√£o, ou seja: \\(F_n = F_{n-1} +  F_{n-2}\\). Se o \\(n\\) for maior do que 2, temos que fazer a soma dos valores de Fibonacci de \\(n-1\\) e de \\(n-2\\). Ou seja:\n\nfunction fibo(n)\n    if n &lt;= 2\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nend\n\nfibo(10)\n\n55\n\n\n√â interessante notar que apesar de ser um dos exemplos cl√°ssicos de uso de recurs√£o, o algoritmo acima √© extremamente ineficiente. A raz√£o √© simples, cada vez que √© feita a chamada, toda os valores de Fibonacci s√£o recalculados para os valores de \\(n\\) e \\(n-1\\).\nComo Julia √© uma linguagem moderna podemos usar o conceito de Memoiza√ß√£o, que evita calcular o que j√° foi calculado. O Memoize tem que ser instalado no Julia com os comandos import Pkg e Pkg.add(\"Memoize\").\n\nusing Memoize\n@memoize function fibo(n)\n    if n &lt;= 2\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nend\n\nfibo(10)\n\n55\n\n\nAs diferen√ßas de tempo das duas vers√µes podem ser verificada com o comando @time. Da seguinte forma:\n\n@time fibo(10)\n\n  0.000001 seconds\n\n\n55\n\n\nEsse tipo de comando, que come√ßa com @ √© conhecido como anota√ß√£o, e tem o poder de mudar o comportamente de partes do c√≥digo.\nVamos ao segundo algoritmo da aula, o MDC (M√°ximo Divisor Comum). A ideia √© usar o algoritmo de Euclides.\nBasicamente ele diz que o MDC de dois n√∫meros a e b, √© igual ao MDC de b e r, onde \\(r=a\\% b\\). Quando esse resto for zero, chegamos a solu√ß√£o, que √© b.\nVamos come√ßar com os testes para alguns valores bem conhecidos. Por sinal come√ßar pelos testes antes de escrever o c√≥digo √© uma boa pr√°tica de programa√ß√£o conhecida por TDD (Test Driven Design).\n\nfunction testaMDC()\n    if MDC(3298, 2031) != 1\n        println(\"deu erro, para 3298 e 2031\")\n    end\n    if MDC(120, 36) != 12\n        println(\"deu erro, para 120 e 36\")\n    end\n    if MDC(36, 120) != 12\n        println(\"deu erro, para 36 e 120\")\n    end\n    println(\"Acabaram os testes\")\nend\n\ntestaMDC (generic function with 1 method)\n\n\nVamos pensar na fun√ß√£o agora. Dessa vez, se o resto for 0, temos que devolver o segundo termo. Caso contr√°rio temos que continuar com a regra\n\nfunction MDC(a, b)\n    r = a % b\n    if r == 0\n        return b\n    else\n        return MDC(b, r)\n    end\nend\n\ntestaMDC()\n\nAcabaram os testes\n\n\nAt√© agora usamos o modo interativo do Julia para fazer os nosso c√≥digos. Mas, existe oura forma bem mais reutiliz√°vel, ou seja escrever o texto em arqivos. Isso √© relativamente simples, basta usar um editor de texto (puro) da sua prefer√™ncia, como o notepad, nano, juno, atom, vscode ou outro e salvar um arquivo com a extens√£o .jl.\nMas, para que algo seja executado √© importante colocar uma chamada ao final. Veja abaixo um poss√≠vel arquivo mdc.jl.\n\nfunction testeMDC()\n    if mdc(70, 5) != 5\n        println(\"N√£o funcionou para 70 e 5\")\n    end\n    if mdc(13, 7) != 1\n        println(\"N√£o funcionou para 13 e 7\")\n    end\n    if mdc(127, 15) != 1\n        println(\"N√£o funcionou para 127 e 15\")\n    end\n    if mdc(20, 15) != 5\n        println(\"N√£o funcionou para 20 e 15\")\n    end\n    if mdc(42, 3) != 3\n        println(\"N√£o funcionou para 42 e 3\")\n    end\n    if mdc(42, 8) != 2\n        println(\"N√£o funcionou para 42 e 8\")\n    end\n    println(\"Final dos testes\")\nend\n\nfunction mdc(a, b)\n    r = a % b\n    if r == 0\n        return b\n    else\n        mdc(b, r)\n    end\nend\n\ntesteMDC()\nprintln(\"O mdc entre 1227 e 321 √© \", mdc(1227, 321))\n\nFinal dos testes\nO mdc entre 1227 e 321 √© 3",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Mais algoritmos e introdu√ß√£o aos testes</span>"
    ]
  },
  {
    "objectID": "chapters/06-testes-automatizados.html",
    "href": "chapters/06-testes-automatizados.html",
    "title": "6¬† Testes automatizados e um pouco mais de c√≥digo",
    "section": "",
    "text": "6.1 Fun√ß√µes ca√≥ticas\nVamos come√ßar o cap√≠tulo vendo uma forma mais simples de se rodar testes. Nos testes que vimos at√© agora sempre havia o teste de uma condi√ß√£o booleana associado a uma mensagem de erro quando n√£o funcionasse. Mas, observando que a mensagem de erro geralmente est√° ligada √† condi√ß√£o, por vezes a condi√ß√£o pode ser auto-explicativa.\nLogo, uma forma elegante de expressar as condi√ß√µes pode ser √∫til na escrita dos testes. Para isso, vamos usar o m√≥dulo de testes. Em linguagens modernas, v√°rias das situa√ß√µes repetitivas que enfrentamos podem ser evitadas usando alguma t√©cnica mais moderna.\nNo trecho acima primeiro indicamos que queremos fazer testes. Em seguida usamos o test que espera uma condi√ß√£o ou valor booleano. Finalmente todos os testes s√£o reunidos em um testset.\nClaro que o teste d√° infoma√ß√µes relevantes quando falha:\nAgora sim, vamos pensar em problemas algoritmicos novos. Que tal fazer a soma dos d√≠gitos de um n√∫mero inteiro. Ou seja, pensar em um n√∫mero d√≠gito √† d√≠gito. Vamos aos testes primeiro:\nVamos agora tentar pensar em como ‚Äúdescascar‚Äù um n√∫mero, dado o n√∫mero 123, uma forma seria pegar o resto por 10 (ou seja 3) e depois dividir por 10 (ou seja 12), e assim por diante. Ou seja.\nVamos agora a um outro problema cl√°ssico, a verifica√ß√£o se um n√∫mero √© ou n√£o √© primo. Na pr√°tica para fazer isso, temos a defini√ß√£o, um n√∫mero \\(n\\) √© primo apenas se for divis√≠vel apenas por 1 e por ele mesmo. Ou seja, nenhum n√∫mero entre 2 e \\(n - 1\\) pode ser divisor de um n√∫mero primo.\nA forma de se fazer isso √© relativamente simples. Vamos pensar em uma fun√ß√£o que tenta dividir um n√∫mero recursivamente, se conseguir devolve falso, se n√£o conseguir devolve verdadeiro.\nVamos aos c√≥digo:\nQue pode ser chamada por:\nMais um exemplo, o m√©todo de Newton para o c√°lculo de raiz quadrada. Para achar a raiz de \\(x\\), a partir de um chute inicial (por exemplos \\(y= x /2\\)), chegamos a um novo chute que √© a m√©dia de \\(y\\) e \\(x/y\\).\nMas, sim, vamos come√ßar com os testes. Como estamos usando n√∫meros do tipo double √© bom sempre ter uma toler√¢ncia, por isso vamos usar uma compara√ß√£o aproximada. Tamb√©m poderiamos ter usado a fun√ß√£o isapprox da linguagem Julia.\nNote que como estamos comparando n√∫meros em ponto flutuante, n√£o usamos a compara√ß√£o exata.\nA solu√ß√£o final √©:\nVamos brincar um pouco agora com fun√ß√µes ca√≥ticas :), isso √©, fun√ß√µes, que conforme o comportamento de uma constante \\(k\\), apresentam resultados que podem convergir ou n√£o. Isso √©, a cada passo, quero saber o valor do pr√≥ximo ponto aplicando a fun√ß√£o novamente, isso √©: \\[x_1 = f(x_0), x_2 = f(x_1), \\ldots, x_n  = f(x_{n - 1})\\]\nAs fun√ß√µes ca√≥ticas desempenham um papel significativo em diversas √°reas da matem√°tica e da f√≠sica, com aplica√ß√µes que v√£o desde a modelagem de crescimento populacional at√© a previs√£o de padr√µes clim√°ticos. Elas tamb√©m s√£o fundamentais na an√°lise de circuitos el√©tricos n√£o lineares, onde pequenas varia√ß√µes nas condi√ß√µes iniciais podem levar a resultados drasticamente diferentes.\nPara o nosso teste, a fun√ß√£o \\(f\\) √© extremamente simples: \\(x_{i + 1}=x_i * (1 -  x_i) * k\\).\nImplemente a fun√ß√£o e imprima os 30 primeiros resultados. Comece com um valor de \\(x\\) entre 0 e 1, como 0.2. Use constantes \\(k = 2.1, 2.5, 2.8\\) e \\(3.1\\) o que ocorre com \\(k = 3.7\\)?\nEntregue o c√≥digo e um pequeno relat√≥rio sobre o que acontece.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Testes automatizados e um pouco mais de c√≥digo</span>"
    ]
  },
  {
    "objectID": "chapters/07-while.html",
    "href": "chapters/07-while.html",
    "title": "7¬† Uma outra forma de se fazer la√ßos",
    "section": "",
    "text": "At√© o momento vimos que o computador √© muito bom para fazer contas e repeti√ß√µes. Fizemos isso at√© agora com fun√ß√µes recursivas. Mas, existe um outro comando para isso, o while. A motiva√ß√£o √© que enquanto alguma condi√ß√£o for v√°lida, o computador continua repetindo os comandos.\nO formato b√°sico √© o seguinte:\nwhile condi√ß√£o\n  # execute obloco\nend  \nEnquanto a condi√ß√£o continuar verdadeira, o computador vai seguir repetindo o bloco que pode ser formado por v√°rias intru√ß√µes. Logo, para que a repeti√ß√£o, ou la√ßo, n√£o seja repetido indefinidamente, √© essencial que algo ligado a condi√ß√£o seja atualizado no corpo do while.\nVejamos o exemplo simples da contagem regressiva:\n\nn = 5\nwhile n &gt; 0\n  println(n)\n  n = n - 1\nend\nprintln(\"Acabou\")\n\n5\n4\n3\n2\n1\nAcabou\n\n\nMas, vamos ver abaixo um caso onde o uso de while deixa o c√≥digo mais Claro que com a recurs√£o (onde √© ruim fazer uma com v√°rios par√£metros). Veja a resolu√ß√£o da s√©rie de Taylor abaixo:\n\n function sinTaylor2(x)\n   i = 1\n   termo = x\n   soma = 0.0\n   while i &lt;= 15\n     soma = soma + termo\n     termo = -1 * termo * x * x / ((2 * i) * (2 * i + 1))\n     i = i + 1\n   end\n   return soma\nend\n\nsinTaylor2 (generic function with 1 method)\n\n\nNela s√£o calculados os 15 primeiros termos.\nObservem a vers√£o recursiva:\n\nfunction sinTaylor(x)\n    return sinTaylorRec(1, 15, x, 1, x)\nend\n\nfunction sinTaylorRec(i, n, x, sinal, termo)\n    if n == i\n      return 0.0\n    else\n      return sinal * termo +\n         sinTaylorRec(i + 1, n, x, -1 * sinal, termo * x * x/ (2*i * (2*i+1)))\n    end\nend\n\nsinTaylorRec (generic function with 1 method)\n\n\nPodemos tamb√©m fazer opera√ß√µes com os d√≠gitos de um n√∫mero inteiro, para isso opera√ß√µes como o resto da divis√£o por 10 e a divis√£o inteira por 10 s√£o bastante √∫teis. Abaixo temos as duas vers√µes que fazem a soma dos d√≠gitos de um n√∫mero inteiro.\n\nusing Test\nfunction testaSD()\n  @test sd(123) == 6\n  @test sd(321) == 6\n  @test sd(0) == 0\n  @test sd(1001) == 2\n  @test sd(3279) == 21\n  println(\"Fim dos testes\")\nend\n\nfunction sd(x)\n  if x == 0\n     return 0\n  else\n     d = x % 10\n     return d + sd(div(x, 10))\n  end\nend\n\nfunction sd1(x)\n  soma = 0\n  while x != 0\n   d = x % 10\n   soma = soma + d\n   x = div(x, 10)\n  end\n  return soma\nend\ntestaSD()\n\nFim dos testes",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Uma outra forma de se fazer la√ßos</span>"
    ]
  },
  {
    "objectID": "chapters/08-exercicios.html",
    "href": "chapters/08-exercicios.html",
    "title": "8¬† Aula de exerc√≠cios",
    "section": "",
    "text": "8.1 Revisitando o c√°lculo do fatorial, recursivo e interativo\nAgora que aprendemos a fazer tamb√©m repeti√ß√µes com o comando while, sempre √© bom pensar em qual o comando mais adequado. Vejamos o exemplo abaixo com duas vers√µes da fun√ß√£o para o c√°lculo do Fatorial.\nfunction fatorial_recursivo(n::Int64) # Com o ::Int64 estamos definindo que o par√¢metro da fun√ß√£o deve ser um n√∫mero inteiro\n    # Caso base do fatorial: 0! e 1! s√£o iguais a 1\n    if n == 0 || n == 1\n        return 1\n    # Chamada recursiva: n! = n * (n-1)!\n    else\n        return n * fatorial_recursivo(n - 1)\n    end\nend\n\nfunction fatorial_iterativo(n::Int64)\n    # Inicializa o resultado como 1 (j√° que o fatorial de 0 √© 1)\n    resultado = 1\n\n    # No loop estamos fazendo a multiplica√ß√£o: n * (n-1) * ... * 2\n    while n &gt; 1\n        # Multiplica o resultado pelo valor atual de n\n        resultado *= n\n\n        # Decrementa n em 1 para continuar o c√°lculo do fatorial\n        n -= 1\n    end\n    return resultado\nend\n\nprintln(fatorial_recursivo(3))\n\n6\nNo c√≥digo acima temos uma novidade, nos par√¢metros da fun√ß√£o, o tipo est√° sendo declarado expicitamente. No caso, estamos dizendo que o valor n que a fun√ß√£o vai receber √© de um tipo espec√≠fico. Ou seja um Inteiro de 64 bits.\nO estilo de c√≥digo est√° um pouco diferente do que antes, pois foi escrito por outra pessoa. A monitora. Vemos que ela tem o h√°bito de usar nomes de vari√°veis maiores al√©m do que usar contra√ß√µes como += e *=.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Aula de exerc√≠cios</span>"
    ]
  },
  {
    "objectID": "chapters/08-exercicios.html#aproxima√ß√£o-da-raiz-quadrada",
    "href": "chapters/08-exercicios.html#aproxima√ß√£o-da-raiz-quadrada",
    "title": "8¬† Aula de exerc√≠cios",
    "section": "8.2 Aproxima√ß√£o da raiz quadrada",
    "text": "8.2 Aproxima√ß√£o da raiz quadrada\nPara o pr√≥ximo exemplo, vamos ver o m√©todo de Newthon-Raphson para o c√°lculo da raiz quadrada. √â um m√©todo recursivo no qual o pr√≥ximo valor √© baseado no valor anterior. Quanto mais chamadas forem feitas, mais pr√≥ximo do valor final vai se chegar.\nMais informa√ß√µes sobre o m√©todo podem ser encontradas em aqui. Mas para o momento temos que pensar na seguinte implementa√ß√£o. Para se calcular a raiz, podemos usar a seguinte f√≥rmula, a partir de um palpite inicial r, para o valor da raiz de x.\n\\[ r_{n+1} = 0.5 * (r + x / r)\\]\nComo o c√≥digo abaixo √© mais complicado, foram usados coment√°rios.\n\nfunction aproxima_raiz(x::Float64, epsilon::Float64)::Float64\n    if x &lt; 0\n        return nothing\n    end\n\n    # Chute inicial \n    aproximacao = x/2\n    melhor_aproximicao = aproximacao\n\n    while true\n        # F√≥rmula para aproxima√ß√£o de raiz quadrada utilizando o m√©todo de Newthon-Raphson\n        melhor_aproximicao = 0.5 * (aproximacao + x/aproximacao)\n\n        # Se a dist√¢ncia absoluta entre os dois pontos √© menor do que epsilon, ent√£o podemos parar o m√©todo\n        if abs(aproximacao - melhor_aproximicao) &lt;= epsilon\n            break\n        end\n\n        # Se a aproxima√ß√£o ainda n√£o for boa o sufuciente, ent√£o atualizamos a aproxima√ß√£o para a pr√≥xima itera√ß√£o\n        aproximacao = melhor_aproximicao\n    end\n\n    return melhor_aproximicao\n\nend\n\naproxima_raiz (generic function with 1 method)\n\n\nNotem que foi introduzido um comando novo, o break, esse comando apenas interrompe a execu√ß√£o do while. Ou seja, for√ßa a sa√≠da do la√ßo.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Aula de exerc√≠cios</span>"
    ]
  },
  {
    "objectID": "chapters/08-exercicios.html#verificar-se-um-n√∫mero-√©-primo",
    "href": "chapters/08-exercicios.html#verificar-se-um-n√∫mero-√©-primo",
    "title": "8¬† Aula de exerc√≠cios",
    "section": "8.3 Verificar se um n√∫mero √© primo",
    "text": "8.3 Verificar se um n√∫mero √© primo\nNo pr√≥ximo exemplo, vamos verificar se um n√∫mero √© primo, ou seja, se os seus √∫nicos divisores s√£o 1 e o pr√≥prio. A forma mais simples de se fazer isso √© procurando dividir o n√∫mero por outros. Se algum dividir, o n√∫mero n√£o √© primo.\n\nfunction verifica_primo(num :: Int64)\n    if num &lt;= 1\n        return false\n    end\n    i=2\n    # pode ser melhorado com i&lt;=num/2\n    # ou tamb√©m com i&lt;= sqrt(num): baseado no fato que um n√∫mero composto deve ter um fator menor ou igual a raiz desse n√∫mero\n    while i&lt;num\n        if num % i == 0\n            return false\n        end\n        i+=1\n    end\n    return true\nend\n\nverifica_primo (generic function with 1 method)\n\n\nAssim, como o comando break √© usado para interromper a execu√ß√£o de um la√ßo, o comando return, pode ser usado para terminar a execu√ß√£o de uma fun√ß√£o, a qualquer momento.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Aula de exerc√≠cios</span>"
    ]
  },
  {
    "objectID": "chapters/08-exercicios.html#verificar-se-um-n√∫mero-√©-pal√≠ndromo",
    "href": "chapters/08-exercicios.html#verificar-se-um-n√∫mero-√©-pal√≠ndromo",
    "title": "8¬† Aula de exerc√≠cios",
    "section": "8.4 Verificar se um n√∫mero √© pal√≠ndromo",
    "text": "8.4 Verificar se um n√∫mero √© pal√≠ndromo\nUm n√∫mero pal√≠ndromo √© um n√∫mero que √© sim√©trico. Ou seja, a leitura dos d√≠gitos da esquerda para a direita √© igual a leitura dos d√≠gitos na ordem inversa. Por exemplo, o n√∫mero 121 √© pal√≠ndromo, assim como o 11 e o 25677652. Os n√∫meros de um d√≠gito tamb√©m s√£o.\n\nfunction e_palindromo(n::Int64)\n    #=\n        Guarda os d√≠gitos de n que ainda devem ser invertidos\n        A vari√°vel auxiliar √© necess√°ria para que o valor de n n√£o seja, perdido, e possamos usar ele posteriormente.\n    =#\n    aux = n\n    # Guarda a invers√£o do n√∫mero n \n    n_inv = 0\n\n    #=\n        Continuamos o while enquanto ainda h√° n√∫meros a serem invertidos,\n        ou seja, enquanto aux for maior que 0.\n    =#\n    while aux &gt; 0 \n        # Coloca o √∫ltimo d√≠gito de aux na vari√°vel que guarda a invers√£o\n        resto = aux % 10\n        n_inv= n_inv * 10 + resto\n\n        # Retira o √∫ltimo d√≠gito de aux\n        aux = div(aux,10)\n    end\n\n    if n == n_inv\n        println(\"O n√∫mero $n √© pal√≠ndromo\")\n    else\n        println(\"O n√∫mero $n n√£o √© pal√≠ndromo\")\n    end \nend\n\ne_palindromo(2002)\ne_palindromo(1234)\n\nO n√∫mero 2002 √© pal√≠ndromo\nO n√∫mero 1234 n√£o √© pal√≠ndromo",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Aula de exerc√≠cios</span>"
    ]
  },
  {
    "objectID": "chapters/09-exercicios-cont.html",
    "href": "chapters/09-exercicios-cont.html",
    "title": "9¬† Revisitando a aula passada",
    "section": "",
    "text": "9.1 Aleatoreidade\nAl√©m de discutirmos o que vimos na aula passada. Nessa aula, vimos uma nova solu√ß√£o para o problema de verificar de um n√∫mero √© pal√≠ndromo.\nPara isso usamos uma t√©cnica um pouco diferente, ou seja, ao inv√©s de inverter o n√∫mero e compar√°-lo com o original. Verificamos se os seus extremos s√£o iguais.\nObserve o n√∫mero 234432, o primeiro passo seria verificar que nos extremos, mais significativo e menos significativo, temos os n√∫meros 2. Em seguida, podemos continuar com a verifica√ß√£o para o n√∫mero 3443. Se em algum momento a verifica√ß√£o falhar o n√∫mero n√£o √© pal√≠ndromo.\nSeguem os testes e o c√≥digo abaixo.\nEm julia temos a fun√ß√£o rand() que devolve um n√∫mero em ponto flutuante entre 0 e 1. Conforme os par√¢metros, podemos ter outros tipos de n√∫mero como:\nrand(Int)  # devolve um inteiro\nrand(1:10) # devolve um n√∫mero entre 1 e 10\nrand(Bool) # devolve verdadeiro ou falso\n\ntrue\nMas, antes de ver um c√≥digo com rand(). Vamos pensar em um problema da vida real. Imagine que temos que fazer um sorteio justo, e o √∫nico instrumento que possu√≠mos para o sorteio √© uma moeda viciada. Que tem como resultado muito mais faces do que coroas. D√° para usar essa moeda em um sorteio justo?\nA ideia para resolver o problema √© olhar para pares de sorteios. Ou seja, vamos ignorar sorteios onde tenhamos duas faces ou duas coroas. Nos outros, teremos uma coroa e uma face ou vice versa. As chances das duas ser√£o de 50%. Logo podemos assim, corrigir a moeda viciada.\nPara simplificar o exerc√≠cio, a moeda pode devolver 0, ou 1, correspondentes a cara ou a coroa. Observe a seguinte fun√ß√£o que simula uma moeda viciada.\nfunction sorteio()\n  if rand() &gt; 0.90\n    return 1\n  else \n    return 0\n  end\nend\n\nsorteio (generic function with 1 method)\nPode se observar que a fun√ß√£o devolve 0 na maior parte das vezes. Podemos inclusive ver isso, fazendo mil sorteios:\nfunction verificaSorteio()\n   cara = 0\n   coroa = 0\n   i = 0\n   while i &lt; 1000\n     if sorteio() == 0\n        cara = cara + 1\n     else\n        coroa = coroa + 1\n     end\n     i = i + 1\n   end\n   println(\"O n√∫mero de caras foi: \", cara,\" e de coroas foi :\", coroa)\nend\n\nverificaSorteio (generic function with 1 method)\nMas, podemos corrigir o sorteio da seguinte forma:\nfunction sorteioBom()\n   sorteio1 = sorteio()\n   sorteio2 = sorteio()\n   while sorteio1 == sorteio2 # se forem iguais, tente novamente\n     sorteio1 = sorteio()\n     sorteio2 = sorteio()\n   end\n   return sorteio1   # ao termos um diferente, podemos devolver o primeiro sorteio\nend\n\nsorteioBom (generic function with 1 method)\nPodemos usar o verificaSorteio para ver a diferen√ßa.\nfunction verificaSorteio()\n   cara = 0\n   coroa = 0\n   i = 0\n   while i &lt; 1000\n     if sorteioBom() == 0\n        cara = cara + 1\n     else\n        coroa = coroa + 1\n     end\n     i = i + 1\n   end\n   println(\"O n√∫mero de caras foi: \", cara,\" e de coroas foi :\", coroa)\nend\n\nverificaSorteio (generic function with 1 method)\nPodemos ainda aproximar o n√∫mero de Euler (ùëí), constante matem√°tica que √© a base dos logaritmos naturais, usando uma simula√ß√£o probabil√≠stica. A ideia por tr√°s desse c√≥digo √© que o n√∫mero m√©dio de tentativas necess√°rias para que a soma de n√∫meros aleat√≥rios entre 0 e 1 ultrapasse 1 se aproxima do valor de ùëí. Isso √© baseado em uma rela√ß√£o matem√°tica que conecta essa situa√ß√£o ao n√∫mero ùëí.\nfunction calculaEuler(total)\n    soma_tentativas = 0\n    for i in 1:total\n        soma = 0.0\n        tentativas = 0      \n        while soma &lt;= 1   # Continue gerando n√∫meros at√© a soma ultrapassar 1\n            soma += rand()     # Gera n√∫mero aleat√≥rio entre 0 e 1\n            tentativas += 1\n        end        \n        soma_tentativas += tentativas     # Somar o n√∫mero de tentativas necess√°rias\n    end \n    return soma_tentativas / total     # A m√©dia do n√∫mero de tentativas ser√° uma estimativa de e\nend\n\nprintln(\"Estimativa de e (1000 itera√ß√µes): \", calculaEuler(1000))\nprintln(\"Estimativa de e (100000 itera√ß√µes): \", calculaEuler(100000))\nprintln(\"Estimativa de e (100000000 itera√ß√µes): \", calculaEuler(100000000))\n\nEstimativa de e (1000 itera√ß√µes): 2.657\nEstimativa de e (100000 itera√ß√µes): 2.72055\nEstimativa de e (100000000 itera√ß√µes): 2.71821212\nPara terminar a aula vamos aplicar o m√©todo de Monte Carlo para o c√°lculo de Pi. Imaginem o primeiro quadrante, onde temos um semi-c√≠rculo de raio 1, dentro de um quadrado de lado 1. Podemos sortear valores, os que sairem dentro do c√≠rculo podem contar para a √°rea desse. Mais informa√ß√µes podem ser vistas aqui (https://pt.wikipedia.org/wiki/M%C3%A9todo_de_Monte_Carlo)\nfunction calculaPi(total)\n   noAlvo = 0\n   i = 0\n   while i &lt; total\n     x = rand() / 2.0 # gera um n√∫mero entre 0 e 0.5\n     y = rand() / 2.0\n     if sqrt(x * x + y * y) &lt;= 0.5\n       noAlvo = noAlvo + 1\n     end\n     i = i + 1\n   end\n   return 4 * (noAlvo / total)  # precisamos multiplicar para ter a √°rea de 4 quadrantes\nend \n\nprintln(calculaPi(100))\nprintln(calculaPi(1000000))\nprintln(calculaPi(1000000000))\n\n2.96\n3.141104\n3.141609584",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Revisitando a aula passada</span>"
    ]
  },
  {
    "objectID": "chapters/10-entrada-dados.html",
    "href": "chapters/10-entrada-dados.html",
    "title": "10¬† Entrada de dados e o come√ßo de listas",
    "section": "",
    "text": "10.1 O comando input\nNessa aula, temos dois t√≥picos principais, como fazer a entrada de dados, atrav√©s de comandos de entrada e com argumentos na linha de comando. Al√©m disso tamb√©m veremos como tratar de um tipo especial de vari√°vel, onde √© poss√≠vel, guardar mais de um valor.\nQuando queremos inserir dados, em Julia, basta colocar dados. Mas, como podemos fazer para entrar dados em um programa comum?\nPara isso temos o comando readline(), que interrompe a execu√ß√£o do programa e espera pela entrada de uma String, o que ocorre quando a tecla ‚Äúenter‚Äù √© pressionada.\nprintln(\"Digite o seu nome\")\nresposta = readline()\nprintln(\"O seu nome √©: \", resposta)\nCaso, ao rodar o programa, voc√™ digitar Maria, e pressionar a tecla enter, a resposta final do seu programa ser√° O seu nome √©: Maria.\nComo o readline() l√™ Strings, se quisermos ler n√∫meros, √© necess√°rio usar o comando parse. O comando parse de forma simples possui dois par√¢metros, o primeiro corresponde ao tipo que se quer transformar, e o segundo o valor original.\nprintln(\"Digite um inteiro\")\nvalor = parse(Int64, readline())\nprintln(\"O numero digitado foi \", valor)\nSabendo ler n√∫meros do teclado, vamos a um exerc√≠cio simples, ler uma sequ√™ncia de n√∫meros inteiros terminada por zero e devolver a sua soma.\nfunction somaVarios()\n    soma = 0.0\n    println(\"Digite um n√∫mero\")\n    n = parse(Float64, readline())\n    while  n!=0\n        soma = soma + n\n        println(\"Digite um n√∫mero\")\n        n = parse(Float64, readline())\n    end\n    println(\"A soma √©: \", soma)\nend\nObserve o seguinte exemplo que calcula os quadrados dos n√∫meros de uma lista terminada por zero.\nfunction leQ()\n  x = readline()\n  n = parse(Float64, x)\n  while n != 0\n    println(\"$n ao quadrado √© \", n * n)\n    x = readline()\n    n = parse(Float64, x)\n  end\nend\nNotem que o readline tamb√©m pode receber uma vari√°vel de arquivo para que dados sejam lidos diretamente. Mas, nesse caso temos que tomar Ocuidado para abrir (open()) e fechar (close()) o arquivo. Como abaixo:\nfunction leQ()\n    println(\"Digite um n√∫mero\")\n    f = open(\"numeros.txt\", \"r+\")\n    x = readline(f)\n    n = parse(Float64, x)\n    while n != 0\n        println(\"$n ao quadrado √© \", n * n)\n        println(\"Digite outro n√∫mero\")\n        x = readline(f)\n        n = parse(Float64, x)\n    end\n    close(f)\nend",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Entrada de dados e o come√ßo de listas</span>"
    ]
  },
  {
    "objectID": "chapters/10-entrada-dados.html#lendo-atrav√©s-da-linha-de-comando",
    "href": "chapters/10-entrada-dados.html#lendo-atrav√©s-da-linha-de-comando",
    "title": "10¬† Entrada de dados e o come√ßo de listas",
    "section": "10.2 Lendo atrav√©s da linha de comando",
    "text": "10.2 Lendo atrav√©s da linha de comando\nA outra forma de ler comandos √© atrav√©s da constante ARGS que √© preparada na chamada de um programa. Para entender melhor isso, vamos ver o seguinte programa.\n\nprintln(ARGS)\n\nSe a linha acima est√° no arquivo args.jl, ao chamar julia args.jl com diversos par√¢metros, teremos diversos resultados diferentes.\nPor exemplo ao chamar:\njulia args.jl 1 2 3 abc\nTeremos como resposta\n\n[\"1\", \"2\", \"3\", \"abc\"]\n\nVamos analisar um pouco melhor essa resposta observando que cada par√¢metro est√° em uma posi√ß√£o.\n\ntam = length(ARGS)\nprintln(\"O tamanho dos argumentos √©: \", tam)\nfor i in 1:tam\n    println(ARGS[i])\nend\n\nOlhando o c√≥digo acima, podemos ver que a fun√ß√£o length() devolve o n√∫mero de argumentos, ou seja, o tamanho da lista ARGS. Al√©m disso com os colchetes √© poss√≠vel acessar a cada posi√ß√£o da lista de forma individual.\nO exemplo abaixo soma os par√¢metros inteiros dados como argumentos. Ele tamb√©m ilustra uma boa pr√°tica que √©, sempre colocar o c√≥digo em m√≥dulos, no caso abaixo em fun√ß√µes:\n\nfunction SomaEntrada()\n    tam = length(ARGS)\n    s = 0\n    i = 1\n    while i &lt;= tam\n        valor = parse(Int, ARGS[i])\n        println(valor)\n        s = s + valor\n        i = i + 1\n    end\n    println(\"A soma foi: \", s)\nend\nSomaEntrada()\n\nA flexibilidade que temos ao usar listas √© enorme! Por isso, listas ou vetores, merecem um t√≥pico pr√≥prio.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Entrada de dados e o come√ßo de listas</span>"
    ]
  },
  {
    "objectID": "chapters/10-entrada-dados.html#listas",
    "href": "chapters/10-entrada-dados.html#listas",
    "title": "10¬† Entrada de dados e o come√ßo de listas",
    "section": "10.3 Listas",
    "text": "10.3 Listas\nVamos primeiro brincar um pouco no console.\n\nvetor = [1, 2, 3]\nprintln(vetor[1])\nprintln(length(vetor))\nvetor[2] = vetor[2] + 1\nvetor[1] = 2 * vetor[3]\nprintln(vetor)\n\n1\n3\n[6, 3, 3]\n\n\nComo disse antes, o for foi feito para manipular vetores, vamos ver umas fun√ß√µes, a primeira que imprime os elementos de um vetor um por linha.\n\nfunction imprimeVetor(v)\n    for el in v\n        println(el)\n    end\nend\n\nIsso tamb√©m pode ser feito por meio dos √≠ndices do vetor:\n\nfunction imprimeVetor(v)\n    for i in 1:lenght(v)\n        println(v[i])\n    end\nend\n\nComo cada posi√ß√£o √© independente, podemos calcular a soma dos elementos √≠mpares de um vetor\n\nfunction somaImpVetor(v)\n    soma = 0\n    for i in 1:length(v)\n        if v[i] % 2 == 1\n            soma = soma + v[i]\n        end\n    end\n    return soma\nend\n\nTamb√©m vimos em aula alguns outros exemplos, como calcular a m√©dia dos elementos em um vetor.\n\nfunction mediaV(v)\n   soma = 0.0\n   for i in v\n      soma = soma + i\n   end\n   return soma / length(v)\nend\n\nDevolver a soma dos elementos √≠mpares de um vetor\n\nfunction somaImpar(v)\n    soma = 0\n    for i in v\n        if i % 2 == 1\n            soma = soma + i\n        end\n    end\n    return soma\nend\n\nImprimir os n√∫meros divis√≠veis por 5 de um vetor.\n\nfunction imprimeDivisivelPor5(v)\n    for i in v\n        if i % 5 == 0\n            println(i)\n        end\n    end\nend\n\nCom uma pequena varia√ß√£o e usando o comando push!() podemos ver como devolver um vetor com os n√∫meros divis√≠veis por 5.\n\nfunction devolveDivisivelPor5(v)\n    x = []  # come√ßa com um vetor vazio\n    for i in v\n        if i % 5 == 0\n            push!(x, i)  # adiciona um elemento ao vetor x\n        end\n    end\n    return x\nend\n\n\n10.3.1 √Ålgebra linear e Listas\nA manipula√ß√£o de listas √© uma parte fundamental da √°lgebra linear, que estuda vetores e matrizes. Fun√ß√µes como o produto escalar de dois vetores s√£o exemplos cl√°ssicos. Abaixo temos dois exemplos de produto escalar de dois vetores. lembrado esse √© definido como a soma dos produtos de elementos em posi√ß√µes iguais.\n\nfunction dotProduct(a, b)\n    soma = 0\n    if length(a) != length(b)\n       return soma   # o produto n√£o est√° definido se os tamanhos s√£o diferentes\n    end\n    for i in 1:length(a)\n        soma = soma + a[i] * b[i]\n    end\n    return soma\nend\n\nAcima vimos que um caso especial do uso do for, consiste em fazer Ofor varias entre 1 e um tamanho (1:lenght(a))\nObservem a diferen√ßa na vers√£o abaixo:\n\nfunction dotProduct(a, b)\n    soma = 0\n    if length(a) != length(b)\n       return soma   # o produto n√£o est√° definido se os tamanhos s√£o diferentes\n    end   \n    i = 1\n    for x in a\n        soma = soma + x * b[i]\n        i = i + 1\n    end \n    return soma\nend\n\n\n\n10.3.2 Exerc√≠cio de permuta√ß√£o\nPara terminar, vamos fazer uma fun√ß√£o onde dado um vetor de inteiros de tamanho \\(n\\), verifica se esse vetor √© uma permuta√ß√£o dos n√∫meros de 1 a \\(n\\). Para isso, veremos se cada n√∫mero de 1 a \\(n\\) est√° no vetor.\nMas, sem esquecer dos testes:\n\n@testset \"Verifica Permuta√ß√£o\" begin\n    @test permuta([1,2,3])\n    @test permuta([3, 2, 1])\n    @test permuta([1])\n    @test permuta([2, 1])\n    @test permuta([4, 2, 3, 1])\n    @test !permuta([1, 1])\n    @test !permuta([1, 3])\n    @test permuta([])\nend\n\ne o c√≥digo:\n\nfunction permuta(v)\n   tam = length(v)\n   for i in 1:tam\n      if  !(i in v)\n         return false\n      end\n   end\n   return true\nend\n\nFoi usado o comando in de Julia que verifica se um elemento est√° no vetor.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Entrada de dados e o come√ßo de listas</span>"
    ]
  },
  {
    "objectID": "chapters/11-exercicios-2.html",
    "href": "chapters/11-exercicios-2.html",
    "title": "11¬† Exerc√≠cios com vetores",
    "section": "",
    "text": "11.1 Permuta√ß√£o\nOs vetores permitem que sejam realizados algoritmos bem mais complexos, nesse cap√≠tulo veremos algums exerc√≠cios.\nDado um vetor com inteiros, queremos verificar se esse vetor cont√©m uma permuta√ß√£o. Para isso, temos que verificar em um vetor de tamanho n, se ele cont√©m os n√∫meros de 1 a n exatamente uma vez cada 1. O vetor [3, 1, 2] √© uma permuta√ß√£o, pois tem tamanho 3 e os elementos de 1 a 3 aparecem uma vez.\nUma forma de se resolver esse problema √© por meio de um indicador de passagem. Inicialmente vamos supor que o vetor √© uma permuta√ß√£o, em seguida verificamos se todos os n√∫meros entre 1 e n est√£o no vetor. Isso pode ser feito com comando in, que verifica se um elemento pertence ao vetor.\nfunction permuta√ß√£o(l)\n    perm = true\n    tamanho = length(l)\n    i = 1\n    while i &lt;= tamanho\n        if !(i in l)\n            perm = false\n        end    \n        i += 1\n    end\n    return perm\nend\n\npermuta√ß√£o (generic function with 1 method)\nUma outra alternativa √© verificar se para cada elemento do vetor, se ele est√° entre 1 e n, e √© unico. Ou seja, verificamos se o primeiro elemento est√° entre 1 e n, e depois percorremos o vetor para ver se ele √© √∫nico. Em seguida fazemos isso para os elementos seguintes. O c√≥digo fica:\nfunction permuta√ß√£o(l)\n    perm = true\n    tamanho = length(l)\n    i = 1\n    while i &lt;= tamanho\n        if (l[i] &gt; tamanho || l[i] &lt;= 0)\n            perm = false\n        end\n        j = i +1\n        while j &lt;= tamanho\n            if l[j] == l[i]\n                perm = false\n            end\n            j += 1\n        end\n        i += 1\n    end\n    return perm\nend\n\npermuta√ß√£o (generic function with 1 method)\nUma outra alternativa √© ter um vetor auxiliar onde contamos as ocorr√™ncias de cada n√∫mero entre 1 e n. Ao final, todos os elementos desse vetor auxiliar tem que valer 1. Dessa vez, aproveitamos e j√° colocamos os testes automatizados.\nusing Test\nfunction permuta√ß√£o(l)\n    perm = true\n    tamanho = length(l)\n    aux = zeros(Int8, tamanho)\n    for i in l\n      if i &lt; 1 || i &gt; tamanho\n        perm = false\n      else\n        aux[i] += 1\n      end\n    end\n    for i in aux\n      if i != 1\n        perm = false\n      end\n    end  \n    return perm\nend\n\n@testset \"Verifica Permuta√ß√£o\" begin\n    @test permuta√ß√£o([1,2,3])\n    @test permuta√ß√£o([3, 2, 1])\n    @test permuta√ß√£o([1])\n    @test permuta√ß√£o([2, 1])\n    @test permuta√ß√£o([4, 2, 3, 1])\n    @test !permuta√ß√£o([1, 1])\n    @test !permuta√ß√£o([1, 3])\n    @test !permuta√ß√£o([4, 2, 3, -1])\n    @test !permuta√ß√£o([5, 2, 3, 1])\n    @test permuta√ß√£o([])\n    @test !permuta√ß√£o([0, 3, 3])\n    @test !permuta√ß√£o([2, 2, 2])\nend\n\nTest Summary:       | Pass  Total  Time\nVerifica Permuta√ß√£o |   12     12  0.1s\n\n\nTest.DefaultTestSet(\"Verifica Permuta√ß√£o\", Any[], 12, false, false, true, 1.741131086041957e9, 1.74113108614224e9, false, \"/Users/lucas/Desktop/livro-intro-comp-julia/chapters/11-exercicios-2.qmd\")",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Exerc√≠cios com vetores</span>"
    ]
  },
  {
    "objectID": "chapters/11-exercicios-2.html#histograma",
    "href": "chapters/11-exercicios-2.html#histograma",
    "title": "11¬† Exerc√≠cios com vetores",
    "section": "11.2 Histograma",
    "text": "11.2 Histograma\nJ√° que vimos o exemplo anterior onde ‚Äúcontamos‚Äù o n√∫mero, podemos ir um pouco al√©m e calcular o histograma de um vetor com n√∫meros entre 1 e 10.\n\nusing Test\n\nfunction histograma(l)\n    result = [0,0,0,0,0,0,0,0,0,0]\n    i = 1\n    while i &lt;= length(l)\n        valor_atual = l[i]\n        if valor_atual &gt;= 1 && valor_atual &lt;= 10\n           result[valor_atual] += 1\n        end\n        i += 1\n    end\n    return result\nend\n\n@testset \"Verifica Histograma\" begin\n    @test [1,0,0,0,0,0,0,0,0,0] == histograma([1])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([-1])\n    @test [0,0,1,0,0,0,0,0,0,0] == histograma([3])\n    @test [0,0,0,0,0,0,0,0,0,1] == histograma([10])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([11])\n    @test [1,4,0,2,5,1,0,1,0,0] == histograma([5,6,5,4,5,5,4,2,8,2,1,2,5,2])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([])\n    end\n\nTest Summary:       | Pass  Total  Time\nVerifica Histograma |    7      7  0.0s\n\n\nTest.DefaultTestSet(\"Verifica Histograma\", Any[], 7, false, false, true, 1.741131086366627e9, 1.741131086409608e9, false, \"/Users/lucas/Desktop/livro-intro-comp-julia/chapters/11-exercicios-2.qmd\")",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Exerc√≠cios com vetores</span>"
    ]
  },
  {
    "objectID": "chapters/11-exercicios-2.html#modelando-problemas-com-o-computador",
    "href": "chapters/11-exercicios-2.html#modelando-problemas-com-o-computador",
    "title": "11¬† Exerc√≠cios com vetores",
    "section": "11.3 Modelando problemas com o computador",
    "text": "11.3 Modelando problemas com o computador\nO computador pode ser uma ferramenta bem poderosa para a modelagem de problemas reais. Para isso vamos pegar o caso do problema dos anivers√°rios. Esse problema tamb√©m √© conhecido pelo paradoxo do anivers√°rio: Calcular a probabilidade de que em uma sala com n pessoas, pelo menos duas possuam a mesma data de anivers√°rio. Esse problema pode ser resolvido usando probabilidade, por meio da qual se descobre que se a sala tem 23 pessoas a chance de duas terem a mesma data √© de pouco mais de 50%.\nMas, tamb√©m podemos modelar esse problema computacionalmente. Para isso, o primeiro passo √© simplificar as datas, ao inv√©s de m√™s e ano, podemos codificar os dias em um n√∫mero entre 1 e 365, sendo que 1 corresponderia a primeiro de janeiro. Para resolver o problema, podemos sortear n datas, e ver se h√° alguma repeti√ß√£o, se houver encontramos duas pessoas com a mesma data.\nIsso est√° representado na fun√ß√£o experimento_niver abaixo. Mas, para saber a chance real, temos que repetr o experimento v√°rias vezes. Na fun√ß√£o main() abaixo, pedimos a quantidade de experimentos e o n√∫mero de pessoas para executar a simula√ß√£o.\n\nfunction experimento_niver(n)\n    repetiu = false\n    i = 1\n    nivers = []\n    while i &lt;= n && (repetiu == false)\n        niver = rand(1:365)\n        if niver in nivers\n            repetiu = true\n        end\n        push!(nivers, niver)\n        i += 1\n    end\n    return repetiu\nend\n\nfunction main()\n    print(\"Quantos experimentos? \")\n    quantas = readline()\n    print(\"Quantas pessoas? \")\n    npessoas = readline()\n    quantas = parse(Int64, quantas)\n    npessoas = parse(Int64, npessoas)\n    sucessos = 0\n    i = 1\n    while i &lt;= quantas\n        if experimento_niver(npessoas)\n            sucessos += 1\n        end\n        i += 1\n    end\n    println(\"A probabilidade estimada √© \", 100*sucessos/quantas, \"%\")\nend\nmain()\n\nA parte interessante √© que podemos com pequenas varia√ß√µes ter outros experimentos, como verificar se mais do que duas pessoas fazem anivers√°rio na mesma data. Para isso, abaixo, contamos o n√∫mero de repeti√ß√µes.\n\nfunction experimento_niver(n)\n    repetiu = 0\n    i = 1\n    nivers = []\n    while i &lt;= n\n        niver = rand(1:365)\n        if niver in nivers\n            repetiu += 1\n        end\n        push!(nivers, niver)\n        i += 1\n    end\n    return repetiu &gt;= 2\nend\n\nexperimento_niver (generic function with 1 method)",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Exerc√≠cios com vetores</span>"
    ]
  },
  {
    "objectID": "chapters/12-blackjack.html",
    "href": "chapters/12-blackjack.html",
    "title": "12¬† Modelando um problema maior",
    "section": "",
    "text": "Nessa aula vamos modelar um jogo bem conhecido, o 21, ou BlackJack. Nele os jogadores devem tentar chegar mais perto da soma de cartas 21, sem estourar. Quem chegar mais perto ganha.\nCada jogador come√ßa com duas cartas, sendo que as cartas tem o seu valor nominal, as figuras (J, Q, K), que valem 10. Al√©m disso, o √Ås, pode valer 1 ou 11. O que for mais vantajoso para o jogador.\nPara come√ßar vamos fazer uma simula√ß√£o com um baralho, ou seja 52 cartas. J√° que] para o jogo, n√£o importa o naipe da carta, vamos supor que existem quatro cartas de cada. Para isso, vamos criar duas fun√ß√µes, uma que cria um baralho e o guarda em um vetor, e uma segunda que pega uma carta do baralho. Nessa segunda fun√ß√£o temos que ‚Äúretirar‚Äù a carta do vetor. Caso j√° n√£o exista a carta do tipo desejado, temos que sortear uma nova carta.\n\nfunction criaBaralho()\n  cards = zeros(Int8, 13)\n  i = 1\n  while i &lt; 14\n    cards[i] = 4\n    i += 1\n  end\n  return cards\nend\n\nfunction pegarCarta(cards)\n  sorteio = rand(1:13)\n  while cards[sorteio] == 0\n    sorteio = rand(1:13)\n  end\n  cards[sorteio] -= 1\n  if sorteio &gt; 10  # se a carta for figura, ela vale 10\n    sorteio = 10\n  end  \n  return sorteio\nend\n\npegarCarta (generic function with 1 method)\n\n\nDe posse dessas duas fun√ß√µes, podemos criar outras que simulam o comportamento dos jogadores. Vamos usar algumas estrat√©gias simples, como o jogador que fica com as duas cartas que recebeu.\n\nfunction jogador1(cards)\n  carta1 = pegarCarta(cards)\n  carta2 = pegarCarta(cards)\n  if carta1 == 1 || carta2 == 1\n    return carta1 + carta2 + 10\n  else\n    return carta1 + carta2\n  end  \nend\n\njogador1 (generic function with 1 method)\n\n\nNotem que acima, usamos a estrat√©gia de usar o √Ås da forma mais vantajosa.\nPara os outros jogadores, vamos usar estrat√©gias mais elaboradas, ou seja o jogador fica pegando cartas enquanto n√£o chegar a um valor pr√©-determinado, como por exemplo 21, 19, 17, 15 e 13.\nComo cada jogador pode ter um n√∫mero grande de cartas e no caso dele ter um √Ås, a conta tem que ser feita da maneira mais vantajosa, vamos usar uma fun√ß√£o que recebe um vetor de cartas e calcula a soma.\n\nfunction somaCartas(c)\n  soma = 0\n  temAz = false\n  for i in c\n    soma += i\n    if c == 1 \n      temAz = true\n    end\n  end\n  if soma &lt;= 11 && temAz\n      return soma + 10\n  else \n      return soma\n  end\nend\n\nsomaCartas (generic function with 1 method)\n\n\nDe posse do soma cartas, podemos modelar os jogadores.\n\nfunction jogador2(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 21\n    push!(cartas, pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\nfunction jogador3(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 19\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\nfunction jogador4(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 17\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\n  function jogador5(cards)\n    cartas = []\n    push!(cartas, pegarCarta(cards))\n    push!(cartas, pegarCarta(cards))\n    while somaCartas(cartas) &lt; 15\n      push!(cartas,pegarCarta(cards))\n    end\n    return somaCartas(cartas)\n  end\n\nfunction jogador6(cards)\n  cartas = []\n  push!(cartas, pegarCarta(cards))\n  push!(cartas, pegarCarta(cards))\n  while somaCartas(cartas) &lt; 13\n    push!(cartas,pegarCarta(cards))\n  end\n  return somaCartas(cartas)\nend\n\njogador6 (generic function with 1 method)\n\n\nAgora que temos todos os jogadores, podemos modelar uma partida. Para isso criamos um baralho e fazemos com que cada jogador siga a sua estrat√©gia\n\nfunction partida()\n  cards = criaBaralho()\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = jogador1(cards)\n  jogadores[2] = jogador2(cards)\n  jogadores[3] = jogador3(cards)\n  jogadores[4] = jogador4(cards)\n  jogadores[5] = jogador5(cards)\n  jogadores[6] = jogador6(cards)\nend\n\npartida (generic function with 1 method)\n\n\nN√£o deu tempo de continuar, ficou para a pr√≥xima aula.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Modelando um problema maior</span>"
    ]
  },
  {
    "objectID": "chapters/13-blackjack-cont.html",
    "href": "chapters/13-blackjack-cont.html",
    "title": "13¬† Continuando a modelagem",
    "section": "",
    "text": "No cap√≠tulo anterior ficamos com uma partida, mas sem a verifica√ß√£o do vencedor, ou seja o jogador com o maior valor, menor ou igual a 21. Uma decis√£o de projeto √© dizer que no caso de empate, os jogadores, com os maiores valores ganham e dividem o pr√™mio.\n\nfunction partida()\n  cards = criaBaralho()\n  jogadores = zeros(Int8, 6)\n  jogadores[1] = jogador1(cards)\n  jogadores[2] = jogador2(cards)\n  jogadores[3] = jogador3(cards)\n  jogadores[4] = jogador4(cards)\n  jogadores[5] = jogador5(cards)\n  jogadores[6] = jogador6(cards)\n  return jogadores\nend\n\npartida (generic function with 1 method)\n\n\nLogo, a partida devolve a pontua√ß√£o de cada jogador, para podermos verificar na rotina ganhador quem ganhou.\n\nfunction ganhador(v)\n    i = 1\n    maximo = 0\n    while i &lt;= length(v)\n        if v[i] &gt; 21  # se estourou √© como se tivesse o menor valor\n            v[i] = 0\n        end\n        if v[i] &gt; maximo\n            maximo = v[i]  # encontra o vencedor\n        end\n        i = i + 1\n    end\n    result = zeros(Int64, length(v))\n    i = 1\n        while i &lt;= length(v)\n            if v[i] == maximo\n                result[i] = 1\n            end\n            i = i + 1\n        end\n    return result\nend\n\nganhador (generic function with 1 method)\n\n\nA rotinha ganhador devolve um vetor com os vencedores, com 1 na posi√ß√£o de quem ganhou e zero na posi√ß√£o dos perdedores.\nUma das vantagens de se usar um computador √© que podemos ter milhares de partidas de 21 para encontrar qual seria a melhor estrat√©gia.\n\nfunction porcentagem()\n    i = 1\n    porc = zeros(Int64, 6)\n    while i &lt; 100000\n        porc = porc + ganhador(partida())\n        i = i + 1\n    end\n    println(porc)\nend\n\nporcentagem (generic function with 1 method)\n\n\nAo simularmos o jogo 10000 vezes, podemos encontrar qual √© a melhor estrat√©gia dentre as que foram apresentadas.\nO c√≥digo acima ficou relativamente grande, e uma das coisas que podemos notar √© que h√° muita duplica√ß√£o nos c√≥digos dos Jogadores a partir do segundo. Um dos maiores problemas de c√≥digo √© a duplica√ß√£o. No caso acima, podemos evit√°-la adicionando um par√¢metro √† fun√ß√£o Jogador, de forma que esse seja o limite a ser considerado no la√ßo. A fun√ß√£o jogador2 fica assim:\n\nfunction jogador2(cards, valor)\n    cartas = []\n    push!(cartas, pegarCarta(cards))\n    push!(cartas, pegarCarta(cards))\n    while somaCartas(cartas) &lt; valor\n       push!(cartas, pegarCarta(cards))\n    end\n    return somaCartas(cartas)\nend\n\njogador2 (generic function with 1 method)\n\n\nComo a fun√ß√£o tem um par√¢metro novo, temos que acertar a partida. Mas, agora podemos usar todos os valores.\n\nfunction partida()\n   cards = criaBaralho()\n   jogadores = zeros(Int8, 6)\n   jogadores[1] = jogador1(cards)\n   jogadores[2] = jogador2(cards, 21)\n   jogadores[3] = jogador2(cards, 20)\n   jogadores[4] = jogador2(cards, 19)\n   jogadores[5] = jogador2(cards, 18)\n   jogadores[6] = jogador2(cards, 17)\n   return jogadores\nend\n\npartida (generic function with 1 method)\n\n\nNotem que n√£o h√° mudan√ßa na fun√ß√£o ganhador, que continua funcionando.\nPara terminar, podemos ter agora uma vers√£o interativa que permite que um jogador humano jogue com o computador.\n\nfunction partidaComHumano()\n    cards = criaBaralho()\n    humano = []\n    computador = jogador2(cards, 19)\n    push!(humano, pegarCarta(cards))\n    push!(humano, pegarCarta(cards))\n    println(\"O humano tem \", humano, \" e soma \", somaCartas(humano))\n    println(\"O humano quer mais cartas (S/N)?\")\n    resp = readline()\n    while resp == \"S\" || resp == \"s\"\n         push!(humano, pegarCarta(cards))\n         println(\"O computador tem \", computador, \" e soma \", somaCartas(computador))\n         println(\"O humano tem \", humano, \" e soma \", somaCartas(humano))\n         println(\"O humano quer mais cartas (S/N)?\")\n         resp = readline()\n    end\n    println(\"O computador tem \", computador, \" e soma \", somaCartas(computador))\n    if somaCartas(computador) &lt;= 21 && somaCartas(humano) &lt;= 21\n         if somaCartas(computador) &gt; somaCartas(humano)\n             println(\"Humano Perdeu\")\n         elseif somaCartas(computador) == somaCartas(humano)\n             println(\"Empate\")\n         else\n             println(\"Humano ganhou\")\n         end\n    elseif somaCartas(computador) &gt; 21 && somaCartas(humano) &gt; 21\n         println(\"os dois perderam\")\n    elseif somaCartas(computador) &gt; 21\n         println(\"Humano ganhou\")\n    else\n         println(\"Computador ganhou\")\n    end\nend\n\npartidaComHumano (generic function with 1 method)",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Continuando a modelagem</span>"
    ]
  },
  {
    "objectID": "chapters/14-boas-praticas.html",
    "href": "chapters/14-boas-praticas.html",
    "title": "14¬† Boas pr√°ticas",
    "section": "",
    "text": "14.1 Uso de contratos\nVamos come√ßar apresentando 3 boas pr√°ticas de programa√ß√£o. Na verdade h√° uma √°rea que cuida de desenvolvimento de software, a Engenharia de Software. Vamos a elas:\nSempre que poss√≠vel o c√≥digo deve ser modular, ou seja estar repartido em arquivos e ou fun√ß√µes. Cada tipo de fun√ß√£o deve deixar claro quais s√£o os seus par√¢metros e o que ela devolve. Isso pode ser feito usando tipos.\nfunction fatorial(n::Int64)::Int64\n    if n &lt; 2 \n        return 1\n    else  \n        return n * fatorial(n - 1)\n    end\nend\n\nfatorial (generic function with 1 method)\nCom isso, fica claro o que a fun√ß√£o recebe e devolve, e se for enviado um tipo diferente do esperado, temos em erro imediato.",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Boas pr√°ticas</span>"
    ]
  },
  {
    "objectID": "chapters/14-boas-praticas.html#uso-de-contratos",
    "href": "chapters/14-boas-praticas.html#uso-de-contratos",
    "title": "14¬† Boas pr√°ticas",
    "section": "",
    "text": "14.1.1 Boa pr√°tica 1: Use tipos",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Boas pr√°ticas</span>"
    ]
  },
  {
    "objectID": "chapters/14-boas-praticas.html#testes-automatizados",
    "href": "chapters/14-boas-praticas.html#testes-automatizados",
    "title": "14¬† Boas pr√°ticas",
    "section": "14.2 Testes automatizados",
    "text": "14.2 Testes automatizados\nPara evitar que apare√ßam erros, ou os populates bugs, uma forma eficaz √© escrever c√≥digo que verifica o funcionamento do c√≥digo. Se isso for feito de forma autom√°tica, temos os testes automatizados.\n\nusing Test\nfunction testaFat()\n  @test fatorial(3) == 6\n  @test fatorial(5) == 120\n  @test fatorial(1) == 1\n  @test fatorial(0) == 1\n  @test fatorial(4) == 24\nend\n\ntestaFat (generic function with 1 method)\n\n\n\n14.2.1 Boa pr√°tica 2: Sempre que poss√≠vel fa√ßa testes",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Boas pr√°ticas</span>"
    ]
  },
  {
    "objectID": "chapters/14-boas-praticas.html#escreva-c√≥digo-para-humanos-n√£o-para-computadores",
    "href": "chapters/14-boas-praticas.html#escreva-c√≥digo-para-humanos-n√£o-para-computadores",
    "title": "14¬† Boas pr√°ticas",
    "section": "14.3 Escreva c√≥digo para humanos, n√£o para computadores",
    "text": "14.3 Escreva c√≥digo para humanos, n√£o para computadores\nApesar dos computadores serem capazes de ler c√≥digo nem sempre bem formatado, √© bem dif√≠cil para humanos lerem c√≥digo de forma n√£o padr√£o. Por isso algumas dicas importantes s√£o:\n\nUse identa√ß√£o. Com isso, os blocos ficam bem claros e √© f√°cil identificar os la√ßos, blocos de if e corpos de fun√ß√£o;\nEscolha bem o nome das vari√°veis e fun√ß√µes, isso ajuda muito quem for ler o c√≥digo\nSempre que voc√™ identificar uma possibilidade de melhoria no c√≥digo, implemente. Ainda melhor se voc√™ tiver testes automatizados, para verificar que a melhoria n√£o quebrou o c√≥digo.\n\n\n14.3.1 Boa pr√°tica 3: Escreva c√≥digo para que outros leiam",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Boas pr√°ticas</span>"
    ]
  },
  {
    "objectID": "chapters/14-boas-praticas.html#aplicando-as-boas-pr√°ticas",
    "href": "chapters/14-boas-praticas.html#aplicando-as-boas-pr√°ticas",
    "title": "14¬† Boas pr√°ticas",
    "section": "14.4 Aplicando as boas pr√°ticas",
    "text": "14.4 Aplicando as boas pr√°ticas\nVamos agora resolver o seguinte problema, aplicando as pr√°ticas acima. Dada um vetor com n√∫meros reais, determinar os n√∫meros que est√£o no vetor e o n√∫mero de vezes que cada um deles ocorre na mesma.\nAo analizar o problema, vemos que temos como entrada um vetor de n√∫mero reais, que pode conter repeti√ß√µes. Para determinar os n√∫meros que est√£o no vetor, podemos usar um outro vetor de sa√≠da. Sendo que o de entrada e o de sa√≠da devem ser do tipo Float64. Al√©m disso, para o vetor que fornece a quantidade de n√∫meros temos um vetor de inteiros. De posse disso, j√° temos a assinatura da fun√ß√£o.\n\nfunction contHist(v::Vector{Float64}, el::Vector{Float64}, qtd::Vector{Int64})\nend\n\ncontHist (generic function with 1 method)\n\n\nDe posse dessa assinatura, j√° podemos escrever os testes.\n\nfunction verifica(v::Vector{Float64}, elementos::Vector{Float64}, \n     quant::Vector{Int64})\n     el = Float64[]\n     quan = Int64[]\n     contHist(v, el, quan)\n     if el == elementos && quan == quant\n        return true\n     else\n        return false\n     end\nend\n\nfunction testaLista()\n  @test verifica([1.3, 1.2, 0.0, 1.3], [1.3, 1.2, 0.0], [2, 1, 1])\n  @test verifica([1.0, 1.0, 1.0, 1.0], [1.0], [4])\n  @test verifica([8.3], [8.3], [1])\n  @test verifica([3.14, 2.78, 2.78], [3.14, 2.78], [1, 2])\nend\n\ntestaLista (generic function with 1 method)\n\n\nFinalmente, podemos escrever o c√≥digo. A idea para escrever a solu√ß√£o √© simples, vamos percorrer o vetor de entrada. Para cada elemento, temos duas possibilidades, se ele n√£o tiver aparecido antes, temos que adicionar o n√∫mero ao vetor sa√≠da e marcar 1 ocorr√™ncia. Se j√° apareceu, basta incrementar o n√∫mero de ocorr√™ncias.\n\nfunction contHist(v::Vector{Float64}, el::Vector{Float64}, qtd::Vector{Int64})\n    for a in v\n        if a in el\n            i = 1\n            while el[i] != a\n               i += 1\n            end\n            qtd[i] += 1\n        else\n            push!(el, a)\n            push!(qtd, 1)\n        end\n    end\nend\n\ncontHist (generic function with 1 method)",
    "crumbs": [
      "Parte II: Estruturas Fundamentais e Boas Pr√°ticas",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Boas pr√°ticas</span>"
    ]
  },
  {
    "objectID": "chapters/15-matrizes.html",
    "href": "chapters/15-matrizes.html",
    "title": "15¬† Indo al√©m de uma dimens√£o (Matrizes)",
    "section": "",
    "text": "At√© o momento trabalhamos com estruturas com mais de uma dimens√£o, mas sem olharmos muito bem o seu tipo. Nessa aula vamos procurar entender as diferen√ßas entre elas e como isso pode ser usado ao nosso favor.\nVamos come√ßar com as listas:\n\nv = [1, 2, 3]\ntypeof(v)\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\nO tipo devolvido √©: Vector{Int64} (alias for Array{Int64, 1}). No caso isso significa que v √© um vetor de inteiros, ou um array de uma dimens√£o. Da mesma forma\n\nv = zeros(Int64, 3)\ntypeof(v)\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\nMas, vetores podem ser mais flex√≠veis, como por exemplo abaixo:\n\nv = [1, 2.0, \"tr√™s\"]\ntypeof(v)\n\nVector{Any} (alias for Array{Any, 1})\n\n\nNesse caso o tipo de vetor, deixa de ser de inteiros e passa a ser ‚ÄúAny‚Äù, ou seja Vector{Any} (alias for Array{Any, 1}).\nMais ainda, imaginem a seguinte situa√ß√£o:\n\na = [1, 2, 3]\npush!(v, a)\ntypeof(v)\n\nVector{Any} (alias for Array{Any, 1})\n\n\nNesse caso, o vetor continua sendo do tipo Any, mas na quarta posi√ß√£o temos um vetor com tr√™s inteiros. Com isso podemos ver que as estruturas de vetores podem ser bem flex√≠veis. Mas, apesar disso, quando temos estruturas de tipos diferentes, com muita flexibilidade, geralmente h√° alguma penalidade de uso, geralmente no desempenho.\nPor outro lado, podemos ter estruturas com mais de uma dimens√£o, no caso elas s√£o denominadas matrizes. Elas podem ser criadas com a fun√ß√£o zeros que j√° usamos acima.\n\nm = zeros(Int64, 3, 2)\ntypeof(m)\n\nMatrix{Int64} (alias for Array{Int64, 2})\n\n\nAcima foi criada uma matriz de duas dimens√µes com 3 linhas e duas colunas. Seus elementos podem se acessados como em um vetor, mas agora com dois ind√≠ces.\n\nm[1, 2]  = 10\n\n10\n\n\n\nfunction imprime(m::Array{Int64,2})\n    println(m)\nend\n\nimprime (generic function with 1 method)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    println(m[1])\n    println(m[2])\nend\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    for i in m\n        println(i)\n    end\n end\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    for i in m\n        for j in m[i]\n            println(j,\"  \")\n        end   \n    end\nend\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprime(m::Vector{Vector{Int64}})\n    for i in m\n        print(\"|\")\n        for j in i\n            print(j,\"  \")\n        end\n        println(\"|\")   \n    end\nend\n\nimprime (generic function with 2 methods)\n\n\n\nfunction imprimeMatriz(m::Matrix{Int64})\n    println(m)\nend\n\nimprimeMatriz (generic function with 1 method)\n\n\n\nfunction imprimeMatriz(m::Matrix{Int64})\n    i = 1\n    while i &lt; size(m)[1]\n        println(m[1])\n        i += 1\n    end\nend\n\nimprimeMatriz (generic function with 1 method)\n\n\n\nfunction imprimeMatriz(m::Matrix{Int64})\n    i = 1\n    while i &lt; size(m)[1]\n        j = 1\n        while j &lt; size(m)[2]\n            print(m[i, j], \" \")\n            j += 1\n        end\n        println()   \n        i += 1\n    end\nend\n\nimprimeMatriz (generic function with 1 method)\n\n\n\nfunction preencheMatriz(m::Matrix{Int64})\n    i = 1\n    while i &lt;= length(m)\n        m[i] = rand(Int) % 10\n        i += 1\n    end\nend\n\npreencheMatriz (generic function with 1 method)\n\n\n\nfunction criaIdentidate(tam::Int64)\n    m = zeros(Int64, tam, tam)\n    i = 1\n    while i &lt;= tam\n        m[i, i] = 1\n    end\n    return m  \nend\n\ncriaIdentidate (generic function with 1 method)\n\n\nOpera√ß√µes diretas com matrizes tipo +, - e *",
    "crumbs": [
      "Parte III: Conceitos Avan√ßados",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Indo al√©m de uma dimens√£o (Matrizes)</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html",
    "href": "chapters/16-exercicios-3.html",
    "title": "16¬† Aula de exerc√≠cios sobre Strings",
    "section": "",
    "text": "16.1 Concatena√ß√£o de letras\nNesta aula, vamos explorar fun√ß√µes que manipulam strings e criar testes para verificar sua corre√ß√£o. Em algumas fun√ß√µes, vamos notar que h√° diversas formas de se obter o mesmo resultado\nA primeira fun√ß√£o concatena concatena as primeiras duas e as √∫ltimas duas letras de uma string.\nfunction concatena(s::String)::String\n    if length(s) &lt; 2\n        return \"Erro: tamanho da string menor do que 2\"\n    end\n    resposta = s[1:2]*s[end-1:end]\n    return resposta\nend\n\nconcatena (generic function with 1 method)\nAwui utulizamos s[1:2] para obter as duas primeiras letras de s, que √© uma forma mais concisa de acessar mais de um √≠ndice de um objeto. Alternativamente, poder√≠amos acessar esses dois √≠ndices separadamente com o comando s[1]*s[2].\nPara verificar se a fun√ß√£o est√° funcionando corretamente, podemos utilizar o seguinte teste:\nusing Test\n\nfunction testeConcatena()\n  @test concatena(\"Ola Bom Dia\") == \"Olia\"\n  @test concatena(\"oi\") == \"oioi\"\n  @test concatena(\"tre\") == \"trre\"\n  @test concatena(\"a\") == \"Erro: tamanho da string menor do que 2\"\n  @test concatena(\"a123\") == \"a123\"\nend\n\ntesteConcatena (generic function with 1 method)",
    "crumbs": [
      "Parte III: Conceitos Avan√ßados",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html#invers√£o-de-string",
    "href": "chapters/16-exercicios-3.html#invers√£o-de-string",
    "title": "16¬† Aula de exerc√≠cios sobre Strings",
    "section": "16.2 Invers√£o de String",
    "text": "16.2 Invers√£o de String\nDevemos criar uma fun√ß√£o que interte uma string, retornando os caracteres na ordem reversa.\n\nfunction inverte(s::String)::String\n    # Inicializamos uma string vazia\n    inversa=\"\"\n\n    # Intervalo de lenght(s) at√© 1, a passos de -1\n    for i in length(s):-1:1\n        # Concatena cada caractere na ordem inversa\n        inversa*=s[i]\n    end\n\n    return inversa\nend\n\ninverte (generic function with 1 method)\n\n\nPara obter o resultado que desejamos, fazemos um la√ßo for que itera do √∫ltimo √≠ndice da string, representado por length(s), at√© o primeiro, concatenando os caracteres nessa ordem na string de retorno. O la√ßo √© configurado para decrementar o √≠ndice a cada itera√ß√£o, especificando -1 como passo. Isso nos permite acessar cada caractere da string de tr√°s para frente. E em cada itera√ß√£o, concatenamos o caractere atual, s[i], √† string inversa. Dessa forma, os caracteres s√£o adicionados na ordem inversa.\nAgora podemos criar uma fun√ß√£o de teste para verificar o funcionamento da nossa fun√ß√£o inverte.\n\nusing Test\n\nfunction testeInverte()\n  @test inverte(\"123\") == \"321\"\n  @test inverte(\"x\") == \"x\"\n  @test inverte(\"SOS\") == \"SOS\"\n  @test inverte(\"tres\") == \"sert\"\nend\n\ntesteInverte (generic function with 1 method)\n\n\n\n16.2.1 Fun√ß√£o reverse\n√â interessante notar que Julia j√° fornece uma fun√ß√£o chamada reverse, que pode ser utilizada para inverter tanto vetores quanto strings. Por exemplo:\n\nreversa = reverse(\"exemplo\")\n\n\"olpmexe\"\n\n\nNeste exemplo, a fun√ß√£o reverse recebe como par√¢metro apenas o objeto a ser invertido, mas no caso de vetores, podemos ainda informar exatamente o intervalo que desejamos que seja invertido.\n\nvetor = [1, 2, 3, 4, 5]\nreversa = reverse(vetor, 2, 4)\n\n5-element Vector{Int64}:\n 1\n 4\n 3\n 2\n 5",
    "crumbs": [
      "Parte III: Conceitos Avan√ßados",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html#modifica√ß√£o-de-string",
    "href": "chapters/16-exercicios-3.html#modifica√ß√£o-de-string",
    "title": "16¬† Aula de exerc√≠cios sobre Strings",
    "section": "16.3 Modifica√ß√£o de String",
    "text": "16.3 Modifica√ß√£o de String\nA terceira fun√ß√£o modifica altera uma string que termina com ‚Äúing‚Äù para adicionar ‚Äúly‚Äù ou, caso contr√°rio, adiciona ‚Äúing‚Äù.\n\nfunction modifica(s::String)::String\n    if length(s) &lt; 3\n        return \"Erro: tamanho da string menor do que 3\"\n    end\n    \n    if s[end-2:end] == \"ing\"\n        s = s*\"ly\"\n    else    \n        s = s*\"ing\"                \n    end\n\n\n    return s\nend\n\nmodifica (generic function with 1 method)\n\n\nNeste exemplo, verificamos manualmente os √∫ltimos tr√™s caracteres da string s. No entanto, Julia oferece uma fun√ß√£o mais pr√°tica e leg√≠vel chamada endswith, que podemos usar para simplificar essa verifica√ß√£o.\n\nfunction modifica(s::String)::String\n    if length(s) &lt; 3\n        return \"Erro: tamanho da string menor do que 3\"\n    end\n    \n    if endswith(s, \"ing\")\n        s = s*\"ly\"\n    else    \n        s = s*\"ing\"                \n    end\n\n    return s\nend\n\nmodifica (generic function with 1 method)\n\n\nVamos ent√£o escrever o teste que verifica o correto funcionamento das fun√ß√µes anteriores\n\nusing Test\nfunction testaModifica()\n  @test modifica(\"doing\") == \"doingly\"\n  @test modifica(\"sing\") == \"singly\"\n  @test modifica(\"run\") == \"runing\"\n  @test modifica(\"talk\") == \"talking\"\nend\n\ntestaModifica (generic function with 1 method)",
    "crumbs": [
      "Parte III: Conceitos Avan√ßados",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html#rearranjo-de-letras",
    "href": "chapters/16-exercicios-3.html#rearranjo-de-letras",
    "title": "16¬† Aula de exerc√≠cios sobre Strings",
    "section": "16.4 Rearranjo de letras",
    "text": "16.4 Rearranjo de letras\nA segunda fun√ß√£o rearranja recebe uma string e devolve uma string que cont√©m as letras min√∫sculas primeiro, seguidas pelas letras mai√∫sculas.\nPodemos verificar se uma letra √© mai√∫scula ou min√∫scula usando a tabela ASCII, que codifica caracteres em n√∫meros inteiros. Na tabela, as letras mai√∫sculas est√£o no intervalo de 65 a 90, e as letras min√∫sculas no intervalo de 97 a 122.\nPara saber mais sobre a tabela ASCII voc√™ pode acessar essa p√°gina.\n\nfunction rearranja(s::String)::String\n    maiusculos=\"\"\n    minusculos=\"\"\n\n    for i in 1:length(s)\n        if Int(s[i]) &gt;= 65 && Int(s[i]) &lt;= 90 \n            maiusculos = maiusculos*s[i]\n        elseif Int(s[i]) &gt;= 97 && Int(s[i]) &lt;= 122\n            minusculos = minusculos*s[i]\n        end \n    end\n\n    return minusculos*maiusculos\n     \nend\n\nrearranja (generic function with 1 method)\n\n\nUma abordagem mais leg√≠vel √© utilizar as fun√ß√µes islowercase e isuppercase, que verificam se uma letra √© min√∫scula ou mai√∫scula, respectivamente.\n\nfunction rearranja(s::String)::String\n    maiusculos=\"\"\n    minusculos=\"\"\n\n    for i in 1:length(s)\n        if isuppercase(s[i]) \n            maiusculos = maiusculos*s[i]\n        elseif islowercase(s[i])\n            minusculos = minusculos*s[i]\n        end \n    end\n\n    return minusculos*maiusculos\n     \nend\n\nrearranja (generic function with 1 method)\n\n\nPodemos ent√£o escrever o teste para nossas fun√ß√µes.\n\nusing Test\n\nfunction testaRearranja()\n  @test rearranja1(\"PaRaLelO\") == \"aaelPRLO\"\n  @test rearranja1(\"ELEfantE\") == \"fantELEE\"\n  @test rearranja1(\"Ol√°\") == \"lO\"\n  @test rearranja1(\"13La2\") == \"aL\"\n  @test rearranja2(\"PaRaLelO\") == \"aaelPRLO\"\n  @test rearranja2(\"ELEfantE\") == \"fantELEE\"\n  @test rearranja2(\"Ol√°\") == \"l√°O\"\n  @test rearranja2(\"13La2\") == \"aL\"\nend\n\ntestaRearranja (generic function with 1 method)",
    "crumbs": [
      "Parte III: Conceitos Avan√ßados",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html#encontrar-a-maior-palavra",
    "href": "chapters/16-exercicios-3.html#encontrar-a-maior-palavra",
    "title": "16¬† Aula de exerc√≠cios sobre Strings",
    "section": "16.5 Encontrar a maior palavra",
    "text": "16.5 Encontrar a maior palavra\nNossa √∫ltima fun√ß√£o deve receber uma lista de palavras e retornar a maior delas, junto de seu tamanho.\n\nfunction maior_palavra(vetor::Vector{String})\n    # Inicialmente, a maoior palavra que encontramos √© uma string vazia\n    maior_palavra = \"\"\n    maior_tamanho = 0\n\n    for palavra in vetor\n        #  Verifica se a palavra atual √© maior que a maior encontrada at√© agora\n        if length(palavra) &gt; maior_tamanho \n            maior_palavra = palavra\n            maior_tamanho = length(palavra)\n        end\n    end\n\n    return maior_palavra, maior_tamanho\n\nend\n\nmaior_palavra (generic function with 1 method)\n\n\nApesar de parecer correto, esse c√≥digo n√£o lida com o caso de haver mais de uma palavra com o maior tamanho. Como por exemplo:\n\nvetor = [\"boa\", \"bem\", \"oi\"]\nmaior_palavra(vetor)\n\n(\"boa\", 3)\n\n\nNesse caso, apenas a palavra ‚Äúboa‚Äù ser√° retornada, mesmo que ‚Äúbem‚Äù tenha o mesmo tamanho. Para consertar a fun√ß√£o devemos alterar a vari√°vel em que guardamos a maior palavra, para que possamos armazenar mais de uma palavra, para isso vamos usar um vetor de strings.\n\nfunction maiores_palavras(vetor::Vector{String})\n    maiores_palavras = String[]\n    maior_tamanho = 0\n\n    for palavra in vetor\n        # Se a palavra √© maior do que o maior tamanho salvo, \n        # ent√£o todas as palavras que est√£o no vetor maior_palavra s√£o menores do que a palavra atual\n        if length(palavra) &gt; maior_tamanho \n            # Limpa o vetor e salva a palavra atual\n            maiores_palavras = String[]\n            push!(maiores_palavras, palavra)\n            maior_tamanho = length(palavra)\n\n        # Se √© igual ao tamanho salvo, ent√£o √© do mesmo tamanho que as palavras j√° salvas no vetor maiores_palavras,\n        # apenas damos push na palavra atual\n        elseif length(palavra) == maior_tamanho\n            push!(maiores_palavras, palavra) \n        end\n    end\n\n    return maiores_palavras, maior_tamanho\n\nend\n\nmaiores_palavras (generic function with 1 method)\n\n\nAssim podemos escrever testes para esta √∫ltima fun√ß√£o .\n\nusing Test\n\nfunction testeMaioresPalavras()\n    vetor1 = [\"gato\", \"elefante\", \"cachorro\"]\n    @test maiores_palavras(vetor1) == ([\"elefante\", \"cachorro\"], 8)  \n    \n    vetor2 = [\"a\", \"ab\", \"abc\"]\n    @test maiores_palavras(vetor2) == ([\"abc\"], 3)        \n    \n    vetor3 = [\"bem\", \"boa\", \"bom\", \"oi\"]\n    @test maiores_palavras(vetor3) == ([\"bem\", \"boa\", \"bom\"], 3)       \n\n    vetor4 = [\"\", \" \", \"teste\"]\n    @test maiores_palavras(vetor4) == ([\"teste\"], 5)      \n\n    vetor5 = String[]\n    @test maiores_palavras(vetor5) == ([], 0)              \n\n    vetor6 = [\"a\", \"ab\", \"abc\", \"xyz\", \"xy\"]\n    @test maiores_palavras(vetor6) == ([\"abc\", \"xyz\"], 3)  \nend\n\ntesteMaioresPalavras (generic function with 1 method)",
    "crumbs": [
      "Parte III: Conceitos Avan√ßados",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "chapters/16-exercicios-3.html#retorno-de-m√∫ltiplos-valores",
    "href": "chapters/16-exercicios-3.html#retorno-de-m√∫ltiplos-valores",
    "title": "16¬† Aula de exerc√≠cios sobre Strings",
    "section": "16.6 Retorno de m√∫ltiplos valores",
    "text": "16.6 Retorno de m√∫ltiplos valores\nComo visto no exerc√≠cio anterior, Julia permite que uma fun√ß√£o retorne m√∫ltiplos valores. Isso permite que voc√™ envie mais de um resultado ao chamar uma fun√ß√£o, tornando o c√≥digo mais conciso e f√°cil de entender. Essa funcionalidade √© especialmente √∫til em situa√ß√µes onde voc√™ precisa de mais de um resultado, como em opera√ß√µes matem√°ticas, decomposi√ß√µes, ou processamento de dados.\nPara retornar m√∫ltiplos valores em Julia, voc√™ pode simplesmente separ√°-los por v√≠rgulas. Aqui est√° um exemplo simples:\n\nfunction troca(a,b)\n    aux = a\n    a = b\n    b = aux\n\n    return a, b\nend\n\ntroca (generic function with 1 method)\n\n\nAo chamar essa fun√ß√£o, voc√™ pode capturar os m√∫ltiplos valores retornados em vari√°veis separadas:\n\na, b = troca(1, 10)\n\n(10, 1)",
    "crumbs": [
      "Parte III: Conceitos Avan√ßados",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Aula de exerc√≠cios sobre Strings</span>"
    ]
  },
  {
    "objectID": "appendices/01-questionario.html",
    "href": "appendices/01-questionario.html",
    "title": "Ap√™ndice A ‚Äî Respostas para a pergunta ‚ÄúO que √© um computador?‚Äù",
    "section": "",
    "text": "As respostas foram coletadas atrav√©s do site https://www.bli.do/MAC115. Eis as respostas:\n\n‚Äú√â uma m√°quina que utiliza certos padr√µes para processar informa√ß√µes. √â uma evolu√ß√£o da te√≥rica m√°quina de Turing e pode ser considerada uma extens√£o de nossa intelig√™ncia.‚Äù\n‚ÄúComputador: configura uma m√°quina capaz de realizar processos bin√°rios de cria√ß√£o e an√°lise, sendo esses modelados pelo pr√≥prio dispositivo (IA) ou por um programador. Um produto de passos.‚Äù\n‚ÄúUm computador √© uma m√°quina capaz de identificar c√≥digos baseados em binariedade utilizando linguagem l√≥gica.‚Äù\n‚Äú√â um instrumento tecnol√≥gico que junta milh√µes de dados que diversas pessoas ao redor do mundo distribuem, possibilitando trabalhar de forma t√©cnica criando novos dados e meios de alcan√ßar respostas.‚Äù\n‚ÄúUm dispositivo que vive na tomada.‚Äù\n‚Äú√â um equipamento que‚Äùroda‚Äù um programa instalado que recebe dados, os processa e tem com sa√≠da o resultado, se tudo correr bem‚Ä¶‚Äù\n‚ÄúDecodificador.‚Äù\n‚ÄúTem por finalidade ser uma ferramenta baseada em algoritmos e l√≥gica de decis√£o que vez programada e orientada possa possibilitar a resolu√ß√£o de problemas por coleta de dados, informa√ß√µes e ent√£o gera√ß√£o de sistemas.‚Äù\n‚ÄúUm computador √© um dispositivo eletr√¥nico caracterizado pela sua capacidade de processamento l√≥gico. S√£o constru√≠dos com semicondutores e pode apresentar v√°rias pe√ßas diferentes, como fonte (ou bateria), placa m√£e, processador, placa de v√≠deo, mem√≥rias e etc.‚Äù\n‚Äúum rob√¥ que vai controlar os humanos um dia.‚Äù\n‚ÄúDispositivo que faz contas.‚Äù\nUm computador √© um dispositivo que computa, que faz contas, utilizando uma CPU (Central Processing Unit) para fazer c√°lculos utilizando o sistema bin√°rio. 0 e 1, que s√£o utilizados em portas l√≥gicas que s√£o feitas de sil√≠cio, um semicondutor que permite que c√°lculos utilizando esses dois d√≠gitos sejam realizados.‚Äù\n‚ÄúUma m√°quina.‚Äù\n‚Äú√â um neg√≥cio que tem ferramentas que ajudam a realizar diferentes tarefas.‚Äù\n‚Äú√â um celular 2.0.‚Äù\n‚ÄúO computador √© uma m√°quina que obedece comandos.‚Äù\n‚ÄúUma calculadora.‚Äù\n‚ÄúM√°quina de Turing.‚Äù\n‚ÄúComputador √©, de uma forma bem simplificada, uma intelig√™ncia eletr√¥nica composta de uma carca√ßa (hardware) que completa a parte do software, feita para responder comandos.‚Äù\n‚ÄúA evolu√ß√£o da calculadora.‚Äù",
    "crumbs": [
      "Ap√™ndices",
      "<span class='chapter-number'>A</span>¬† <span class='chapter-title'>Respostas para a pergunta \"O que √© um computador?\"</span>"
    ]
  }
]