---
engine: julia
---
# Usando o Interpretador (REPL) como Calculadora

O objetivo deste cap√≠tulo √© apresentar o interpretador de Julia como uma calculadora poderosa e introduzir os primeiros conceitos de programa√ß√£o: vari√°veis e fun√ß√µes. Mas primeiro √© preciso instalar a linguagem Julia em seu computador. Mais detalhes sobre o processo de instala√ß√£o podem ser encontrados neste [link](https://julialang.org/downloads/).

Muito provavelmente seu sistema √© Windows (10 ou 11) e sua arquitetura √© de 64-bits. H√° algumas formas de instalar Julia no Windows:

1. Atrav√©s de um arquivo execut√°vel (`.exe`).
2. Atrav√©s de comandos pelo terminal (`winget`).

A princ√≠pio qualquer uma das op√ß√µes √© adequada. A primeira op√ß√£o n√£o requer nenhum programa adicional, enquanto que a segunda requer um terminal. Um terminal √© um aplicativo que permite a comunica√ß√£o com o sistema operacional por meio de uma interface de linha de comando (CLI). O terminal padr√£o do Windows √© o Windows Terminal. √â fortemente recomendado que voc√™ o tenha instalado e isso pode ser feito atrav√©s da Microsoft Store.

Uma vez que voc√™ tenha acesso a um terminal h√° dois comandos poss√≠veis para instalar Julia: `winget install julia -s msstore` ou `winget install -e --id Julialang.Julia`. Mais uma vez, qualquer uma das op√ß√µes deve funcionar.

## Explorando a Sess√£o Interativa de Julia

Voc√™ pode abrir uma sess√£o interativa (tamb√©m conhecido como um *read-eval-print loop* ou REPL) de Julia digitando o comando `julia` na linha de comando do seu terminal. No Windows, ap√≥s instala√ß√£o da linguagem, √© poss√≠vel abrir uma sess√£o interativa clicando duas vezes no execut√°vel Julia. A sua janela deve ser parecida com

```
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.11.3 (2025-01-21)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |


julia>
```

Dentro da sess√£o podemos inserir comandos que ser√£o lidos, avaliados e impressos na tela. Um comando s√≥ √© avaliado quando teclamos **Enter**. Vamos come√ßar com opera√ß√µes com n√∫meros inteiros. Para somar dois n√∫meros podemos digitar:

```{julia}
1 + 2
```

Para multiplicar outros dois n√∫mero:

```{julia}
40 * 4
```

Como esperado, podemos utilizar as opera√ß√µes b√°sicas de soma (`+`), subtra√ß√£o (`-`) e multiplica√ß√£o (`*`), e os resultados ocorrem como previsto. No entanto, observaremos a seguir que o comportamento da divis√£o apresenta algumas particularidades:

```{julia}
a = 84 
b = 2

# As vari√°veis a e b s√£o do tipo Int64

resultado = a / b
println(resultado)
```

Notem que, neste exemplo, ocorreu uma convers√£o de tipo, pois 84 e 2 s√£o n√∫meros inteiros, enquanto o resultado √© um n√∫mero em ponto flutuante (float). Os pontos flutuantes s√£o representa√ß√µes bin√°rias de n√∫meros reais, tema que exploraremos com mais detalhes em breve. Esta convers√£o fica evidente pela representa√ß√£o do resultado como `42.0`, em vez de simplesmente `42`. Caso deseje obter o resultado como um n√∫mero inteiro, √© poss√≠vel utilizar o operador `div`:

```{julia}
div(84,2)
```

Ou de forma equivalente usando o operador `\div` (para conseguir ver o s√≠mbolo da divis√£o √© necess√°rio digitar `\div` seguido da tecla `<tab>`).

Al√©m das opera√ß√µes b√°sicas, √© poss√≠vel fazer exponencia√ß√£o:

```{julia}
2^31
```

Express√µes mais complexas tamb√©m podem ser calculadas:

```{julia}
23 + 2 * 2 + 3 * 4
```

Sim, a preced√™ncia de operadores usual tamb√©m √© v√°lida em Julia. Entretanto, lembre-se da primeira li√ß√£o de programa√ß√£o: *Escreva para humanos, n√£o para m√°quinas*. Podemos usar par√™nteses para separar as opera√ß√µes:

```{julia}
23 + (2 * 2) + (3 * 4)
```

Lembra dos pontos flutuantes? Todas as opera√ß√µes vistas podem ser aplicadas em pontos flutuantes:

```{julia}
23.5 * 3.14
```

Ou:

```{julia}
12.5 / 2.0
```


O exemplo acima demonstra mais um c√≥digo escrito de forma clara para pessoas, onde ao utilizarmos `2.0` deixamos expl√≠cito que o segundo par√¢metro √© um n√∫mero de ponto flutuante (float). √â fundamental compreender que n√∫meros de ponto flutuante possuem precis√£o **limitada**, portanto n√£o se surpreenda ao encontrar resultados inesperados como os demonstrados abaixo:

```{julia}
1.2 - 1.0
```

Erros como esse s√£o bastante raros, tanto que normalmente depositamos total confian√ßa nas contas realizadas por computadores e calculadoras. No entanto, √© importante reconhecer que existem limita√ß√µes (veja os exemplos abaixo).

```{julia}
2.6 - 0.7 - 1.9
```

```{julia}
0.1 + 0.2
```

```{julia}
10e15 + 1 - 10e15
```

Esses problemas de precis√£o est√£o ligados √† limita√ß√£o de como os n√∫meros s√£o representados no computador. De maneira simplificada, os valores no computador s√£o codificados em palavras, formadas por bits. Nos computadores modernos, as palavras t√™m 64 bits, ou 8 bytes. Logo, uma outra limita√ß√£o est√° relacionada aos n√∫meros inteiros muito grandes.

```{julia}
2^63
```

No entanto, para um curso introdut√≥rio, √© suficiente estar ciente dessas limita√ß√µes. O tratamento dessas quest√µes faz parte de disciplinas mais avan√ßadas. Vale ressaltar que o erro mencionado anteriormente √© um *erro silencioso*, ou seja, ao trabalharmos com n√∫meros inteiros, pode acontecer que o valor a ser representado exceda a capacidade do n√∫mero de bits dispon√≠vel, resultando em uma falha que ocorre sem notifica√ß√£o expl√≠cita.

Voltando √†s contas. Um outro operador interessante √© o `%` que calcula o resto da divis√£o

```{julia}
4 % 3
```

At√© agora vimos como trabalhar com um √∫nico valor, como se estiv√©ssemos usando o visor de uma calculadora. Mas podemos ir al√©m disso. Em vez de simples teclas de mem√≥ria, o computador nos oferece **vari√°veis**. Essas s√£o como nomes para valores que queremos armazenar e utilizar posteriormente.

Al√©m das opera√ß√µes b√°sicas tamb√©m temos as opera√ß√µes matem√°ticas (fun√ß√µes), como por exemplo o seno, *sine* em ingl√™s. Para saber como uma fun√ß√£o funciona podemos pedir ajuda ao ambiente, usando uma `?` ou o macro `@doc`, e em seguida digitando o que queremos saber, como por exemplo em:

```{julia}
#| eval: false
@doc sin
```

A sa√≠da desse comando indica a opera√ß√£o que a fun√ß√£o realiza e ainda apresenta alguns exemplos: 

```
sin(x)

Compute sine of x, where x is in radians.

See also sind, sinpi, sincos, cis, asin.

Examples
‚â°‚â°‚â°‚â°‚â°‚â°‚â°‚â°

julia> round.(sin.(range(0, 2pi, length=9)'), digits=3)
1√ó9 Matrix{Float64}:
0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0
```

Ambos os comandos `? sin` e `@doc sin` possuem a mesma sa√≠da.

Notem que nem tudo que foi apresentado faz sentido no momento, mas j√° d√° para entender o uso de uma fun√ß√£o como `sin`. Vejamos agora a raiz quadrada:

```{julia}
#| eval: false
@doc sqrt
```

```
sqrt(x)

Return \sqrt{x}.

Throws DomainError for negative Real arguments. Use complex negative arguments instead. Note that sqrt has a branch cut
along the negative real axis.

The prefix operator ‚àö is equivalent to sqrt.

See also: hypot
...
```

Nela vemos que √© poss√≠vel calcular a raiz como em:

```{julia}
sqrt(4)
```

```{julia}
sqrt(4.0)
```

Agora, observe que a documenta√ß√£o da fun√ß√£o `big()` tem a seguinte ajuda:

```
big(T::Type)

Compute the type that represents the numeric type T with arbitrary precision. Equivalent to typeof(big(zero(T))).

Examples
‚â°‚â°‚â°‚â°‚â°‚â°‚â°‚â°

julia> big(Rational)
Rational{BigInt}

julia> big(Float64)
BigFloat

julia> big(Complex{Int})
Complex{BigInt}

big(x)

Convert a number to a maximum precision representation (typically BigInt or BigFloat). See BigFloat for information about
some pitfalls with floating-point numbers.
```

A fun√ß√£o `big()` permite criar n√∫meros de grande magnitude, representados pelos tipos `BigInt` ou `BigFloat`. Essa fun√ß√£o √© particularmente √∫til quando voc√™ precisa trabalhar com n√∫meros muito grandes que ultrapassam os limites dos tipos padr√£o, como `Int64` ou `Int32`. Ao utilizar n√∫meros do tipo `BigInt`, eliminamos problemas de estouro (overflow), conforme podemos observar abaixo:

```{julia}
big(2) ^ 1002
```

## Vari√°veis e Tipos de Dados

Como j√° introduzido, em Julia, temos o conceito de vari√°veis. Vari√°veis servem para armazenar dados diversos, como inteiros e floats. Podemos operar nas vari√°veis da mesma forma que operamos nos dados que elas guardam (veja o exemplo abaixo).

```{julia}
a = 7
2 + a
```

√â importante destacar que as vari√°veis em Julia podem receber novos valores, e o tipo da vari√°vel √© determinado pela √∫ltima atribui√ß√£o realizada. A fun√ß√£o `typeof` pode ser usada para identificar o tipo da vari√°vel especificada.

```{julia}
a = 3
typeof(a)
```

```{julia}
a = a + 1
typeof(a)
```

No exemplo a seguir, a vari√°vel `b` come√ßa com um valor de tipo inteiro. No entanto, ap√≥s a opera√ß√£o de multiplica√ß√£o, seu valor passa a ser do tipo ponto flutuante.

```{julia}
b = 3
b = b * 0.5
typeof(b)
```

A capacidade de alterar o tipo da vari√°vel √© conhecida como **tipagem din√¢mica**. Esta caracter√≠stica apresenta diversas vantagens, como a flexibilidade de reutilizar vari√°veis para armazenar diferentes tipos de dados ao longo do tempo e a menor verbosidade, pois n√£o √© necess√°rio especificar o tipo de cada vari√°vel, o que melhora a legibilidade do c√≥digo. Neste contexto, podemos observar que Julia possui v√°rios tipos primitivos, sendo os principais:

```{julia}
typeof(1)
```

```{julia}
typeof(1.1)
```

```{julia}
typeof("Bom dia")
```

Falando em **strings**, elas s√£o definidas por conjuntos de caracteres entre aspas como:

```{julia}
s1 = "Olha que legal"
s2 = "Outra String"
```

Tamb√©m √© poss√≠vel realizar opera√ß√µes com strings, como concatena√ß√£o:

```{julia}
s1 = "Tenha um"
s2 = " Bom dia"
s3 = s1 * s2
```

Ou repeti√ß√£o usando o operador de pot√™ncia:

```{julia}
s = "N√£o vou mais fazer coisas que possam desagradar os meus colegas "
s ^ 10
```

Ainda sobre vari√°veis, h√° algumas regras referentes aos seus nomes: devem come√ßar com uma letra (ou com `_`), podem conter d√≠gitos e n√£o podem ser palavras reservadas. Vale ressaltar que Julia, por ser uma linguagem moderna, aceita caracteres unicode e emojis nos nomes, como por exemplo o Œî (`\Delta`).

```{julia}
Œî = 2
```

```{julia}
üê± = 5 # \:cat: <tab>
üê∂ = 3 # \:dog: <tab>
üè† = 20 # \:house: <tab>
```

Isso n√£o adiciona nada do lado de algoritmos, mas √© poss√≠vel ter vari√°veis bem bonitinhas. A lista de figuras pode ser encontrada [aqui](https://docs.julialang.org/en/v1/manual/unicode-input/).

## Sa√≠da de Dados
Para fazer sa√≠das usam-se dois comandos, `print()` e o `println()`, sendo que o primeiro n√£o pula linha e o segundo pula.

```{julia}
print("Hello ")
println("World!")
println("Ola, mundo!")
```

Para evitar que se digitem muitos caracteres, por vezes podemos usar *a√ßucares sint√°ticos*.

```{julia}
x = 1
x = x + 1
x += 1  # forma equivalente a acima, o mesmo vale para os operadores *, - e /
```

O c√≥digo acima utiliza coment√°rios (tudo depois do `#`). Esses coment√°rios s√£o ignorados pelo interpretador e podem ser usados para tornar o c√≥digo mais leg√≠vel.

## Arquivos Externos

Podemos carregar fun√ß√µes de outros arquivos na sess√£o interativa (e em outros arquivos tamb√©m) usando o comando `include("caminho/do/arquivo.jl")`. Julia l√™ o arquivo especificado e executa todo o seu conte√∫do no contexto atual. Isso significa que todas as fun√ß√µes, vari√°veis e defini√ß√µes no arquivo tornam-se dispon√≠veis no ambiente onde `include` foi chamado.

Por exemplo, suponha que temos um arquivo chamado `funcoes.jl` que possui a fun√ß√£o `ola`:

```{julia}
function ola(nome)
    println("Ol√° ", nome)
end
```

Podemos incluir essa fun√ß√£o em um segundo arquivo utilizando o `include("funcoes.jl")` e ent√£o usar a fun√ß√£o definida no arquivo `funcoes.jl`:

```{julia}
#| eval: false
include("funcoes.jl")
println(ola("Alfredo"))
```

A sa√≠da dever√° ser `Ol√° Alfredo`.

### O que √© um arquivo `.jl`?

Um arquivo `.jl` √© semelhante a um arquivo de texto `.txt`, por√©m com a extens√£o `.jl`. Embora seja poss√≠vel abri-lo com um editor de texto simples como o Bloco de Notas, n√£o √© recomendado utiliz√°-lo para programa√ß√£o. Os arquivos `.jl` s√£o arquivos de c√≥digo-fonte da linguagem Julia e s√£o geralmente editados com editores espec√≠ficos para programa√ß√£o, como Visual Studio Code, Atom ou Sublime Text.

N√£o existe um editor de texto definitivamente superior aos demais, o importante √© escolher aquele com o qual voc√™ se sinta mais confort√°vel. Nossa recomenda√ß√£o √© o Visual Studio Code, que oferece recursos muito mais avan√ßados que um editor de texto comum e possui uma extens√£o dedicada √† linguagem Julia, facilitando significativamente a escrita de c√≥digo. Para come√ßar a usar o Visual Studio Code com Julia, os tutoriais a seguir podem ser √∫teis:

- [https://code.visualstudio.com/docs/getstarted/getting-started](https://code.visualstudio.com/docs/getstarted/getting-started)
- [https://code.visualstudio.com/docs/languages/julia](https://code.visualstudio.com/docs/languages/julia)

## Verifique seu Aprendizado

1. Qual a diferen√ßa entre os resultados obtidos pelos operadores `/` e `div` em Julia? Em quais situa√ß√µes cada um seria mais apropriado?
2. Por que a express√£o `2.6 - 0.7 - 1.9` n√£o resulta exatamente em zero? O que isso nos ensina sobre c√°lculos computacionais?
3. Explique o que significa 'tipagem din√¢mica' e como isso afeta o comportamento das vari√°veis quando atribu√≠mos diferentes tipos de valores a elas.
4. Use a fun√ß√£o `big()` para calcular $2^{1000}$. Compare este resultado com o que acontece ao tentar calcular $2^{1000}$ sem usar `big()`.
5. Armazene seu nome e sobrenome em vari√°veis separadas e depois combine-as para formar seu nome completo com um espa√ßo entre elas. Demonstre tamb√©m a opera√ß√£o de repeti√ß√£o de strings.
6. Crie as vari√°veis `a = 10`, `b = 3` e `c = 4.5`. Realize os seguintes c√°lculos: `a + b + c`, `a * b * c`, `a % b` e verifique o tipo do resultado de cada opera√ß√£o usando `typeof()`.

## Explore por Conta Pr√≥pria

1. Procure na documenta√ß√£o duas fun√ß√µes matem√°ticas que n√£o foram mencionadas no cap√≠tulo e teste seu uso no REPL.
2. O que acontece quando voc√™ tenta dividir um n√∫mero por zero em Julia? E quando calcula `0/0`? Teste e observe os resultados.
3. Experimente o operador Unicode `‚âà` (digite `\approx` seguido de **TAB**). Como ele se comporta ao comparar `0.1 + 0.2 ‚âà 0.3`?
4. Investigue a fun√ß√£o `round()` e utilize-a para corrigir alguns dos problemas de precis√£o demonstrados no cap√≠tulo.