---
engine: julia
---
# Usando o Interpretador (REPL) como Calculadora

Objetivo: Ver o interpretador de Julia como uma calculadora poderosa, introduzir a no√ß√£o de vari√°veis.

## Come√ßando com o modo interativo do Julia

Quem quiser j√° pode instalar o ambiente de programa√ß√£o, usem esse [link](https://julialang.org/). H√° tamb√©m alguns ambientes que permitem o uso da linguagem no seu navegador, sugiro a busca pelas palavras chave `Julia Language online`.

Dentro do Julia (ap√≥s chamar julia na linha de comando), vamos come√ßar com contas com n√∫meros inteiros:

```{julia}
1 + 2
```


```{julia}
40 * 4
```

Sim, como era de se esperar, podemos em Julia usar os operandos: `+`, `-` e `*`, o resultado ser√° como o esperado. Vejamos a seguir que com a divis√£o fica um pouco diferente:


```{julia}
a = 84 
b = 2

# As vari√°veis a e b s√£o do tipo Int64

resultado = a / b
println(resultado)
```

Notem que nesse caso, houve uma mudan√ßa de tipos, pois 84 e 2 s√£o inteiros e o resultado √© um n√∫mero em ponto flutuante (float), podemos ver isso, pois ao inv√©s de 42, tivemos como resultado 42.0.

Tamb√©m √© poss√≠vel pedir o resultado inteiro usando o operador `div`:

```{julia}
div(84,2)
```

Ou de forma equivalente usando o operador `\div` (para conseguir ver o s√≠mbolo da divis√£o √© necess√°rio digitar `\div` seguido da tecla `<tab>`).

Al√©m das contas b√°sicas, tamb√©m d√° para fazer a exponencia√ß√£o:

```{julia}
2^31
```

Express√µes mais complexas tamb√©m podem ser calculadas:

```{julia}
23 + 2 * 2 + 3 * 4
```

Sim, a preced√™ncia de operadores usual tamb√©m √© v√°lida em Julia. Mas, segue a primeira li√ß√£o de programa√ß√£o: *Escreva para humanos, n√£o para m√°quinas*.

```{julia}
23 + (2 * 2) + (3 * 4)
```

Em Julia tamb√©m podemos fazer opera√ß√µes com n√∫meros em ponto flutuante:

```{julia}
23.5 * 3.14
```

ou

```{julia}
12.5 / 2.0
```

Acima temos mais um exemplo de c√≥digo escrito para pessoas, ao se escrever 2.0 estamos deixando claro que o segundo par√¢metro √© um n√∫mero float.

√â importante saber que n√∫meros em ponto flutuante tem precis√£o limitada, logo n√£o se espante com resultados inesperados como abaixo:

```{julia}
1.2 - 1.0
```

Erros como esse s√£o bastante raros, tanto que usualmente confiamos plenamente nas contas feitas com computadores e calculadoras. Mas, √© bom saber que existem limita√ß√µes.

```{julia}
2.6 - 0.7 - 1.9
```

ou

```{julia}
0.1 + 0.2
```

ou ainda

```{julia}
10e15 + 1 - 10e15
```

Esses problemas de precis√£o est√£o ligados a limita√ß√£o de como os n√∫meros s√£o representados no computador. De maneira simplificada, os valores no computador s√£o codificados em palavras, formadas por bits. Nos computadores modernos as palavras tem 64 bits, ou 8 bytes. Logo, uma outra limita√ß√£o est√° ligada aos n√∫meros inteiros muito grandes

```{julia}
2^63
```

Mas, para um curso introdut√≥rio basta saber que existem essas limita√ß√µes. Como lidar com elas √© parte de um curso mais avan√ßado.

√â importante notar que o erro acima √© um *erro silencioso*, ou seja quanto estamos usando n√∫meros inteiros, pode ocorrer que o n√∫mero a ser representado n√£o caiba no n√∫mero de bits dispon√≠vel, o que faz com que ocorra um erro.

Voltando para as contas. Um outro operador interessante √© o `%` que faz o resto da divis√£o

```{julia}
4 % 3
```

At√© agora vimos como trabalhar com um √∫nico valor, ou seja, como se fosse no visor de uma calculadora. Mas, √© poss√≠vel ir al√©m. Ao inv√©s de termos teclas de mem√≥ria, o computador nos oferece vari√°veis. Elas s√£o como nomes para valores que queremos guardar e usar mais tarde.

Al√©m das opera√ß√µes b√°sicas tamb√©m temos as opera√ß√µes matem√°ticas (fun√ß√µes), como por exemplo o seno, sin em ingl√™s. Para saber como uma fun√ß√£o funciona podemos pedir ajuda ao ambiente, usando uma `?` ou o macro `@doc`, e em seguida digitando o que queremos saber, como por exemplo em:

```{julia}
#| eval: false
@doc sin
```

A sa√≠da desse comando indica a opera√ß√£o que a fun√ß√£o realiza e ainda apresenta alguns exemplos: 

```
  sin(x)

  Compute sine of x, where x is in radians.

  See also sind, sinpi, sincos, cis, asin.

  Examples
  ‚â°‚â°‚â°‚â°‚â°‚â°‚â°‚â°

  julia> round.(sin.(range(0, 2pi, length=9)'), digits=3)
  1√ó9 Matrix{Float64}:
   0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0
```


Ambos os comandos `? sin` `@doc sin` possuem a mesma sa√≠da.


Notem que nem tudo que foi apresentado faz sentido no momento, mas j√° d√° para entender o uso de uma fun√ß√£o como sin. Vejamos agora a raiz quadrada:

```{julia}
#| eval: false
@doc sqrt
```

Nela vemos que √© poss√≠vel calcular a raiz como em:

```{julia}
sqrt(4)
```

```{julia}
sqrt(4.0)
```

Mas, observamos tamb√©m na documenta√ß√£o a fun√ß√£o `big()`, que tem a seguinte ajuda:

```{julia}
#| eval: false
@doc BigInt
```

A fun√ß√£o `big()` em Julia √© usada para criar n√∫meros inteiros grandes, representados pelo tipo BigInt. Essa fun√ß√£o √© especialmente √∫til quando voc√™ precisa lidar com n√∫meros muito grandes que excedem o limite dos tipos inteiros padr√£o, como Int64 ou Int32.

Com n√∫meros BigInt, j√° n√£o h√° problemas de estouro, como podemos ver abaixo:

```{julia}
big(2) ^ 1002
```


Podemos ainda carregar fun√ß√µes de outros arquivos em nosso arquivo Julia ou no pr√≥prio terminal, para isso basta utilizar o comando `include("caminho/do/arquivo.jl")`, Julia l√™ o arquivo especificado e executa todo o seu conte√∫do no contexto atual. Isso significa que todas as fun√ß√µes, vari√°veis e defini√ß√µes no arquivo tornam-se dispon√≠veis no ambiente onde `include` foi chamado.

Como por exemplo no primeiro caso tenho um arquivo chamado `funcoes.jl` que possui a fun√ß√£o soma:

```{julia}
function ola(nome)
    println("Ol√°", nome)
end

```

Podemos incluir essa fun√ß√£o em um segundo arquivo utilizando o `include("funcoes.jl")`, e utilizar a fun√ß√£o definida no arquivo `funcoes.jl`

```
    include("funcoes.jl")
    println(ola("Alfredo"))  
```

Cuja sa√≠da dever√° ser `Ol√° Alfredo`.

## Vari√°veis e seus tipos

Em Julia tamb√©m temos o conceito de vari√°veis, que servem para armazenar os diferentes conte√∫dos de dados poss√≠veis.

```{julia}
a = 7
2 + a
```


### Tipagem din√¢mica

√â importante notar que as vari√°veis em Julia podem receber novos valores e o tipo da vari√°vel depende do que foi atribu√≠do por √∫ltimo.

```{julia}
a = 3
typeof(a)
```

```{julia}
a = a + 1
typeof(a)
```

Neste pr√≥ximo exemplo, a vari√°vel b √© inicializada com um valor de tipo inteiro, contudo, ap√≥s a opera√ß√£o de multiplica√ß√£o, seu valor √© do tipo ponto flutuante:

```{julia}
b = 3
b = b * 0.5
typeof(b)
```

A tipagem din√¢mica apresenta diversas vantagens, entre elas a flexibilidade, pois √© poss√≠vel reutilizar vari√°veis para armazenar diferentes tipos de dados ao longo do tempo; e menos verbosidade, pois n√£o √© necess√°rio especificar o tipo de cada vari√°vel, o que melhora a legibilidade do c√≥digo.

Aproveitando o momento, podemos ver que h√° v√°rios tipos primitivos em Julia, sendo os principais:

```{julia}
typeof(1)
```

```{julia}
typeof(1.1)
```

```{julia}
typeof("Bom dia")
```

Falando em Strings, elas s√£o definidas por conjuntos de caracteres entre aspas como:

```{julia}
s1 = "Olha que legal"
s2 = "Outra String"
```

D√° tamb√©m para fazer opera√ß√µes com strings como concatena√ß√£o:

```{julia}
s1 = "Tenha um"
s2 = " Bom dia"
s3 = s1 * s2
```

Ou pot√™ncia:

```{julia}
s = "Nao vou mais fazer coisas que possam desagradar os meus colegas "
s ^ 10
```

Ainda sobre vari√°veis, h√° umas regras com rela√ß√£o aos seus nomes, tem que come√ßar com uma letra (ou com `_`), pode ter d√≠gitos e n√£o pode ser uma palavra reservada. √â bom notar que Julia por ser uma linguagem moderna, aceita nomes de caracteres em unicode, por exemplo o Œî (`\Delta`):

```{julia}
Œî = 2
```

Mas, a linguagem vai bem al√©m com caracteres de animais e s√≠mbolos:

```{julia}
üê± = 5 # \:cat: <tab>
üê∂ = 3 # \:dog: <tab>
üè† = 20 # \:house: <tab>
```

Isso n√£o adiciona nada do lado de algoritmos, mas √© poss√≠vel ter vari√°veis bem bonitinhas. A lista de figuras pode ser encontrada [aqui](   ://docs.julialang.org/en/v1/manual/unicode-input/).

## Sa√≠da de dados
Para fazer sa√≠das usam-se dois comandos, `print()` e o `println()`, sendo que o primeiro n√£o pula linha e o segundo pula.

```{julia}
print("Hello ")
println("World!")
println("Ola, mundo!")
```

Para evitar que se digitem muitos caracteres, por vezes podemos usar "a√ßucares sint√°ticos".

```{julia}
x = 1
x = x + 1
x += 1  # forma equivalente a acima, o mesmo vale para os operadores *, - e /
```

Acima, vimos a forma de se inserir coment√°rios em Julia (sim esses ser√£o ignorados pelo computador).


Exerc√≠cio:
Fa√ßa o passo a passo para encontrar as ra√≠zes da equa√ß√£o de segundo grau $x^2 - 5 x + 6$, usando
as v√°riaveis `a`, `b`, `c`, `\Delta`, `x1` e `x2`. Ap√≥s isso, compare com a solu√ß√£o a seguir:

```{julia}

# Defini√ß√£o dos coeficientes
a = 1
b = -5
c = 6

# C√°lculo do discriminante
delta = b^2 - 4 * a * c

# C√°lculo das ra√≠zes
if delta >= 0
    x1 = (-b + sqrt(delta)) / (2 * a)
    x2 = (-b - sqrt(delta)) / (2 * a)
    println("As ra√≠zes s√£o: x1 = $x1 e x2 = $x2")
else
    println("A equa√ß√£o n√£o possui ra√≠zes reais.")
end

```
