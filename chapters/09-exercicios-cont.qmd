---
engine: julia
---

# Revisitando a aula passada

Al√©m de discutirmos o que vimos na aula passada. Nessa aula,
vimos uma nova solu√ß√£o para o problema de verificar de um n√∫mero √©
pal√≠ndromo.

Para isso usamos uma t√©cnica um pouco diferente, ou seja, ao inv√©s
de inverter o n√∫mero e compar√°-lo com o original. Verificamos se
os seus extremos s√£o iguais.

Observe o n√∫mero 234432, o primeiro passo seria verificar que nos extremos,
mais significativo e menos significativo, temos os n√∫meros 2. Em seguida,
podemos continuar com a verifica√ß√£o para o n√∫mero 3443. Se em algum momento
a verifica√ß√£o falhar o n√∫mero n√£o √© pal√≠ndromo.

Seguem os testes e o c√≥digo abaixo.

``` {julia}
using Test

function testaPal()
  @test testaPal(1)
  @test testaPal(131)
  @test testaPal(22)
  @test testaPal(53877835)
  @test !testaPal(123)
  @test !testaPal(23452)
  println("Final dos testes")
end

function testaPal(n::Int64)
# o primeiro passo √© encontrar um n√∫mero com o mesmo n√∫mero de d√≠gitos de n
  pot10 = 1
  while pot10 < n
    pot10 = pot10 * 10
  end
  pot10 = div(pot10, 10)


  while n > 9
    d1 = n % 10
    d2 = div(n, pot10)
    if d1 != d2
      return false
    end
    n = div(n % pot10, 10)
    pot10 = div(pot10, 100)
  end
  return true
end 
``` 

## Aleatoreidade

Em julia temos a fun√ß√£o rand() que devolve um n√∫mero em ponto flutuante entre 0 e 1.
Conforme os par√¢metros, podemos ter outros tipos de n√∫mero como:

``` {julia}
rand(Int)  # devolve um inteiro
rand(1:10) # devolve um n√∫mero entre 1 e 10
rand(Bool) # devolve verdadeiro ou falso
```

Mas, antes de ver um c√≥digo com rand(). Vamos pensar em um problema da vida real. Imagine 
que temos que fazer um sorteio justo, e o √∫nico instrumento que possu√≠mos para o sorteio
√© uma moeda viciada. Que tem como resultado muito mais faces do que coroas. D√° para usar
essa moeda em um sorteio justo?

A ideia para resolver o problema √© olhar para pares de sorteios. Ou seja, vamos ignorar
sorteios onde tenhamos duas faces ou duas coroas. Nos outros, teremos uma coroa e
uma face ou vice versa. As chances das duas ser√£o de 50%. Logo podemos assim, corrigir a 
moeda viciada.

Para simplificar o exerc√≠cio, a moeda pode devolver 0, ou 1, correspondentes
a cara ou a coroa. Observe a seguinte fun√ß√£o que simula uma moeda viciada.

``` {julia}
function sorteio()
  if rand() > 0.90
    return 1
  else 
    return 0
  end
end
```

Pode se observar que a fun√ß√£o devolve 0 na maior parte das vezes. Podemos
inclusive ver isso, fazendo mil sorteios:

``` {julia}
function verificaSorteio()
   cara = 0
   coroa = 0
   i = 0
   while i < 1000
     if sorteio() == 0
        cara = cara + 1
     else
        coroa = coroa + 1
     end
     i = i + 1
   end
   println("O n√∫mero de caras foi: ", cara," e de coroas foi :", coroa)
end
```

Mas, podemos corrigir o sorteio da seguinte forma:

``` {julia}
function sorteioBom()
   sorteio1 = sorteio()
   sorteio2 = sorteio()
   while sorteio1 == sorteio2 # se forem iguais, tente novamente
     sorteio1 = sorteio()
     sorteio2 = sorteio()
   end
   return sorteio1   # ao termos um diferente, podemos devolver o primeiro sorteio
end
```

Podemos usar o verificaSorteio para ver a diferen√ßa.

``` {julia}
function verificaSorteio()
   cara = 0
   coroa = 0
   i = 0
   while i < 1000
     if sorteioBom() == 0
        cara = cara + 1
     else
        coroa = coroa + 1
     end
     i = i + 1
   end
   println("O n√∫mero de caras foi: ", cara," e de coroas foi :", coroa)
end
```

Podemos ainda aproximar o n√∫mero de Euler (ùëí), constante matem√°tica que √© a base dos logaritmos naturais, usando uma simula√ß√£o probabil√≠stica.
A ideia por tr√°s desse c√≥digo √© que o n√∫mero m√©dio de tentativas necess√°rias para que a soma de n√∫meros aleat√≥rios entre 0 e 1 ultrapasse 1 se aproxima do valor de ùëí. Isso √© baseado em uma rela√ß√£o matem√°tica que conecta essa situa√ß√£o ao n√∫mero ùëí.

```{julia}
function calculaEuler(total)
    soma_tentativas = 0
    for i in 1:total
        soma = 0.0
        tentativas = 0      
        while soma <= 1   # Continue gerando n√∫meros at√© a soma ultrapassar 1
            soma += rand()     # Gera n√∫mero aleat√≥rio entre 0 e 1
            tentativas += 1
        end        
        soma_tentativas += tentativas     # Somar o n√∫mero de tentativas necess√°rias
    end 
    return soma_tentativas / total     # A m√©dia do n√∫mero de tentativas ser√° uma estimativa de e
end

println("Estimativa de e (1000 itera√ß√µes): ", calculaEuler(1000))
println("Estimativa de e (100000 itera√ß√µes): ", calculaEuler(100000))
println("Estimativa de e (100000000 itera√ß√µes): ", calculaEuler(100000000))
```


Para terminar a aula vamos aplicar o m√©todo de Monte Carlo para o c√°lculo de Pi.
Imaginem o primeiro quadrante, onde temos um semi-c√≠rculo de raio 1, dentro de um
quadrado de lado 1. Podemos sortear valores, os que sairem dentro do c√≠rculo podem
contar para a √°rea desse. Mais informa√ß√µes podem ser vistas aqui (https://pt.wikipedia.org/wiki/M%C3%A9todo_de_Monte_Carlo)

``` {julia}
function calculaPi(total)
   noAlvo = 0
   i = 0
   while i < total
     x = rand() / 2.0 # gera um n√∫mero entre 0 e 0.5
     y = rand() / 2.0
     if sqrt(x * x + y * y) <= 0.5
       noAlvo = noAlvo + 1
     end
     i = i + 1
   end
   return 4 * (noAlvo / total)  # precisamos multiplicar para ter a √°rea de 4 quadrantes
end 

println(calculaPi(100))
println(calculaPi(1000000))
println(calculaPi(1000000000))
```